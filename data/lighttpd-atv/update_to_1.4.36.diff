diff -u lighttpd-1.4.32/src/array.c lighttpd-1.4.36/src/array.c
--- lighttpd-1.4.32/src/array.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/array.c	2015-07-26 05:36:36.000000000 -0500
@@ -13,7 +13,7 @@
 	array *a;
 
 	a = calloc(1, sizeof(*a));
-	assert(a);
+	force_assert(a);
 
 	a->next_power_of_2 = 1;
 
@@ -24,6 +24,8 @@
 	size_t i;
 	array *a = array_init();
 
+	if (0 == src->size) return a;
+
 	a->used = src->used;
 	a->size = src->size;
 	a->next_power_of_2 = src->next_power_of_2;
@@ -72,7 +74,7 @@
 data_unset *array_pop(array *a) {
 	data_unset *du;
 
-	assert(a->used != 0);
+	force_assert(a->used != 0);
 
 	a->used --;
 	du = a->data[a->used];
@@ -96,7 +98,7 @@
 		} else if (pos >= (int)a->used) {
 			pos -= i;
 		} else {
-			cmp = buffer_caseless_compare(key, keylen, a->data[a->sorted[pos]]->key->ptr, a->data[a->sorted[pos]]->key->used);
+			cmp = buffer_caseless_compare(key, keylen, CONST_BUF_LEN(a->data[a->sorted[pos]]->key));
 
 			if (cmp == 0) {
 				/* found */
@@ -119,7 +121,7 @@
 data_unset *array_get_element(array *a, const char *key) {
 	int ndx;
 
-	if (-1 != (ndx = array_get_index(a, key, strlen(key) + 1, NULL))) {
+	if (-1 != (ndx = array_get_index(a, key, strlen(key), NULL))) {
 		/* found, leave here */
 
 		return a->data[ndx];
@@ -168,7 +170,8 @@
 data_unset *array_replace(array *a, data_unset *du) {
 	int ndx;
 
-	if (-1 == (ndx = array_get_index(a, du->key->ptr, du->key->used, NULL))) {
+	force_assert(NULL != du);
+	if (-1 == (ndx = array_get_index(a, CONST_BUF_LEN(du->key), NULL))) {
 		array_insert_unique(a, du);
 		return NULL;
 	} else {
@@ -184,13 +187,13 @@
 	size_t j;
 
 	/* generate unique index if neccesary */
-	if (str->key->used == 0 || str->is_index_key) {
-		buffer_copy_long(str->key, a->unique_ndx++);
+	if (buffer_is_empty(str->key) || str->is_index_key) {
+		buffer_copy_int(str->key, a->unique_ndx++);
 		str->is_index_key = 1;
 	}
 
 	/* try to find the string */
-	if (-1 != (ndx = array_get_index(a, str->key->ptr, str->key->used, &pos))) {
+	if (-1 != (ndx = array_get_index(a, CONST_BUF_LEN(str->key), &pos))) {
 		/* found, leave here */
 		if (a->data[ndx]->type == str->type) {
 			str->insert_dup(a->data[ndx], str);
@@ -211,15 +214,15 @@
 		a->size   = 16;
 		a->data   = malloc(sizeof(*a->data)     * a->size);
 		a->sorted = malloc(sizeof(*a->sorted)   * a->size);
-		assert(a->data);
-		assert(a->sorted);
+		force_assert(a->data);
+		force_assert(a->sorted);
 		for (j = a->used; j < a->size; j++) a->data[j] = NULL;
 	} else if (a->size == a->used) {
 		a->size  += 16;
 		a->data   = realloc(a->data,   sizeof(*a->data)   * a->size);
 		a->sorted = realloc(a->sorted, sizeof(*a->sorted) * a->size);
-		assert(a->data);
-		assert(a->sorted);
+		force_assert(a->data);
+		force_assert(a->sorted);
 		for (j = a->used; j < a->size; j++) a->data[j] = NULL;
 	}
 
@@ -232,7 +235,7 @@
 
 	if (pos != ndx &&
 	    ((pos < 0) ||
-	     buffer_caseless_compare(str->key->ptr, str->key->used, a->data[a->sorted[pos]]->key->ptr, a->data[a->sorted[pos]]->key->used) > 0)) {
+	     buffer_caseless_compare(CONST_BUF_LEN(str->key), CONST_BUF_LEN(a->data[a->sorted[pos]]->key)) > 0)) {
 		pos++;
 	}
 
diff -u lighttpd-1.4.32/src/base.h lighttpd-1.4.36/src/base.h
--- lighttpd-1.4.32/src/base.h	2011-11-30 13:43:35.000000000 -0600
+++ lighttpd-1.4.36/src/base.h	2015-07-26 05:36:36.000000000 -0500
@@ -222,7 +222,6 @@
 
 #ifdef HAVE_FAM_H
 	int    dir_version;
-	int    dir_ndx;
 #endif
 
 	buffer *content_type;
@@ -235,7 +234,7 @@
 #ifdef HAVE_FAM_H
 	splay_tree *dirs; /* the nodes of the tree are fam_dir_entry */
 
-	FAMConnection *fam;
+	FAMConnection fam;
 	int    fam_fcce_ndx;
 #endif
 	buffer *hash_key;  /* temp-store for the hash-key */
@@ -278,6 +277,7 @@
 	buffer *ssl_dh_file;
 	buffer *ssl_ec_curve;
 	unsigned short ssl_honor_cipher_order; /* determine SSL cipher in server-preferred order, not client-order */
+	unsigned short ssl_empty_fragments; /* whether to not set SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS */
 	unsigned short ssl_use_sslv2;
 	unsigned short ssl_use_sslv3;
 	unsigned short ssl_verifyclient;
@@ -289,7 +289,7 @@
 
 	unsigned short use_ipv6, set_v6only; /* set_v6only is only a temporary option */
 	unsigned short defer_accept;
-	unsigned short is_ssl;
+	unsigned short ssl_enabled; /* only interesting for setting up listening sockets. don't use at runtime */
 	unsigned short allow_http11;
 	unsigned short etag_use_inode;
 	unsigned short etag_use_mtime;
@@ -319,7 +319,11 @@
 	off_t *global_bytes_per_second_cnt_ptr; /*  */
 
 #ifdef USE_OPENSSL
-	SSL_CTX *ssl_ctx;
+	SSL_CTX *ssl_ctx; /* not patched */
+	/* SNI per host: with COMP_SERVER_SOCKET, COMP_HTTP_SCHEME, COMP_HTTP_HOST */
+	EVP_PKEY *ssl_pemfile_pkey;
+	X509 *ssl_pemfile_x509;
+	STACK_OF(X509_NAME) *ssl_ca_file_cert_names;
 #endif
 } specific_config;
 
@@ -410,7 +414,6 @@
 
 	size_t header_len;
 
-	buffer *authed_user;
 	array  *environment; /* used to pass lighttpd internal stuff to the FastCGI/CGI apps, setenv does that */
 
 	/* response */
@@ -432,7 +435,7 @@
 	int error_handler_saved_status;
 	int in_error_handler;
 
-	void *srv_socket;   /* reference to the server-socket (typecast to server_socket) */
+	struct server_socket *srv_socket;   /* reference to the server-socket */
 
 #ifdef USE_OPENSSL
 	SSL *ssl;
@@ -525,19 +528,11 @@
 	unsigned short reject_expect_100_with_417;
 } server_config;
 
-typedef struct {
+typedef struct server_socket {
 	sock_addr addr;
 	int       fd;
 	int       fde_ndx;
 
-	buffer *ssl_pemfile;
-	buffer *ssl_ca_file;
-	buffer *ssl_cipher_list;
-	buffer *ssl_dh_file;
-	buffer *ssl_ec_curve;
-	unsigned short ssl_use_sslv2;
-	unsigned short ssl_use_sslv3;
-	unsigned short use_ipv6;
 	unsigned short is_ssl;
 
 	buffer *srv_token;
@@ -545,7 +540,6 @@
 #ifdef USE_OPENSSL
 	SSL_CTX *ssl_ctx;
 #endif
-       unsigned short is_proxy_ssl;
 } server_socket;
 
 typedef struct {
Only in lighttpd-1.4.32/src: bitset.c
Only in lighttpd-1.4.32/src: bitset.h
diff -u lighttpd-1.4.32/src/buffer.c lighttpd-1.4.36/src/buffer.c
--- lighttpd-1.4.32/src/buffer.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.36/src/buffer.c	2015-07-26 05:36:36.000000000 -0500
@@ -7,10 +7,8 @@
 #include <assert.h>
 #include <ctype.h>
 
-
 static const char hex_chars[] = "0123456789abcdef";
 
-
 /**
  * init the buffer
  *
@@ -20,7 +18,7 @@
 	buffer *b;
 
 	b = malloc(sizeof(*b));
-	assert(b);
+	force_assert(b);
 
 	b->ptr = NULL;
 	b->size = 0;
@@ -29,177 +27,177 @@
 	return b;
 }
 
-buffer *buffer_init_buffer(buffer *src) {
+buffer *buffer_init_buffer(const buffer *src) {
 	buffer *b = buffer_init();
-	buffer_copy_string_buffer(b, src);
+	buffer_copy_buffer(b, src);
 	return b;
 }
 
-/**
- * free the buffer
- *
- */
+buffer *buffer_init_string(const char *str) {
+	buffer *b = buffer_init();
+	buffer_copy_string(b, str);
+	return b;
+}
 
 void buffer_free(buffer *b) {
-	if (!b) return;
+	if (NULL == b) return;
 
 	free(b->ptr);
 	free(b);
 }
 
 void buffer_reset(buffer *b) {
-	if (!b) return;
+	if (NULL == b) return;
 
 	/* limit don't reuse buffer larger than ... bytes */
 	if (b->size > BUFFER_MAX_REUSE_SIZE) {
 		free(b->ptr);
 		b->ptr = NULL;
 		b->size = 0;
-	} else if (b->size) {
+	} else if (b->size > 0) {
 		b->ptr[0] = '\0';
 	}
 
 	b->used = 0;
 }
 
+void buffer_move(buffer *b, buffer *src) {
+	buffer tmp;
 
-/**
- *
- * allocate (if neccessary) enough space for 'size' bytes and
- * set the 'used' counter to 0
- *
- */
+	if (NULL == b) {
+		buffer_reset(src);
+		return;
+	}
+	buffer_reset(b);
+	if (NULL == src) return;
 
-#define BUFFER_PIECE_SIZE 64
+	tmp = *src; *src = *b; *b = tmp;
+}
 
-int buffer_prepare_copy(buffer *b, size_t size) {
-	if (!b) return -1;
+#define BUFFER_PIECE_SIZE 64
+static size_t buffer_align_size(size_t size) {
+	size_t align = BUFFER_PIECE_SIZE - (size % BUFFER_PIECE_SIZE);
+	/* overflow on unsinged size_t is defined to wrap around */
+	if (size + align < size) return size;
+	return size + align;
+}
 
-	if ((0 == b->size) ||
-	    (size > b->size)) {
-		if (b->size) free(b->ptr);
+/* make sure buffer is at least "size" big. discard old data */
+static void buffer_alloc(buffer *b, size_t size) {
+	force_assert(NULL != b);
+	if (0 == size) size = 1;
 
-		b->size = size;
+	if (size <= b->size) return;
 
-		/* always allocate a multiply of BUFFER_PIECE_SIZE */
-		b->size += BUFFER_PIECE_SIZE - (b->size % BUFFER_PIECE_SIZE);
+	if (NULL != b->ptr) free(b->ptr);
 
-		b->ptr = malloc(b->size);
-		assert(b->ptr);
-	}
 	b->used = 0;
-	return 0;
+	b->size = buffer_align_size(size);
+	b->ptr = malloc(b->size);
+
+	force_assert(NULL != b->ptr);
 }
 
-/**
- *
- * increase the internal buffer (if neccessary) to append another 'size' byte
- * ->used isn't changed
- *
- */
+/* make sure buffer is at least "size" big. keep old data */
+static void buffer_realloc(buffer *b, size_t size) {
+	force_assert(NULL != b);
+	if (0 == size) size = 1;
 
-int buffer_prepare_append(buffer *b, size_t size) {
-	if (!b) return -1;
+	if (size <= b->size) return;
 
-	if (0 == b->size) {
-		b->size = size;
+	b->size = buffer_align_size(size);
+	b->ptr = realloc(b->ptr, b->size);
 
-		/* always allocate a multiply of BUFFER_PIECE_SIZE */
-		b->size += BUFFER_PIECE_SIZE - (b->size % BUFFER_PIECE_SIZE);
+	force_assert(NULL != b->ptr);
+}
 
-		b->ptr = malloc(b->size);
-		b->used = 0;
-		assert(b->ptr);
-	} else if (b->used + size > b->size) {
-		b->size += size;
 
-		/* always allocate a multiply of BUFFER_PIECE_SIZE */
-		b->size += BUFFER_PIECE_SIZE - (b->size % BUFFER_PIECE_SIZE);
+char* buffer_string_prepare_copy(buffer *b, size_t size) {
+	force_assert(NULL != b);
+	force_assert(size + 1 > size);
 
-		b->ptr = realloc(b->ptr, b->size);
-		assert(b->ptr);
-	}
-	return 0;
-}
+	buffer_alloc(b, size + 1);
 
-int buffer_copy_string(buffer *b, const char *s) {
-	size_t s_len;
+	b->used = 1;
+	b->ptr[0] = '\0';
 
-	if (!s || !b) return -1;
+	return b->ptr;
+}
 
-	s_len = strlen(s) + 1;
-	buffer_prepare_copy(b, s_len);
+char* buffer_string_prepare_append(buffer *b, size_t size) {
+	force_assert(NULL !=  b);
 
-	memcpy(b->ptr, s, s_len);
-	b->used = s_len;
+	if (buffer_string_is_empty(b)) {
+		return buffer_string_prepare_copy(b, size);
+	} else {
+		size_t req_size = b->used + size;
 
-	return 0;
-}
+		/* not empty, b->used already includes a terminating 0 */
+		force_assert(req_size >= b->used);
 
-int buffer_copy_string_len(buffer *b, const char *s, size_t s_len) {
-	if (!s || !b) return -1;
-#if 0
-	/* removed optimization as we have to keep the empty string
-	 * in some cases for the config handling
-	 *
-	 * url.access-deny = ( "" )
-	 */
-	if (s_len == 0) return 0;
-#endif
-	buffer_prepare_copy(b, s_len + 1);
+		/* check for overflow: unsigned overflow is defined to wrap around */
+		force_assert(req_size >= b->used);
 
-	memcpy(b->ptr, s, s_len);
-	b->ptr[s_len] = '\0';
-	b->used = s_len + 1;
+		buffer_realloc(b, req_size);
 
-	return 0;
+		return b->ptr + b->used - 1;
+	}
 }
 
-int buffer_copy_string_buffer(buffer *b, const buffer *src) {
-	if (!src) return -1;
+void buffer_string_set_length(buffer *b, size_t len) {
+	force_assert(NULL != b);
+	force_assert(len + 1 > len);
 
-	if (src->used == 0) {
-		buffer_reset(b);
-		return 0;
-	}
-	return buffer_copy_string_len(b, src->ptr, src->used - 1);
+	buffer_realloc(b, len + 1);
+
+	b->used = len + 1;
+	b->ptr[len] = '\0';
 }
 
-int buffer_append_string(buffer *b, const char *s) {
-	size_t s_len;
+void buffer_commit(buffer *b, size_t size)
+{
+	force_assert(NULL != b);
+	force_assert(b->size > 0);
+
+	if (0 == b->used) b->used = 1;
 
-	if (!s || !b) return -1;
+	if (size > 0) {
+		/* check for overflow: unsigned overflow is defined to wrap around */
+		force_assert(b->used + size > b->used);
 
-	s_len = strlen(s);
-	buffer_prepare_append(b, s_len + 1);
-	if (b->used == 0)
-		b->used++;
+		force_assert(b->used + size <= b->size);
+		b->used += size;
+	}
 
-	memcpy(b->ptr + b->used - 1, s, s_len + 1);
-	b->used += s_len;
+	b->ptr[b->used - 1] = '\0';
+}
 
-	return 0;
+void buffer_copy_string(buffer *b, const char *s) {
+	buffer_copy_string_len(b, s, NULL != s ? strlen(s) : 0);
 }
 
-int buffer_append_string_rfill(buffer *b, const char *s, size_t maxlen) {
-	size_t s_len;
+void buffer_copy_string_len(buffer *b, const char *s, size_t s_len) {
+	force_assert(NULL != b);
+	force_assert(NULL != s || s_len == 0);
+
+	buffer_string_prepare_copy(b, s_len);
 
-	if (!s || !b) return -1;
+	if (0 != s_len) memcpy(b->ptr, s, s_len);
 
-	s_len = strlen(s);
-	if (s_len > maxlen)  s_len = maxlen;
-	buffer_prepare_append(b, maxlen + 1);
-	if (b->used == 0)
-		b->used++;
+	buffer_commit(b, s_len);
+}
 
-	memcpy(b->ptr + b->used - 1, s, s_len);
-	if (maxlen > s_len) {
-		memset(b->ptr + b->used - 1 + s_len, ' ', maxlen - s_len);
+void buffer_copy_buffer(buffer *b, const buffer *src) {
+	if (NULL == src || 0 == src->used) {
+		buffer_string_prepare_copy(b, 0);
+		b->used = 0; /* keep special empty state for now */
+	} else {
+		buffer_copy_string_len(b, src->ptr, buffer_string_length(src));
 	}
+}
 
-	b->used += maxlen;
-	b->ptr[b->used - 1] = '\0';
-	return 0;
+void buffer_append_string(buffer *b, const char *s) {
+	buffer_append_string_len(b, s, NULL != s ? strlen(s) : 0);
 }
 
 /**
@@ -213,278 +211,192 @@
  * @param s_len size of the string (without the terminating \0)
  */
 
-int buffer_append_string_len(buffer *b, const char *s, size_t s_len) {
-	if (!s || !b) return -1;
-	if (s_len == 0) return 0;
-
-	buffer_prepare_append(b, s_len + 1);
-	if (b->used == 0)
-		b->used++;
+void buffer_append_string_len(buffer *b, const char *s, size_t s_len) {
+	char *target_buf;
 
-	memcpy(b->ptr + b->used - 1, s, s_len);
-	b->used += s_len;
-	b->ptr[b->used - 1] = '\0';
+	force_assert(NULL != b);
+	force_assert(NULL != s || s_len == 0);
 
-	return 0;
-}
+	target_buf = buffer_string_prepare_append(b, s_len);
 
-int buffer_append_string_buffer(buffer *b, const buffer *src) {
-	if (!src) return -1;
-	if (src->used == 0) return 0;
+	if (0 == s_len) return; /* nothing to append */
 
-	return buffer_append_string_len(b, src->ptr, src->used - 1);
-}
+	memcpy(target_buf, s, s_len);
 
-int buffer_append_memory(buffer *b, const char *s, size_t s_len) {
-	if (!s || !b) return -1;
-	if (s_len == 0) return 0;
-
-	buffer_prepare_append(b, s_len);
-	memcpy(b->ptr + b->used, s, s_len);
-	b->used += s_len;
-
-	return 0;
+	buffer_commit(b, s_len);
 }
 
-int buffer_copy_memory(buffer *b, const char *s, size_t s_len) {
-	if (!s || !b) return -1;
-
-	b->used = 0;
-
-	return buffer_append_memory(b, s, s_len);
+void buffer_append_string_buffer(buffer *b, const buffer *src) {
+	if (NULL == src) {
+		buffer_append_string_len(b, NULL, 0);
+	} else {
+		buffer_append_string_len(b, src->ptr, buffer_string_length(src));
+	}
 }
 
-int buffer_append_long_hex(buffer *b, unsigned long value) {
+void buffer_append_uint_hex(buffer *b, uintmax_t value) {
 	char *buf;
 	int shift = 0;
-	unsigned long copy = value;
 
-	while (copy) {
-		copy >>= 4;
-		shift++;
-	}
-	if (shift == 0)
-		shift++;
-	if (shift & 0x01)
-		shift++;
-
-	buffer_prepare_append(b, shift + 1);
-	if (b->used == 0)
-		b->used++;
-	buf = b->ptr + (b->used - 1);
-	b->used += shift;
+	{
+		uintmax_t copy = value;
+		do {
+			copy >>= 8;
+			shift += 2; /* counting nibbles (4 bits) */
+		} while (0 != copy);
+	}
+
+	buf = buffer_string_prepare_append(b, shift);
+	buffer_commit(b, shift); /* will fill below */
 
-	shift <<= 2;
+	shift <<= 2; /* count bits now */
 	while (shift > 0) {
 		shift -= 4;
 		*(buf++) = hex_chars[(value >> shift) & 0x0F];
 	}
-	*buf = '\0';
-
-	return 0;
 }
 
-int LI_ltostr(char *buf, long val) {
-	char swap;
-	char *end;
-	int len = 1;
-
-	if (val < 0) {
-		len++;
-		*(buf++) = '-';
-		val = -val;
-	}
-
-	end = buf;
-	while (val > 9) {
-		*(end++) = '0' + (val % 10);
-		val = val / 10;
-	}
-	*(end) = '0' + val;
-	*(end + 1) = '\0';
-	len += end - buf;
-
-	while (buf < end) {
-		swap = *end;
-		*end = *buf;
-		*buf = swap;
-
-		buf++;
-		end--;
-	}
+static char* utostr(char * const buf_end, uintmax_t val) {
+	char *cur = buf_end;
+	do {
+		int mod = val % 10;
+		val /= 10;
+		/* prepend digit mod */
+		*(--cur) = (char) ('0' + mod);
+	} while (0 != val);
+	return cur;
+}
+
+static char* itostr(char * const buf_end, intmax_t val) {
+	char *cur = buf_end;
+	if (val >= 0) return utostr(buf_end, (uintmax_t) val);
+
+	/* can't take absolute value, as it isn't defined for INTMAX_MIN */
+	do {
+		int mod = val % 10;
+		val /= 10;
+		/* val * 10 + mod == orig val, -10 < mod < 10 */
+		/* we want a negative mod */
+		if (mod > 0) {
+			mod -= 10;
+			val += 1;
+		}
+		/* prepend digit abs(mod) */
+		*(--cur) = (char) ('0' + (-mod));
+	} while (0 != val);
+	*(--cur) = '-';
 
-	return len;
+	return cur;
 }
 
-int buffer_append_long(buffer *b, long val) {
-	if (!b) return -1;
+void buffer_append_int(buffer *b, intmax_t val) {
+	char buf[LI_ITOSTRING_LENGTH];
+	char* const buf_end = buf + sizeof(buf);
+	char *str;
 
-	buffer_prepare_append(b, 32);
-	if (b->used == 0)
-		b->used++;
+	force_assert(NULL != b);
 
-	b->used += LI_ltostr(b->ptr + (b->used - 1), val);
-	return 0;
+	str = itostr(buf_end, val);
+	force_assert(buf_end > str && str >= buf);
+
+	buffer_append_string_len(b, str, buf_end - str);
 }
 
-int buffer_copy_long(buffer *b, long val) {
-	if (!b) return -1;
+void buffer_copy_int(buffer *b, intmax_t val) {
+	force_assert(NULL != b);
 
 	b->used = 0;
-	return buffer_append_long(b, val);
+	buffer_append_int(b, val);
 }
 
-#if !defined(SIZEOF_LONG) || (SIZEOF_LONG != SIZEOF_OFF_T)
-int buffer_append_off_t(buffer *b, off_t val) {
-	char swap;
-	char *end;
-	char *start;
-	int len = 1;
-
-	if (!b) return -1;
+void buffer_append_strftime(buffer *b, const char *format, const struct tm *tm) {
+	size_t r;
+	char* buf;
+	force_assert(NULL != b);
+	force_assert(NULL != tm);
 
-	buffer_prepare_append(b, 32);
-	if (b->used == 0)
-		b->used++;
-
-	start = b->ptr + (b->used - 1);
-	if (val < 0) {
-		len++;
-		*(start++) = '-';
-		val = -val;
-	}
-
-	end = start;
-	while (val > 9) {
-		*(end++) = '0' + (val % 10);
-		val = val / 10;
+	if (NULL == format || '\0' == format[0]) {
+		/* empty format */
+		buffer_string_prepare_append(b, 0);
+		return;
 	}
-	*(end) = '0' + val;
-	*(end + 1) = '\0';
-	len += end - start;
 
-	while (start < end) {
-		swap   = *end;
-		*end   = *start;
-		*start = swap;
+	buf = buffer_string_prepare_append(b, 255);
+	r = strftime(buf, buffer_string_space(b), format, tm);
 
-		start++;
-		end--;
+	/* 0 (in some apis buffer_string_space(b)) signals the string may have
+	 * been too small; but the format could also just have lead to an empty
+	 * string
+	 */
+	if (0 == r || r >= buffer_string_space(b)) {
+		/* give it a second try with a larger string */
+		buf = buffer_string_prepare_append(b, 4095);
+		r = strftime(buf, buffer_string_space(b), format, tm);
 	}
 
-	b->used += len;
-	return 0;
-}
-
-int buffer_copy_off_t(buffer *b, off_t val) {
-	if (!b) return -1;
+	if (r >= buffer_string_space(b)) r = 0;
 
-	b->used = 0;
-	return buffer_append_off_t(b, val);
+	buffer_commit(b, r);
 }
-#endif /* !defined(SIZEOF_LONG) || (SIZEOF_LONG != SIZEOF_OFF_T) */
 
-char int2hex(char c) {
-	return hex_chars[(c & 0x0F)];
-}
-
-/* converts hex char (0-9, A-Z, a-z) to decimal.
- * returns 0xFF on invalid input.
- */
-char hex2int(unsigned char hex) {
-	hex = hex - '0';
-	if (hex > 9) {
-		hex = (hex + '0' - 1) | 0x20;
-		hex = hex - 'a' + 11;
-	}
-	if (hex > 15)
-		hex = 0xFF;
-
-	return hex;
-}
 
+void li_itostrn(char *buf, size_t buf_len, intmax_t val) {
+	char p_buf[LI_ITOSTRING_LENGTH];
+	char* const p_buf_end = p_buf + sizeof(p_buf);
+	char* str = p_buf_end - 1;
+	*str = '\0';
 
-/**
- * init the buffer
- *
- */
-
-buffer_array* buffer_array_init(void) {
-	buffer_array *b;
-
-	b = malloc(sizeof(*b));
-
-	assert(b);
-	b->ptr = NULL;
-	b->size = 0;
-	b->used = 0;
+	str = itostr(str, val);
+	force_assert(p_buf_end > str && str >= p_buf);
 
-	return b;
+	force_assert(buf_len >= (size_t) (p_buf_end - str));
+	memcpy(buf, str, p_buf_end - str);
 }
 
-void buffer_array_reset(buffer_array *b) {
-	size_t i;
-
-	if (!b) return;
-
-	/* if they are too large, reduce them */
-	for (i = 0; i < b->used; i++) {
-		buffer_reset(b->ptr[i]);
-	}
-
-	b->used = 0;
+void li_itostr(char *buf, intmax_t val) {
+	li_itostrn(buf, LI_ITOSTRING_LENGTH, val);
 }
 
+void li_utostrn(char *buf, size_t buf_len, uintmax_t val) {
+	char p_buf[LI_ITOSTRING_LENGTH];
+	char* const p_buf_end = p_buf + sizeof(p_buf);
+	char* str = p_buf_end - 1;
+	*str = '\0';
 
-/**
- * free the buffer_array
- *
- */
-
-void buffer_array_free(buffer_array *b) {
-	size_t i;
-	if (!b) return;
+	str = utostr(str, val);
+	force_assert(p_buf_end > str && str >= p_buf);
 
-	for (i = 0; i < b->size; i++) {
-		if (b->ptr[i]) buffer_free(b->ptr[i]);
-	}
-	free(b->ptr);
-	free(b);
+	force_assert(buf_len >= (size_t) (p_buf_end - str));
+	memcpy(buf, str, p_buf_end - str);
 }
 
-buffer *buffer_array_append_get_buffer(buffer_array *b) {
-	size_t i;
+void li_utostr(char *buf, uintmax_t val) {
+	li_utostrn(buf, LI_ITOSTRING_LENGTH, val);
+}
 
-	if (b->size == 0) {
-		b->size = 16;
-		b->ptr = malloc(sizeof(*b->ptr) * b->size);
-		assert(b->ptr);
-		for (i = 0; i < b->size; i++) {
-			b->ptr[i] = NULL;
-		}
-	} else if (b->size == b->used) {
-		b->size += 16;
-		b->ptr = realloc(b->ptr, sizeof(*b->ptr) * b->size);
-		assert(b->ptr);
-		for (i = b->used; i < b->size; i++) {
-			b->ptr[i] = NULL;
-		}
-	}
+char int2hex(char c) {
+	return hex_chars[(c & 0x0F)];
+}
 
-	if (b->ptr[b->used] == NULL) {
-		b->ptr[b->used] = buffer_init();
+/* converts hex char (0-9, A-Z, a-z) to decimal.
+ * returns 0xFF on invalid input.
+ */
+char hex2int(unsigned char hex) {
+	unsigned char value = hex - '0';
+	if (value > 9) {
+		hex |= 0x20; /* to lower case */
+		value = hex - 'a' + 10;
+		if (value < 10) value = 0xff;
 	}
+	if (value > 15) value = 0xff;
 
-	b->ptr[b->used]->used = 0;
-
-	return b->ptr[b->used++];
+	return value;
 }
 
-
 char * buffer_search_string_len(buffer *b, const char *needle, size_t len) {
 	size_t i;
-	if (len == 0) return NULL;
-	if (needle == NULL) return NULL;
+	force_assert(NULL != b);
+	force_assert(0 != len && NULL != needle); /* empty needles not allowed */
 
 	if (b->used < len) return NULL;
 
@@ -497,17 +409,12 @@
 	return NULL;
 }
 
-buffer *buffer_init_string(const char *str) {
-	buffer *b = buffer_init();
-
-	buffer_copy_string(b, str);
-
-	return b;
+int buffer_is_empty(const buffer *b) {
+	return NULL == b || 0 == b->used;
 }
 
-int buffer_is_empty(buffer *b) {
-	if (!b) return 1;
-	return (b->used == 0);
+int buffer_string_is_empty(const buffer *b) {
+	return 0 == buffer_string_length(b);
 }
 
 /**
@@ -517,115 +424,83 @@
  * alignment properly.
  */
 
-int buffer_is_equal(buffer *a, buffer *b) {
+int buffer_is_equal(const buffer *a, const buffer *b) {
+	force_assert(NULL != a && NULL != b);
+
 	if (a->used != b->used) return 0;
 	if (a->used == 0) return 1;
 
-	return (0 == strcmp(a->ptr, b->ptr));
+	return (0 == memcmp(a->ptr, b->ptr, a->used));
 }
 
-int buffer_is_equal_string(buffer *a, const char *s, size_t b_len) {
-	buffer b;
+int buffer_is_equal_string(const buffer *a, const char *s, size_t b_len) {
+	force_assert(NULL != a && NULL != s);
+	force_assert(b_len + 1 > b_len);
 
-	b.ptr = (char *)s;
-	b.used = b_len + 1;
+	if (a->used != b_len + 1) return 0;
+	if (0 != memcmp(a->ptr, s, b_len)) return 0;
+	if ('\0' != a->ptr[a->used-1]) return 0;
 
-	return buffer_is_equal(a, &b);
+	return 1;
 }
 
-/* simple-assumption:
- *
- * most parts are equal and doing a case conversion needs time
- *
- */
-int buffer_caseless_compare(const char *a, size_t a_len, const char *b, size_t b_len) {
-	size_t ndx = 0, max_ndx;
-	size_t *al, *bl;
-	size_t mask = sizeof(*al) - 1;
-
-	al = (size_t *)a;
-	bl = (size_t *)b;
-
-	/* is the alignment correct ? */
-	if ( ((size_t)al & mask) == 0 &&
-	     ((size_t)bl & mask) == 0 ) {
-
-		max_ndx = ((a_len < b_len) ? a_len : b_len) & ~mask;
-
-		for (; ndx < max_ndx; ndx += sizeof(*al)) {
-			if (*al != *bl) break;
-			al++; bl++;
-
-		}
-
-	}
-
-	a = (char *)al;
-	b = (char *)bl;
+/* buffer_is_equal_caseless_string(b, CONST_STR_LEN("value")) */
+int buffer_is_equal_caseless_string(const buffer *a, const char *s, size_t b_len) {
+	force_assert(NULL != a);
+	if (a->used != b_len + 1) return 0;
+	force_assert('\0' == a->ptr[a->used - 1]);
 
-	max_ndx = ((a_len < b_len) ? a_len : b_len);
+	return (0 == strcasecmp(a->ptr, s));
+}
 
-	for (; ndx < max_ndx; ndx++) {
-		int a1 = *a++, b1 = *b++;
+int buffer_caseless_compare(const char *a, size_t a_len, const char *b, size_t b_len) {
+	size_t const len = (a_len < b_len) ? a_len : b_len;
+	size_t i;
 
-		if (a1 != b1) {
-			/* always lowercase for transitive results */
-			if (a1 >= 'A' && a1 <= 'Z') a1 |= 32;
-			if (b1 >= 'A' && b1 <= 'Z') b1 |= 32;
+	for (i = 0; i < len; ++i) {
+		unsigned char ca = a[i], cb = b[i];
+		if (ca == cb) continue;
+
+		/* always lowercase for transitive results */
+		if (ca >= 'A' && ca <= 'Z') ca |= 32;
+		if (cb >= 'A' && cb <= 'Z') cb |= 32;
 
-			if ((a1 - b1) != 0) return (a1 - b1);
-		}
+		if (ca == cb) continue;
+		return ca - cb;
 	}
-
-	/* all chars are the same, and the length match too
-	 *
-	 * they are the same */
 	if (a_len == b_len) return 0;
-
-	/* if a is shorter then b, then b is larger */
-	return (a_len - b_len);
+	return a_len < b_len ? -1 : 1;
 }
 
-
-/**
- * check if the rightmost bytes of the string are equal.
- *
- *
- */
-
-int buffer_is_equal_right_len(buffer *b1, buffer *b2, size_t len) {
-	/* no, len -> equal */
+int buffer_is_equal_right_len(const buffer *b1, const buffer *b2, size_t len) {
+	/* no len -> equal */
 	if (len == 0) return 1;
 
 	/* len > 0, but empty buffers -> not equal */
 	if (b1->used == 0 || b2->used == 0) return 0;
 
 	/* buffers too small -> not equal */
-	if (b1->used - 1 < len || b1->used - 1 < len) return 0;
+	if (b1->used - 1 < len || b2->used - 1 < len) return 0;
 
-	if (0 == strncmp(b1->ptr + b1->used - 1 - len,
-			 b2->ptr + b2->used - 1 - len, len)) {
-		return 1;
-	}
-
-	return 0;
+	return 0 == memcmp(b1->ptr + b1->used - 1 - len, b2->ptr + b2->used - 1 - len, len);
 }
 
-int buffer_copy_string_hex(buffer *b, const char *in, size_t in_len) {
+void li_tohex(char *buf, const char *s, size_t s_len) {
 	size_t i;
 
-	/* BO protection */
-	if (in_len * 2 < in_len) return -1;
-
-	buffer_prepare_copy(b, in_len * 2 + 1);
-
-	for (i = 0; i < in_len; i++) {
-		b->ptr[b->used++] = hex_chars[(in[i] >> 4) & 0x0F];
-		b->ptr[b->used++] = hex_chars[in[i] & 0x0F];
+	for (i = 0; i < s_len; i++) {
+		buf[2*i] = hex_chars[(s[i] >> 4) & 0x0F];
+		buf[2*i+1] = hex_chars[s[i] & 0x0F];
 	}
-	b->ptr[b->used++] = '\0';
+	buf[2*s_len] = '\0';
+}
+
+void buffer_copy_string_hex(buffer *b, const char *in, size_t in_len) {
+	/* overflow protection */
+	force_assert(in_len * 2 > in_len);
 
-	return 0;
+	buffer_string_set_length(b, 2 * in_len);
+	li_tohex(b->ptr, in, in_len);
 }
 
 /* everything except: ! ( ) * - . 0-9 A-Z _ a-z */
@@ -764,18 +639,15 @@
 
 
 
-int buffer_append_string_encoded(buffer *b, const char *s, size_t s_len, buffer_encoding_t encoding) {
+void buffer_append_string_encoded(buffer *b, const char *s, size_t s_len, buffer_encoding_t encoding) {
 	unsigned char *ds, *d;
 	size_t d_len, ndx;
 	const char *map = NULL;
 
-	if (!s || !b) return -1;
+	force_assert(NULL != b);
+	force_assert(NULL != s || 0 == s_len);
 
-	if (b->ptr[b->used - 1] != '\0') {
-		SEGFAULT();
-	}
-
-	if (s_len == 0) return 0;
+	if (0 == s_len) return;
 
 	switch(encoding) {
 	case ENCODING_REL_URI:
@@ -796,11 +668,9 @@
 	case ENCODING_HTTP_HEADER:
 		map = encoded_chars_http_header;
 		break;
-	case ENCODING_UNSET:
-		break;
 	}
 
-	assert(map != NULL);
+	force_assert(NULL != map);
 
 	/* count to-be-encoded-characters */
 	for (ds = (unsigned char *)s, d_len = 0, ndx = 0; ndx < s_len; ds++, ndx++) {
@@ -818,17 +688,17 @@
 			case ENCODING_HEX:
 				d_len += 2;
 				break;
-			case ENCODING_UNSET:
-				break;
 			}
 		} else {
-			d_len ++;
+			d_len++;
 		}
 	}
 
-	buffer_prepare_append(b, d_len);
+	d = (unsigned char*) buffer_string_prepare_append(b, d_len);
+	buffer_commit(b, d_len); /* fill below */
+	force_assert('\0' == *d);
 
-	for (ds = (unsigned char *)s, d = (unsigned char *)b->ptr + b->used - 1, d_len = 0, ndx = 0; ndx < s_len; ds++, ndx++) {
+	for (ds = (unsigned char *)s, d_len = 0, ndx = 0; ndx < s_len; ds++, ndx++) {
 		if (map[*ds]) {
 			switch(encoding) {
 			case ENCODING_REL_URI:
@@ -854,47 +724,135 @@
 				d[d_len++] = *ds;
 				d[d_len++] = '\t';
 				break;
-			case ENCODING_UNSET:
-				break;
 			}
 		} else {
 			d[d_len++] = *ds;
 		}
 	}
+}
+
+void buffer_append_string_c_escaped(buffer *b, const char *s, size_t s_len) {
+	unsigned char *ds, *d;
+	size_t d_len, ndx;
 
-	/* terminate buffer and calculate new length */
-	b->ptr[b->used + d_len - 1] = '\0';
+	force_assert(NULL != b);
+	force_assert(NULL != s || 0 == s_len);
 
-	b->used += d_len;
+	if (0 == s_len) return;
 
-	return 0;
+	/* count to-be-encoded-characters */
+	for (ds = (unsigned char *)s, d_len = 0, ndx = 0; ndx < s_len; ds++, ndx++) {
+		if ((*ds < 0x20) /* control character */
+				|| (*ds >= 0x7f)) { /* DEL + non-ASCII characters */
+			switch (*ds) {
+			case '\t':
+			case '\r':
+			case '\n':
+				d_len += 2;
+				break;
+			default:
+				d_len += 4; /* \xCC */
+				break;
+			}
+		} else {
+			d_len++;
+		}
+	}
+
+	d = (unsigned char*) buffer_string_prepare_append(b, d_len);
+	buffer_commit(b, d_len); /* fill below */
+	force_assert('\0' == *d);
+
+	for (ds = (unsigned char *)s, d_len = 0, ndx = 0; ndx < s_len; ds++, ndx++) {
+		if ((*ds < 0x20) /* control character */
+				|| (*ds >= 0x7f)) { /* DEL + non-ASCII characters */
+			d[d_len++] = '\\';
+			switch (*ds) {
+			case '\t':
+				d[d_len++] = 't';
+				break;
+			case '\r':
+				d[d_len++] = 'r';
+				break;
+			case '\n':
+				d[d_len++] = 'n';
+				break;
+			default:
+				d[d_len++] = 'x';
+				d[d_len++] = hex_chars[((*ds) >> 4) & 0x0F];
+				d[d_len++] = hex_chars[(*ds) & 0x0F];
+				break;
+			}
+		} else {
+			d[d_len++] = *ds;
+		}
+	}
 }
 
 
+void buffer_copy_string_encoded_cgi_varnames(buffer *b, const char *s, size_t s_len, int is_http_header) {
+	size_t i, j;
+
+	force_assert(NULL != b);
+	force_assert(NULL != s || 0 == s_len);
+
+	buffer_reset(b);
+
+	if (is_http_header && NULL != s && 0 != strcasecmp(s, "CONTENT-TYPE")) {
+		buffer_string_prepare_append(b, s_len + 5);
+		buffer_copy_string_len(b, CONST_STR_LEN("HTTP_"));
+	} else {
+		buffer_string_prepare_append(b, s_len);
+	}
+
+	j = buffer_string_length(b);
+	for (i = 0; i < s_len; ++i) {
+		unsigned char cr = s[i];
+		if (light_isalpha(cr)) {
+			/* upper-case */
+			cr &= ~32;
+		} else if (!light_isdigit(cr)) {
+			cr = '_';
+		}
+		b->ptr[j++] = cr;
+	}
+	b->used = j;
+	b->ptr[b->used++] = '\0';
+}
+
 /* decodes url-special-chars inplace.
  * replaces non-printable characters with '_'
  */
 
-static int buffer_urldecode_internal(buffer *url, int is_query) {
+static void buffer_urldecode_internal(buffer *url, int is_query) {
 	unsigned char high, low;
-	const char *src;
+	char *src;
 	char *dst;
 
-	if (!url || !url->ptr) return -1;
+	force_assert(NULL != url);
+	if (buffer_string_is_empty(url)) return;
+
+	force_assert('\0' == url->ptr[url->used-1]);
 
-	src = (const char*) url->ptr;
-	dst = (char*) url->ptr;
+	src = (char*) url->ptr;
 
-	while ((*src) != '\0') {
+	while ('\0' != *src) {
+		if ('%' == *src) break;
+		if (is_query && '+' == *src) *src = ' ';
+		src++;
+	}
+	dst = src;
+
+	while ('\0' != *src) {
 		if (is_query && *src == '+') {
 			*dst = ' ';
 		} else if (*src == '%') {
 			*dst = '%';
 
 			high = hex2int(*(src + 1));
-			if (high != 0xFF) {
+			if (0xFF != high) {
 				low = hex2int(*(src + 2));
-				if (low != 0xFF) {
+				if (0xFF != low) {
 					high = (high << 4) | low;
 
 					/* map control-characters out */
@@ -914,19 +872,19 @@
 
 	*dst = '\0';
 	url->used = (dst - url->ptr) + 1;
-
-	return 0;
 }
 
-int buffer_urldecode_path(buffer *url) {
-	return buffer_urldecode_internal(url, 0);
+void buffer_urldecode_path(buffer *url) {
+	buffer_urldecode_internal(url, 0);
 }
 
-int buffer_urldecode_query(buffer *url) {
-	return buffer_urldecode_internal(url, 1);
+void buffer_urldecode_query(buffer *url) {
+	buffer_urldecode_internal(url, 1);
 }
 
-/* Remove "/../", "//", "/./" parts from path.
+/* Remove "/../", "//", "/./" parts from path,
+ * strips leading spaces,
+ * prepends "/" if not present already
  *
  * /blah/..         gets  /
  * /blah/../foo     gets  /foo
@@ -937,37 +895,45 @@
  *       the operation is performed in-place.
  */
 
-int buffer_path_simplify(buffer *dest, buffer *src)
+void buffer_path_simplify(buffer *dest, buffer *src)
 {
 	int toklen;
 	char c, pre1;
 	char *start, *slash, *walk, *out;
 	unsigned short pre;
 
-	if (src == NULL || src->ptr == NULL || dest == NULL)
-		return -1;
+	force_assert(NULL != dest && NULL != src);
 
-	if (src == dest)
-		buffer_prepare_append(dest, 1);
-	else
-		buffer_prepare_copy(dest, src->used + 1);
+	if (buffer_string_is_empty(src)) {
+		buffer_string_prepare_copy(dest, 0);
+		return;
+	}
 
-	walk  = src->ptr;
-	start = dest->ptr;
-	out   = dest->ptr;
-	slash = dest->ptr;
+	force_assert('\0' == src->ptr[src->used-1]);
 
+	/* might need one character more for the '/' prefix */
+	if (src == dest) {
+		buffer_string_prepare_append(dest, 1);
+	} else {
+		buffer_string_prepare_copy(dest, buffer_string_length(src) + 1);
+	}
 
 #if defined(__WIN32) || defined(__CYGWIN__)
-	/* cygwin is treating \ and / the same, so we have to that too
-	 */
-
-	for (walk = src->ptr; *walk; walk++) {
-		if (*walk == '\\') *walk = '/';
+	/* cygwin is treating \ and / the same, so we have to that too */
+	{
+		char *p;
+		for (p = src->ptr; *p; p++) {
+			if (*p == '\\') *p = '/';
+		}
 	}
-	walk = src->ptr;
 #endif
 
+	walk  = src->ptr;
+	start = dest->ptr;
+	out   = dest->ptr;
+	slash = dest->ptr;
+
+
 	while (*walk == ' ') {
 		walk++;
 	}
@@ -983,34 +949,29 @@
 
 	if (pre1 == '\0') {
 		dest->used = (out - start) + 1;
-		return 0;
+		return;
 	}
 
-	while (1) {
+	for (;;) {
 		if (c == '/' || c == '\0') {
 			toklen = out - slash;
 			if (toklen == 3 && pre == (('.' << 8) | '.')) {
 				out = slash;
 				if (out > start) {
 					out--;
-					while (out > start && *out != '/') {
-						out--;
-					}
+					while (out > start && *out != '/') out--;
 				}
 
-				if (c == '\0')
-					out++;
+				if (c == '\0') out++;
 			} else if (toklen == 1 || pre == (('/' << 8) | '.')) {
 				out = slash;
-				if (c == '\0')
-					out++;
+				if (c == '\0') out++;
 			}
 
 			slash = out;
 		}
 
-		if (c == '\0')
-			break;
+		if (c == '\0') break;
 
 		pre1 = c;
 		pre  = (pre << 8) | pre1;
@@ -1021,10 +982,7 @@
 		walk++;
 	}
 
-	*out = '\0';
-	dest->used = (out - start) + 1;
-
-	return 0;
+	buffer_string_set_length(dest, out - start);
 }
 
 int light_isdigit(int c) {
@@ -1047,31 +1005,99 @@
 	return light_isdigit(c) || light_isalpha(c);
 }
 
-int buffer_to_lower(buffer *b) {
-	char *c;
-
-	if (b->used == 0) return 0;
+void buffer_to_lower(buffer *b) {
+	size_t i;
 
-	for (c = b->ptr; *c; c++) {
-		if (*c >= 'A' && *c <= 'Z') {
-			*c |= 32;
-		}
+	for (i = 0; i < b->used; ++i) {
+		char c = b->ptr[i];
+		if (c >= 'A' && c <= 'Z') b->ptr[i] |= 0x20;
 	}
+}
+
+
+void buffer_to_upper(buffer *b) {
+	size_t i;
 
-	return 0;
+	for (i = 0; i < b->used; ++i) {
+		char c = b->ptr[i];
+		if (c >= 'A' && c <= 'Z') b->ptr[i] &= ~0x20;
+	}
 }
 
+#ifdef HAVE_LIBUNWIND
+# define UNW_LOCAL_ONLY
+# include <libunwind.h>
+
+void print_backtrace(FILE *file) {
+	unw_cursor_t cursor;
+	unw_context_t context;
+	int ret;
+	unsigned int frame = 0;
+
+	if (0 != (ret = unw_getcontext(&context))) goto error;
+	if (0 != (ret = unw_init_local(&cursor, &context))) goto error;
 
-int buffer_to_upper(buffer *b) {
-	char *c;
+	fprintf(file, "Backtrace:\n");
 
-	if (b->used == 0) return 0;
+	while (0 < (ret = unw_step(&cursor))) {
+		unw_word_t proc_ip = 0;
+		unw_proc_info_t procinfo;
+		char procname[256];
+		unw_word_t proc_offset = 0;
 
-	for (c = b->ptr; *c; c++) {
-		if (*c >= 'a' && *c <= 'z') {
-			*c &= ~32;
+		if (0 != (ret = unw_get_reg(&cursor, UNW_REG_IP, &proc_ip))) goto error;
+
+		if (0 == proc_ip) {
+			/* without an IP the other functions are useless; unw_get_proc_name would return UNW_EUNSPEC */
+			++frame;
+			fprintf(file, "%u: (nil)\n", frame);
+			continue;
+		}
+
+		if (0 != (ret = unw_get_proc_info(&cursor, &procinfo))) goto error;
+
+		if (0 != (ret = unw_get_proc_name(&cursor, procname, sizeof(procname), &proc_offset))) {
+			switch (-ret) {
+			case UNW_ENOMEM:
+				memset(procname + sizeof(procname) - 4, '.', 3);
+				procname[sizeof(procname) - 1] = '\0';
+				break;
+			case UNW_ENOINFO:
+				procname[0] = '?';
+				procname[1] = '\0';
+				proc_offset = 0;
+				break;
+			default:
+				snprintf(procname, sizeof(procname), "?? (unw_get_proc_name error %d)", -ret);
+				break;
+			}
 		}
+
+		++frame;
+		fprintf(file, "%u: %s (+0x%x) [%p]\n",
+			frame,
+			procname,
+			(unsigned int) proc_offset,
+			(void*)(uintptr_t)proc_ip);
 	}
 
-	return 0;
+	if (0 != ret) goto error;
+
+	return;
+
+error:
+	fprintf(file, "Error while generating backtrace: unwind error %i\n", (int) -ret);
+}
+#else
+void print_backtrace(FILE *file) {
+	UNUSED(file);
+}
+#endif
+
+void log_failed_assert(const char *filename, unsigned int line, const char *msg) {
+	/* can't use buffer here; could lead to recursive assertions */
+	fprintf(stderr, "%s.%d: %s\n", filename, line, msg);
+	print_backtrace(stderr);
+	fflush(stderr);
+	abort();
 }
diff -u lighttpd-1.4.32/src/buffer.h lighttpd-1.4.36/src/buffer.h
--- lighttpd-1.4.32/src/buffer.h	2010-08-22 06:28:46.000000000 -0500
+++ lighttpd-1.4.36/src/buffer.h	2015-07-26 05:36:36.000000000 -0500
@@ -10,82 +10,119 @@
 #include <stdlib.h>
 #include <sys/types.h>
 #include <stdio.h>
+#include <time.h>
 
+#if defined HAVE_STDINT_H
+# include <stdint.h>
+#elif defined HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+
+/* generic string + binary data container; contains a terminating 0 in both
+ * cases
+ *
+ * used == 0 indicates a special "empty" state (unset config values); ptr
+ * might be NULL too then. otherwise an empty string has used == 1 (and ptr[0]
+ * == 0);
+ *
+ * copy/append functions will ensure used >= 1 (i.e. never leave it in the
+ * special empty state); only buffer_copy_buffer will copy the special empty
+ * state.
+ */
 typedef struct {
 	char *ptr;
 
+	/* "used" includes a terminating 0 */
 	size_t used;
+	/* size of allocated buffer at *ptr */
 	size_t size;
 } buffer;
 
-typedef struct {
-	buffer **ptr;
-
-	size_t used;
-	size_t size;
-} buffer_array;
-
-typedef struct {
-	char *ptr;
-
-	size_t offset; /* input-pointer */
-
-	size_t used;   /* output-pointer */
-	size_t size;
-} read_buffer;
-
-buffer_array* buffer_array_init(void);
-void buffer_array_free(buffer_array *b);
-void buffer_array_reset(buffer_array *b);
-buffer *buffer_array_append_get_buffer(buffer_array *b);
-
+/* create new buffer; either empty or copy given data */
 buffer* buffer_init(void);
-buffer* buffer_init_buffer(buffer *b);
-buffer* buffer_init_string(const char *str);
-void buffer_free(buffer *b);
-void buffer_reset(buffer *b);
-
-int buffer_prepare_copy(buffer *b, size_t size);
-int buffer_prepare_append(buffer *b, size_t size);
-
-int buffer_copy_string(buffer *b, const char *s);
-int buffer_copy_string_len(buffer *b, const char *s, size_t s_len);
-int buffer_copy_string_buffer(buffer *b, const buffer *src);
-int buffer_copy_string_hex(buffer *b, const char *in, size_t in_len);
-
-int buffer_copy_long(buffer *b, long val);
-
-int buffer_copy_memory(buffer *b, const char *s, size_t s_len);
-
-int buffer_append_string(buffer *b, const char *s);
-int buffer_append_string_len(buffer *b, const char *s, size_t s_len);
-int buffer_append_string_buffer(buffer *b, const buffer *src);
-int buffer_append_string_lfill(buffer *b, const char *s, size_t maxlen);
-int buffer_append_string_rfill(buffer *b, const char *s, size_t maxlen);
-
-int buffer_append_long_hex(buffer *b, unsigned long len);
-int buffer_append_long(buffer *b, long val);
-
-#if defined(SIZEOF_LONG) && (SIZEOF_LONG == SIZEOF_OFF_T)
-#define buffer_copy_off_t(x, y)		buffer_copy_long(x, y)
-#define buffer_append_off_t(x, y)	buffer_append_long(x, y)
-#else
-int buffer_copy_off_t(buffer *b, off_t val);
-int buffer_append_off_t(buffer *b, off_t val);
-#endif
+buffer* buffer_init_buffer(const buffer *src); /* src can  be NULL */
+buffer* buffer_init_string(const char *str); /* str can  be NULL */
+
+void buffer_free(buffer *b); /* b can be NULL */
+/* truncates to used == 0; frees large buffers, might keep smaller ones for reuse */
+void buffer_reset(buffer *b); /* b can be NULL */
+
+/* reset b. if NULL != b && NULL != src, move src content to b. reset src. */
+void buffer_move(buffer *b, buffer *src);
+
+/* make sure buffer is large enough to store a string of given size
+ * and a terminating zero.
+ * sets b to an empty string, and may drop old content.
+ * @return b->ptr
+ */
+char* buffer_string_prepare_copy(buffer *b, size_t size);
+
+/* allocate buffer large enough to be able to append a string of given size
+ * if b was empty (used == 0) it will contain an empty string (used == 1)
+ * afterwards
+ * "used" data is preserved; if not empty buffer must contain a
+ * zero terminated string.
+ */
+char* buffer_string_prepare_append(buffer *b, size_t size);
+
+/* use after prepare_(copy,append) when you have written data to the buffer
+ * to increase the buffer length by size. also sets the terminating zero.
+ * requires enough space is present for the terminating zero (prepare with the
+ * same size to be sure).
+ */
+void buffer_commit(buffer *b, size_t size);
+
+/* sets string length:
+ * - always stores a terminating zero to terminate the "new" string
+ * - does not modify the string data apart from terminating zero
+ * - reallocates the buffer iff needed
+ */
+void buffer_string_set_length(buffer *b, size_t len);
+
+void buffer_copy_string(buffer *b, const char *s);
+void buffer_copy_string_len(buffer *b, const char *s, size_t s_len);
+void buffer_copy_buffer(buffer *b, const buffer *src);
+/* convert input to hex and store in buffer */
+void buffer_copy_string_hex(buffer *b, const char *in, size_t in_len);
+
+void buffer_append_string(buffer *b, const char *s);
+void buffer_append_string_len(buffer *b, const char *s, size_t s_len);
+void buffer_append_string_buffer(buffer *b, const buffer *src);
+
+void buffer_append_uint_hex(buffer *b, uintmax_t len);
+void buffer_append_int(buffer *b, intmax_t val);
+void buffer_copy_int(buffer *b, intmax_t val);
+
+void buffer_append_strftime(buffer *b, const char *format, const struct tm *tm);
+
+/* '-', log_10 (2^bits) = bits * log 2 / log 10 < bits * 0.31, terminating 0 */
+#define LI_ITOSTRING_LENGTH (2 + (8 * sizeof(intmax_t) * 31 + 99) / 100)
+
+void li_itostrn(char *buf, size_t buf_len, intmax_t val);
+void li_itostr(char *buf, intmax_t val); /* buf must have at least LI_ITOSTRING_LENGTH bytes */
+void li_utostrn(char *buf, size_t buf_len, uintmax_t val);
+void li_utostr(char *buf, uintmax_t val); /* buf must have at least LI_ITOSTRING_LENGTH bytes */
 
-int buffer_append_memory(buffer *b, const char *s, size_t s_len);
+/* buf must be (at least) 2*s_len + 1 big. uses lower-case hex letters. */
+void li_tohex(char *buf, const char *s, size_t s_len);
 
 char * buffer_search_string_len(buffer *b, const char *needle, size_t len);
 
-int buffer_is_empty(buffer *b);
-int buffer_is_equal(buffer *a, buffer *b);
-int buffer_is_equal_right_len(buffer *a, buffer *b, size_t len);
-int buffer_is_equal_string(buffer *a, const char *s, size_t b_len);
+/* NULL buffer or empty buffer (used == 0);
+ * unset "string" (buffer) config options are initialized to used == 0,
+ * while setting an empty string leads to used == 1
+ */
+int buffer_is_empty(const buffer *b);
+/* NULL buffer, empty buffer (used == 0) or empty string (used == 1) */
+int buffer_string_is_empty(const buffer *b);
+
+int buffer_is_equal(const buffer *a, const buffer *b);
+int buffer_is_equal_right_len(const buffer *a, const buffer *b, size_t len);
+int buffer_is_equal_string(const buffer *a, const char *s, size_t b_len);
+int buffer_is_equal_caseless_string(const buffer *a, const char *s, size_t b_len);
 int buffer_caseless_compare(const char *a, size_t a_len, const char *b, size_t b_len);
 
 typedef enum {
-	ENCODING_UNSET,
 	ENCODING_REL_URI, /* for coding a rel-uri (/with space/and%percent) nicely as part of a href */
 	ENCODING_REL_URI_PART, /* same as ENC_REL_URL plus coding / too as %2F */
 	ENCODING_HTML,         /* & becomes &amp; and so on */
@@ -94,17 +131,23 @@
 	ENCODING_HTTP_HEADER   /* encode \n with \t\n */
 } buffer_encoding_t;
 
-int buffer_append_string_encoded(buffer *b, const char *s, size_t s_len, buffer_encoding_t encoding);
+void buffer_append_string_encoded(buffer *b, const char *s, size_t s_len, buffer_encoding_t encoding);
+
+/* escape non-printable characters; simple escapes for \t, \r, \n; fallback to \xCC */
+void buffer_append_string_c_escaped(buffer *b, const char *s, size_t s_len);
 
-int buffer_urldecode_path(buffer *url);
-int buffer_urldecode_query(buffer *url);
-int buffer_path_simplify(buffer *dest, buffer *src);
+/* to upper case, replace non alpha-numerics with '_'; if is_http_header prefix with "HTTP_" unless s is "content-type" */
+void buffer_copy_string_encoded_cgi_varnames(buffer *b, const char *s, size_t s_len, int is_http_header);
+
+void buffer_urldecode_path(buffer *url);
+void buffer_urldecode_query(buffer *url);
+void buffer_path_simplify(buffer *dest, buffer *src);
+
+void buffer_to_lower(buffer *b);
+void buffer_to_upper(buffer *b);
 
-int buffer_to_lower(buffer *b);
-int buffer_to_upper(buffer *b);
 
 /** deprecated */
-int LI_ltostr(char *buf, long val);
 char hex2int(unsigned char c);
 char int2hex(char i);
 
@@ -113,20 +156,42 @@
 int light_isalpha(int c);
 int light_isalnum(int c);
 
+static inline size_t buffer_string_length(const buffer *b); /* buffer string length without terminating 0 */
+static inline size_t buffer_string_space(const buffer *b); /* maximum length of string that can be stored without reallocating */
+static inline void buffer_append_slash(buffer *b); /* append '/' no non-empty strings not ending in '/' */
+
 #define BUFFER_APPEND_STRING_CONST(x, y) \
 	buffer_append_string_len(x, y, sizeof(y) - 1)
 
 #define BUFFER_COPY_STRING_CONST(x, y) \
 	buffer_copy_string_len(x, y, sizeof(y) - 1)
 
-#define BUFFER_APPEND_SLASH(x) \
-	if (x->used > 1 && x->ptr[x->used - 2] != '/') { BUFFER_APPEND_STRING_CONST(x, "/"); }
+#define CONST_STR_LEN(x) x, (x) ? sizeof(x) - 1 : 0
+#define CONST_BUF_LEN(x) ((x) ? (x)->ptr : NULL), buffer_string_length(x)
 
-#define CONST_STR_LEN(x) x, x ? sizeof(x) - 1 : 0
-#define CONST_BUF_LEN(x) x->ptr, x->used ? x->used - 1 : 0
 
-
-#define SEGFAULT() do { fprintf(stderr, "%s.%d: aborted\n", __FILE__, __LINE__); abort(); } while(0)
 #define UNUSED(x) ( (void)(x) )
 
+void print_backtrace(FILE *file);
+void log_failed_assert(const char *filename, unsigned int line, const char *msg) LI_NORETURN;
+#define force_assert(x) do { if (!(x)) log_failed_assert(__FILE__, __LINE__, "assertion failed: " #x); } while(0)
+#define SEGFAULT() log_failed_assert(__FILE__, __LINE__, "aborted");
+
+/* inline implementations */
+
+static inline size_t buffer_string_length(const buffer *b) {
+	return NULL != b && 0 != b->used ? b->used - 1 : 0;
+}
+
+static inline size_t buffer_string_space(const buffer *b) {
+	if (NULL == b || b->size == 0) return 0;
+	if (0 == b->used) return b->size - 1;
+	return b->size - b->used;
+}
+
+static inline void buffer_append_slash(buffer *b) {
+	size_t len = buffer_string_length(b);
+	if (len > 0 && '/' != b->ptr[len-1]) BUFFER_APPEND_STRING_CONST(b, "/");
+}
+
 #endif
diff -u lighttpd-1.4.32/src/chunk.c lighttpd-1.4.36/src/chunk.c
--- lighttpd-1.4.32/src/chunk.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/chunk.c	2015-07-26 05:36:36.000000000 -0500
@@ -5,6 +5,8 @@
  */
 
 #include "chunk.h"
+#include "base.h"
+#include "log.h"
 
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -36,30 +38,28 @@
 
 	c = calloc(1, sizeof(*c));
 
+	c->type = MEM_CHUNK;
 	c->mem = buffer_init();
 	c->file.name = buffer_init();
+	c->file.start = c->file.length = c->file.mmap.offset = 0;
 	c->file.fd = -1;
 	c->file.mmap.start = MAP_FAILED;
+	c->file.mmap.length = 0;
+	c->file.is_temp = 0;
+	c->offset = 0;
 	c->next = NULL;
 
 	return c;
 }
 
-static void chunk_free(chunk *c) {
-	if (!c) return;
-
-	buffer_free(c->mem);
-	buffer_free(c->file.name);
-
-	free(c);
-}
-
 static void chunk_reset(chunk *c) {
-	if (!c) return;
+	if (NULL == c) return;
+
+	c->type = MEM_CHUNK;
 
 	buffer_reset(c->mem);
 
-	if (c->file.is_temp && !buffer_is_empty(c->file.name)) {
+	if (c->file.is_temp && !buffer_string_is_empty(c->file.name)) {
 		unlink(c->file.name->ptr);
 	}
 
@@ -73,13 +73,28 @@
 		munmap(c->file.mmap.start, c->file.mmap.length);
 		c->file.mmap.start = MAP_FAILED;
 	}
+	c->file.start = c->file.length = c->file.mmap.offset = 0;
+	c->file.mmap.length = 0;
+	c->file.is_temp = 0;
+	c->offset = 0;
+	c->next = NULL;
 }
 
+static void chunk_free(chunk *c) {
+	if (NULL == c) return;
+
+	chunk_reset(c);
+
+	buffer_free(c->mem);
+	buffer_free(c->file.name);
+
+	free(c);
+}
 
 void chunkqueue_free(chunkqueue *cq) {
 	chunk *c, *pc;
 
-	if (!cq) return;
+	if (NULL == cq) return;
 
 	for (c = cq->first; c; ) {
 		pc = c;
@@ -96,11 +111,27 @@
 	free(cq);
 }
 
+static void chunkqueue_push_unused_chunk(chunkqueue *cq, chunk *c) {
+	force_assert(NULL != cq && NULL != c);
+
+	/* keep at max 4 chunks in the 'unused'-cache */
+	if (cq->unused_chunks > 4) {
+		chunk_free(c);
+	} else {
+		chunk_reset(c);
+		c->next = cq->unused;
+		cq->unused = c;
+		cq->unused_chunks++;
+	}
+}
+
 static chunk *chunkqueue_get_unused_chunk(chunkqueue *cq) {
 	chunk *c;
 
+	force_assert(NULL != cq);
+
 	/* check if we have a unused chunk */
-	if (!cq->unused) {
+	if (0 == cq->unused) {
 		c = chunk_init();
 	} else {
 		/* take the first element from the list (a stack) */
@@ -113,176 +144,240 @@
 	return c;
 }
 
-static int chunkqueue_prepend_chunk(chunkqueue *cq, chunk *c) {
+static void chunkqueue_prepend_chunk(chunkqueue *cq, chunk *c) {
 	c->next = cq->first;
 	cq->first = c;
 
-	if (cq->last == NULL) {
+	if (NULL == cq->last) {
 		cq->last = c;
 	}
-
-	return 0;
 }
 
-static int chunkqueue_append_chunk(chunkqueue *cq, chunk *c) {
+static void chunkqueue_append_chunk(chunkqueue *cq, chunk *c) {
 	if (cq->last) {
 		cq->last->next = c;
 	}
 	cq->last = c;
 
-	if (cq->first == NULL) {
+	if (NULL == cq->first) {
 		cq->first = c;
 	}
-
-	return 0;
 }
 
 void chunkqueue_reset(chunkqueue *cq) {
-	chunk *c;
-	/* move everything to the unused queue */
+	chunk *cur = cq->first;
 
-	/* mark all read written */
-	for (c = cq->first; c; c = c->next) {
-		switch(c->type) {
-		case MEM_CHUNK:
-			c->offset = c->mem->used - 1;
-			break;
-		case FILE_CHUNK:
-			c->offset = c->file.length;
-			break;
-		default:
-			break;
-		}
+	cq->first = cq->last = NULL;
+
+	while (NULL != cur) {
+		chunk *next = cur->next;
+		chunkqueue_push_unused_chunk(cq, cur);
+		cur = next;
 	}
 
-	chunkqueue_remove_finished_chunks(cq);
 	cq->bytes_in = 0;
 	cq->bytes_out = 0;
 }
 
-int chunkqueue_append_file(chunkqueue *cq, buffer *fn, off_t offset, off_t len) {
+void chunkqueue_append_file(chunkqueue *cq, buffer *fn, off_t offset, off_t len) {
 	chunk *c;
 
-	if (len == 0) return 0;
+	if (0 == len) return;
 
 	c = chunkqueue_get_unused_chunk(cq);
 
 	c->type = FILE_CHUNK;
 
-	buffer_copy_string_buffer(c->file.name, fn);
+	buffer_copy_buffer(c->file.name, fn);
 	c->file.start = offset;
 	c->file.length = len;
 	c->offset = 0;
 
 	chunkqueue_append_chunk(cq, c);
-
-	return 0;
 }
 
-int chunkqueue_append_buffer(chunkqueue *cq, buffer *mem) {
+void chunkqueue_append_buffer(chunkqueue *cq, buffer *mem) {
 	chunk *c;
 
-	if (mem->used == 0) return 0;
+	if (buffer_string_is_empty(mem)) return;
 
 	c = chunkqueue_get_unused_chunk(cq);
 	c->type = MEM_CHUNK;
-	c->offset = 0;
-	buffer_copy_string_buffer(c->mem, mem);
+	force_assert(NULL != c->mem);
+	buffer_move(c->mem, mem);
 
 	chunkqueue_append_chunk(cq, c);
-
-	return 0;
 }
 
-int chunkqueue_append_buffer_weak(chunkqueue *cq, buffer *mem) {
+void chunkqueue_prepend_buffer(chunkqueue *cq, buffer *mem) {
 	chunk *c;
 
+	if (buffer_string_is_empty(mem)) return;
+
 	c = chunkqueue_get_unused_chunk(cq);
 	c->type = MEM_CHUNK;
-	c->offset = 0;
-	if (c->mem) buffer_free(c->mem);
-	c->mem = mem;
-
-	chunkqueue_append_chunk(cq, c);
+	force_assert(NULL != c->mem);
+	buffer_move(c->mem, mem);
 
-	return 0;
+	chunkqueue_prepend_chunk(cq, c);
 }
 
-int chunkqueue_prepend_buffer(chunkqueue *cq, buffer *mem) {
+
+void chunkqueue_append_mem(chunkqueue *cq, const char * mem, size_t len) {
 	chunk *c;
 
-	if (mem->used == 0) return 0;
+	if (0 == len) return;
 
 	c = chunkqueue_get_unused_chunk(cq);
 	c->type = MEM_CHUNK;
-	c->offset = 0;
-	buffer_copy_string_buffer(c->mem, mem);
+	buffer_copy_string_len(c->mem, mem, len);
 
-	chunkqueue_prepend_chunk(cq, c);
-
-	return 0;
+	chunkqueue_append_chunk(cq, c);
 }
 
-
-int chunkqueue_append_mem(chunkqueue *cq, const char * mem, size_t len) {
+void chunkqueue_get_memory(chunkqueue *cq, char **mem, size_t *len, size_t min_size, size_t alloc_size) {
+	static const size_t REALLOC_MAX_SIZE = 256;
 	chunk *c;
+	buffer *b;
+	char *dummy_mem;
+	size_t dummy_len;
+
+	force_assert(NULL != cq);
+	if (NULL == mem) mem = &dummy_mem;
+	if (NULL == len) len = &dummy_len;
+
+	/* default values: */
+	if (0 == min_size) min_size = 1024;
+	if (0 == alloc_size) alloc_size = 4096;
+	if (alloc_size < min_size) alloc_size = min_size;
+
+	if (NULL != cq->last && MEM_CHUNK == cq->last->type) {
+		size_t have;
+
+		b = cq->last->mem;
+		have = buffer_string_space(b);
+
+		/* unused buffer: allocate space */
+		if (buffer_string_is_empty(b)) {
+			buffer_string_prepare_copy(b, alloc_size);
+			have = buffer_string_space(b);
+		}
+		/* if buffer is really small just make it bigger */
+		else if (have < min_size && b->size <= REALLOC_MAX_SIZE) {
+			size_t cur_len = buffer_string_length(b);
+			size_t new_size = cur_len + min_size, append;
+			if (new_size < alloc_size) new_size = alloc_size;
+
+			append = new_size - cur_len;
+			if (append >= min_size) {
+				buffer_string_prepare_append(b, append);
+				have = buffer_string_space(b);
+			}
+		}
 
-	if (len == 0) return 0;
+		/* return pointer into existing buffer if large enough */
+		if (have >= min_size) {
+			*mem = b->ptr + buffer_string_length(b);
+			*len = have;
+			return;
+		}
+	}
 
+	/* allocate new chunk */
 	c = chunkqueue_get_unused_chunk(cq);
 	c->type = MEM_CHUNK;
-	c->offset = 0;
-	buffer_copy_string_len(c->mem, mem, len - 1);
-
 	chunkqueue_append_chunk(cq, c);
 
-	return 0;
-}
+	b = c->mem;
+	buffer_string_prepare_append(b, alloc_size);
 
-buffer * chunkqueue_get_prepend_buffer(chunkqueue *cq) {
-	chunk *c;
+	*mem = b->ptr + buffer_string_length(b);
+	*len = buffer_string_space(b);
+}
 
-	c = chunkqueue_get_unused_chunk(cq);
+void chunkqueue_use_memory(chunkqueue *cq, size_t len) {
+	buffer *b;
 
-	c->type = MEM_CHUNK;
-	c->offset = 0;
-	buffer_reset(c->mem);
+	force_assert(NULL != cq);
+	force_assert(NULL != cq->last && MEM_CHUNK == cq->last->type);
+	b = cq->last->mem;
 
-	chunkqueue_prepend_chunk(cq, c);
+	if (len > 0) {
+		buffer_commit(b, len);
+	} else if (buffer_string_is_empty(b)) {
+		/* unused buffer: can't remove chunk easily from
+		 * end of list, so just reset the buffer
+		 */
+		buffer_reset(b);
+	}
+}
 
-	return c->mem;
+void chunkqueue_set_tempdirs(chunkqueue *cq, array *tempdirs) {
+	force_assert(NULL != cq);
+	cq->tempdirs = tempdirs;
 }
 
-buffer *chunkqueue_get_append_buffer(chunkqueue *cq) {
-	chunk *c;
+void chunkqueue_steal(chunkqueue *dest, chunkqueue *src, off_t len) {
+	while (len > 0) {
+		chunk *c = src->first;
+		off_t clen = 0, use;
 
-	c = chunkqueue_get_unused_chunk(cq);
+		if (NULL == c) break;
 
-	c->type = MEM_CHUNK;
-	c->offset = 0;
-	buffer_reset(c->mem);
+		switch (c->type) {
+		case MEM_CHUNK:
+			clen = buffer_string_length(c->mem);
+			break;
+		case FILE_CHUNK:
+			clen = c->file.length;
+			break;
+		}
+		force_assert(clen >= c->offset);
+		clen -= c->offset;
+		use = len >= clen ? clen : len;
+
+		src->bytes_out += use;
+		dest->bytes_in += use;
+		len -= use;
+
+		if (0 == clen) {
+			/* drop empty chunk */
+			src->first = c->next;
+			if (c == src->last) src->last = NULL;
+			chunkqueue_push_unused_chunk(src, c);
+			continue;
+		}
 
-	chunkqueue_append_chunk(cq, c);
+		if (use == clen) {
+			/* move complete chunk */
+			src->first = c->next;
+			if (c == src->last) src->last = NULL;
 
-	return c->mem;
-}
+			chunkqueue_append_chunk(dest, c);
+			continue;
+		}
 
-int chunkqueue_set_tempdirs(chunkqueue *cq, array *tempdirs) {
-	if (!cq) return -1;
+		/* partial chunk with length "use" */
 
-	cq->tempdirs = tempdirs;
+		switch (c->type) {
+		case MEM_CHUNK:
+			chunkqueue_append_mem(dest, c->mem->ptr + c->offset, use);
+			break;
+		case FILE_CHUNK:
+			/* tempfile flag is in "last" chunk after the split */
+			chunkqueue_append_file(dest, c->file.name, c->file.start + c->offset, use);
+			break;
+		}
 
-	return 0;
+		c->offset += use;
+		force_assert(0 == len);
+	}
 }
 
-chunk *chunkqueue_get_append_tempfile(chunkqueue *cq) {
+static chunk *chunkqueue_get_append_tempfile(chunkqueue *cq) {
 	chunk *c;
 	buffer *template = buffer_init_string("/var/tmp/lighttpd-upload-XXXXXX");
-
-	c = chunkqueue_get_unused_chunk(cq);
-
-	c->type = FILE_CHUNK;
-	c->offset = 0;
+	int fd;
 
 	if (cq->tempdirs && cq->tempdirs->used) {
 		size_t i;
@@ -292,24 +387,26 @@
 		for (i = 0; i < cq->tempdirs->used; i++) {
 			data_string *ds = (data_string *)cq->tempdirs->data[i];
 
-			buffer_copy_string_buffer(template, ds->value);
-			BUFFER_APPEND_SLASH(template);
+			buffer_copy_buffer(template, ds->value);
+			buffer_append_slash(template);
 			buffer_append_string_len(template, CONST_STR_LEN("lighttpd-upload-XXXXXX"));
 
-			if (-1 != (c->file.fd = mkstemp(template->ptr))) {
-				/* only trigger the unlink if we created the temp-file successfully */
-				c->file.is_temp = 1;
-				break;
-			}
+			if (-1 != (fd = mkstemp(template->ptr))) break;
 		}
 	} else {
-		if (-1 != (c->file.fd = mkstemp(template->ptr))) {
-			/* only trigger the unlink if we created the temp-file successfully */
-			c->file.is_temp = 1;
-		}
+		fd = mkstemp(template->ptr);
+	}
+
+	if (-1 == fd) {
+		buffer_free(template);
+		return NULL;
 	}
 
-	buffer_copy_string_buffer(c->file.name, template);
+	c = chunkqueue_get_unused_chunk(cq);
+	c->type = FILE_CHUNK;
+	c->file.fd = fd;
+	c->file.is_temp = 1;
+	buffer_copy_buffer(c->file.name, template);
 	c->file.length = 0;
 
 	chunkqueue_append_chunk(cq, c);
@@ -319,82 +416,189 @@
 	return c;
 }
 
+static int chunkqueue_append_to_tempfile(server *srv, chunkqueue *dest, const char *mem, size_t len) {
+	chunk *dst_c = NULL;
+	ssize_t written;
+	/* copy everything to max 1Mb sized tempfiles */
+
+	/*
+	 * if the last chunk is
+	 * - smaller than 1Mb (size < 1Mb)
+	 * - not read yet (offset == 0)
+	 * -> append to it
+	 * otherwise
+	 * -> create a new chunk
+	 *
+	 * */
+
+	if (NULL != dest->last
+		&& FILE_CHUNK != dest->last->type
+		&& dest->last->file.is_temp
+		&& -1 != dest->last->file.fd
+		&& 0 == dest->last->offset) {
+		/* ok, take the last chunk for our job */
+		dst_c = dest->last;
+
+		if (dest->last->file.length >= 1 * 1024 * 1024) {
+			/* the chunk is too large now, close it */
+			if (-1 != dst_c->file.fd) {
+				close(dst_c->file.fd);
+				dst_c->file.fd = -1;
+			}
+			dst_c = chunkqueue_get_append_tempfile(dest);
+		}
+	} else {
+		dst_c = chunkqueue_get_append_tempfile(dest);
+	}
 
-off_t chunkqueue_length(chunkqueue *cq) {
-	off_t len = 0;
-	chunk *c;
+	if (NULL == dst_c) {
+		/* we don't have file to write to,
+		 * EACCES might be one reason.
+		 *
+		 * Instead of sending 500 we send 413 and say the request is too large
+		 */
+
+		log_error_write(srv, __FILE__, __LINE__, "ss",
+			"denying upload as opening temp-file for upload failed:",
+			strerror(errno));
+
+		return -1;
+	}
+
+	if (0 > (written = write(dst_c->file.fd, mem, len)) || (size_t) written != len) {
+		/* write failed for some reason ... disk full ? */
+		log_error_write(srv, __FILE__, __LINE__, "sbs",
+				"denying upload as writing to file failed:",
+				dst_c->file.name, strerror(errno));
+
+		close(dst_c->file.fd);
+		dst_c->file.fd = -1;
+
+		return -1;
+	}
+
+	dst_c->file.length += len;
+
+	return 0;
+}
+
+int chunkqueue_steal_with_tempfiles(server *srv, chunkqueue *dest, chunkqueue *src, off_t len) {
+	while (len > 0) {
+		chunk *c = src->first;
+		off_t clen = 0, use;
+
+		if (NULL == c) break;
 
-	for (c = cq->first; c; c = c->next) {
 		switch (c->type) {
 		case MEM_CHUNK:
-			len += c->mem->used ? c->mem->used - 1 : 0;
+			clen = buffer_string_length(c->mem);
 			break;
 		case FILE_CHUNK:
-			len += c->file.length;
-			break;
-		default:
+			clen = c->file.length;
 			break;
 		}
+		force_assert(clen >= c->offset);
+		clen -= c->offset;
+		use = len >= clen ? clen : len;
+
+		src->bytes_out += use;
+		dest->bytes_in += use;
+		len -= use;
+
+		if (0 == clen) {
+			/* drop empty chunk */
+			src->first = c->next;
+			if (c == src->last) src->last = NULL;
+			chunkqueue_push_unused_chunk(src, c);
+			continue;
+		}
+
+		if (FILE_CHUNK == c->type) {
+			if (use == clen) {
+				/* move complete chunk */
+				src->first = c->next;
+				if (c == src->last) src->last = NULL;
+
+				chunkqueue_append_chunk(dest, c);
+			} else {
+				/* partial chunk with length "use" */
+				/* tempfile flag is in "last" chunk after the split */
+				chunkqueue_append_file(dest, c->file.name, c->file.start + c->offset, use);
+
+				c->offset += use;
+				force_assert(0 == len);
+			}
+			continue;
+		}
+
+		/* store "use" bytes from memory chunk in tempfile */
+		if (0 != chunkqueue_append_to_tempfile(srv, dest, c->mem->ptr + c->offset, use)) {
+			/* undo counters */
+			src->bytes_out -= use;
+			dest->bytes_in -= use;
+			return -1;
+		}
+
+
+		c->offset += use;
+		if (use == clen) {
+			/* finished chunk */
+			src->first = c->next;
+			if (c == src->last) src->last = NULL;
+			chunkqueue_push_unused_chunk(src, c);
+		}
 	}
 
-	return len;
+	return 0;
 }
 
-off_t chunkqueue_written(chunkqueue *cq) {
+off_t chunkqueue_length(chunkqueue *cq) {
 	off_t len = 0;
 	chunk *c;
 
 	for (c = cq->first; c; c = c->next) {
+		off_t c_len = 0;
+
 		switch (c->type) {
 		case MEM_CHUNK:
-		case FILE_CHUNK:
-			len += c->offset;
+			c_len = buffer_string_length(c->mem);
 			break;
-		default:
+		case FILE_CHUNK:
+			c_len = c->file.length;
 			break;
 		}
+		force_assert(c_len >= c->offset);
+		len += c_len - c->offset;
 	}
 
 	return len;
 }
 
 int chunkqueue_is_empty(chunkqueue *cq) {
-	return cq->first ? 0 : 1;
+	return NULL == cq->first;
 }
 
-int chunkqueue_remove_finished_chunks(chunkqueue *cq) {
+void chunkqueue_remove_finished_chunks(chunkqueue *cq) {
 	chunk *c;
 
 	for (c = cq->first; c; c = cq->first) {
-		int is_finished = 0;
+		off_t c_len = 0;
 
 		switch (c->type) {
 		case MEM_CHUNK:
-			if (c->mem->used == 0 || (c->offset == (off_t)c->mem->used - 1)) is_finished = 1;
+			c_len = buffer_string_length(c->mem);
 			break;
 		case FILE_CHUNK:
-			if (c->offset == c->file.length) is_finished = 1;
-			break;
-		default:
+			c_len = c->file.length;
 			break;
 		}
+		force_assert(c_len >= c->offset);
 
-		if (!is_finished) break;
-
-		chunk_reset(c);
+		if (c_len > c->offset) break; /* not finished yet */
 
 		cq->first = c->next;
 		if (c == cq->last) cq->last = NULL;
 
-		/* keep at max 4 chunks in the 'unused'-cache */
-		if (cq->unused_chunks > 4) {
-			chunk_free(c);
-		} else {
-			c->next = cq->unused;
-			cq->unused = c;
-			cq->unused_chunks++;
-		}
+		chunkqueue_push_unused_chunk(cq, c);
 	}
-
-	return 0;
 }
diff -u lighttpd-1.4.32/src/chunk.h lighttpd-1.4.36/src/chunk.h
--- lighttpd-1.4.32/src/chunk.h	2010-02-01 17:28:20.000000000 -0600
+++ lighttpd-1.4.36/src/chunk.h	2015-07-26 05:36:36.000000000 -0500
@@ -6,7 +6,7 @@
 #include "sys-mmap.h"
 
 typedef struct chunk {
-	enum { UNUSED_CHUNK, MEM_CHUNK, FILE_CHUNK } type;
+	enum { MEM_CHUNK, FILE_CHUNK } type;
 
 	buffer *mem; /* either the storage of the mem-chunk or the read-ahead buffer */
 
@@ -48,24 +48,37 @@
 } chunkqueue;
 
 chunkqueue *chunkqueue_init(void);
-int chunkqueue_set_tempdirs(chunkqueue *c, array *tempdirs);
-int chunkqueue_append_file(chunkqueue *c, buffer *fn, off_t offset, off_t len);
-int chunkqueue_append_mem(chunkqueue *c, const char *mem, size_t len);
-int chunkqueue_append_buffer(chunkqueue *c, buffer *mem);
-int chunkqueue_append_buffer_weak(chunkqueue *c, buffer *mem);
-int chunkqueue_prepend_buffer(chunkqueue *c, buffer *mem);
-
-buffer * chunkqueue_get_append_buffer(chunkqueue *c);
-buffer * chunkqueue_get_prepend_buffer(chunkqueue *c);
-chunk * chunkqueue_get_append_tempfile(chunkqueue *cq);
-
-int chunkqueue_remove_finished_chunks(chunkqueue *cq);
-
-off_t chunkqueue_length(chunkqueue *c);
-off_t chunkqueue_written(chunkqueue *c);
-void chunkqueue_free(chunkqueue *c);
-void chunkqueue_reset(chunkqueue *c);
+void chunkqueue_set_tempdirs(chunkqueue *cq, array *tempdirs);
+void chunkqueue_append_file(chunkqueue *cq, buffer *fn, off_t offset, off_t len); /* copies "fn" */
+void chunkqueue_append_mem(chunkqueue *cq, const char *mem, size_t len); /* copies memory */
+void chunkqueue_append_buffer(chunkqueue *cq, buffer *mem); /* may reset "mem" */
+void chunkqueue_prepend_buffer(chunkqueue *cq, buffer *mem); /* may reset "mem" */
+
+/* functions to handle buffers to read into: */
+/* return a pointer to a buffer in *mem with size *len;
+ *  it should be at least min_size big, and use alloc_size if
+ *  new memory is allocated.
+ * modifying the chunkqueue invalidates the memory area.
+ * should always be followed by chunkqueue_get_memory(),
+ *  even if nothing was read.
+ * pass 0 for min_size/alloc_size for default values
+ */
+void chunkqueue_get_memory(chunkqueue *cq, char **mem, size_t *len, size_t min_size, size_t alloc_size);
+/* append first len bytes of the memory queried with
+ * chunkqueue_get_memory to the chunkqueue
+ */
+void chunkqueue_use_memory(chunkqueue *cq, size_t len);
+
+void chunkqueue_remove_finished_chunks(chunkqueue *cq);
+
+void chunkqueue_steal(chunkqueue *dest, chunkqueue *src, off_t len);
+struct server;
+int chunkqueue_steal_with_tempfiles(struct server *srv, chunkqueue *dest, chunkqueue *src, off_t len);
+
+off_t chunkqueue_length(chunkqueue *cq);
+void chunkqueue_free(chunkqueue *cq);
+void chunkqueue_reset(chunkqueue *cq);
 
-int chunkqueue_is_empty(chunkqueue *c);
+int chunkqueue_is_empty(chunkqueue *cq);
 
 #endif
Only in lighttpd-1.4.36/src: CMakeLists.txt
diff -u lighttpd-1.4.32/src/configfile.c lighttpd-1.4.36/src/configfile.c
--- lighttpd-1.4.32/src/configfile.c	2012-11-07 08:50:29.000000000 -0600
+++ lighttpd-1.4.36/src/configfile.c	2015-07-26 05:36:36.000000000 -0500
@@ -107,6 +107,7 @@
 		{ "ssl.ec-curve",                NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_SERVER },      /* 64 */
 		{ "ssl.disable-client-renegotiation", NULL, T_CONFIG_BOOLEAN, T_CONFIG_SCOPE_SERVER },/* 65 */
 		{ "ssl.honor-cipher-order",      NULL, T_CONFIG_BOOLEAN, T_CONFIG_SCOPE_SERVER },     /* 66 */
+		{ "ssl.empty-fragments",         NULL, T_CONFIG_BOOLEAN, T_CONFIG_SCOPE_SERVER },     /* 67 */
 
 		{ "server.host",                 "use server.bind instead", T_CONFIG_DEPRECATED, T_CONFIG_SCOPE_UNSET },
 		{ "server.docroot",              "use server.document-root instead", T_CONFIG_DEPRECATED, T_CONFIG_SCOPE_UNSET },
@@ -154,13 +155,13 @@
 
 	srv->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
 
-	assert(srv->config_storage);
+	force_assert(srv->config_storage);
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		specific_config *s;
 
 		s = calloc(1, sizeof(specific_config));
-		assert(s);
+		force_assert(s);
 		s->document_root = buffer_init();
 		s->mimetypes     = array_init();
 		s->server_name   = buffer_init();
@@ -177,10 +178,11 @@
 		s->max_read_idle = 60;
 		s->max_write_idle = 360;
 		s->use_xattr     = 0;
-		s->is_ssl        = 0;
+		s->ssl_enabled   = 0;
 		s->ssl_honor_cipher_order = 1;
+		s->ssl_empty_fragments = 0;
 		s->ssl_use_sslv2 = 0;
-		s->ssl_use_sslv3 = 1;
+		s->ssl_use_sslv3 = 0;
 		s->use_ipv6      = 0;
 		s->set_v6only    = 1;
 		s->defer_accept  = 0;
@@ -231,7 +233,7 @@
 		cv[27].destination = &(s->use_xattr);
 		cv[28].destination = s->mimetypes;
 		cv[29].destination = s->ssl_pemfile;
-		cv[30].destination = &(s->is_ssl);
+		cv[30].destination = &(s->ssl_enabled);
 
 		cv[31].destination = &(s->log_file_not_found);
 		cv[32].destination = &(s->log_request_handling);
@@ -250,6 +252,7 @@
 		cv[63].destination = s->ssl_dh_file;
 		cv[64].destination = s->ssl_ec_curve;
 		cv[66].destination = &(s->ssl_honor_cipher_order);
+		cv[67].destination = &(s->ssl_empty_fragments);
 
 		cv[49].destination = &(s->etag_use_inode);
 		cv[50].destination = &(s->etag_use_mtime);
@@ -270,7 +273,7 @@
 		}
 	}
 
-	if (buffer_is_empty(stat_cache_string)) {
+	if (buffer_string_is_empty(stat_cache_string)) {
 		srv->srvconf.stat_cache_engine = STAT_CACHE_ENGINE_SIMPLE;
 	} else if (buffer_is_equal_string(stat_cache_string, CONST_STR_LEN("simple"))) {
 		srv->srvconf.stat_cache_engine = STAT_CACHE_ENGINE_SIMPLE;
@@ -320,7 +323,7 @@
 	PATCH(global_bytes_per_second_cnt);
 
 	con->conf.global_bytes_per_second_cnt_ptr = &s->global_bytes_per_second_cnt;
-	buffer_copy_string_buffer(con->server_name, s->server_name);
+	buffer_copy_buffer(con->server_name, s->server_name);
 
 	PATCH(log_request_header);
 	PATCH(log_response_header);
@@ -332,17 +335,22 @@
 
 	PATCH(range_requests);
 	PATCH(force_lowercase_filenames);
-	PATCH(is_ssl);
+	PATCH(ssl_enabled);
 
 	PATCH(ssl_pemfile);
 #ifdef USE_OPENSSL
-	PATCH(ssl_ctx);
+	PATCH(ssl_pemfile_x509);
+	PATCH(ssl_pemfile_pkey);
 #endif
 	PATCH(ssl_ca_file);
+#ifdef USE_OPENSSL
+	PATCH(ssl_ca_file_cert_names);
+#endif
 	PATCH(ssl_cipher_list);
 	PATCH(ssl_dh_file);
 	PATCH(ssl_ec_curve);
 	PATCH(ssl_honor_cipher_order);
+	PATCH(ssl_empty_fragments);
 	PATCH(ssl_use_sslv2);
 	PATCH(ssl_use_sslv3);
 	PATCH(etag_use_inode);
@@ -405,12 +413,18 @@
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.pemfile"))) {
 				PATCH(ssl_pemfile);
 #ifdef USE_OPENSSL
-				PATCH(ssl_ctx);
+				PATCH(ssl_pemfile_x509);
+				PATCH(ssl_pemfile_pkey);
 #endif
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.ca-file"))) {
 				PATCH(ssl_ca_file);
+#ifdef USE_OPENSSL
+				PATCH(ssl_ca_file_cert_names);
+#endif
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.honor-cipher-order"))) {
 				PATCH(ssl_honor_cipher_order);
+			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.empty-fragments"))) {
+				PATCH(ssl_empty_fragments);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.use-sslv2"))) {
 				PATCH(ssl_use_sslv2);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.use-sslv3"))) {
@@ -418,7 +432,7 @@
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.cipher-list"))) {
 				PATCH(ssl_cipher_list);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.engine"))) {
-				PATCH(is_ssl);
+				PATCH(ssl_enabled);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.dh-file"))) {
 				PATCH(ssl_dh_file);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.ec-curve"))) {
@@ -428,7 +442,7 @@
 				PATCH(follow_symlink);
 #endif
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("server.name"))) {
-				buffer_copy_string_buffer(con->server_name, s->server_name);
+				buffer_copy_buffer(con->server_name, s->server_name);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("server.tag"))) {
 				PATCH(server_tag);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("connection.kbytes-per-second"))) {
@@ -498,7 +512,7 @@
 
 #if 0
 static int tokenizer_open(server *srv, tokenizer_t *t, buffer *basedir, const char *fn) {
-	if (buffer_is_empty(basedir) ||
+	if (buffer_string_is_empty(basedir) ||
 			(fn[0] == '/' || fn[0] == '\\') ||
 			(fn[0] == '.' && (fn[1] == '/' || fn[1] == '\\'))) {
 		t->file = buffer_init_string(fn);
@@ -535,7 +549,7 @@
 #endif
 static int config_skip_newline(tokenizer_t *t) {
 	int skipped = 1;
-	assert(t->input[t->offset] == '\r' || t->input[t->offset] == '\n');
+	force_assert(t->input[t->offset] == '\r' || t->input[t->offset] == '\n');
 	if (t->input[t->offset] == '\r' && t->input[t->offset + 1] == '\n') {
 		skipped ++;
 		t->offset ++;
@@ -546,7 +560,7 @@
 
 static int config_skip_comment(tokenizer_t *t) {
 	int i;
-	assert(t->input[t->offset] == '#');
+	force_assert(t->input[t->offset] == '#');
 	for (i = 1; t->input[t->offset + i] &&
 	     (t->input[t->offset + i] != '\n' && t->input[t->offset + i] != '\r');
 	     i++);
@@ -920,7 +934,7 @@
 	lasttoken = buffer_init();
 	token = buffer_init();
 	while((1 == (ret = config_tokenizer(srv, t, &token_id, token))) && context->ok) {
-		buffer_copy_string_buffer(lasttoken, token);
+		buffer_copy_buffer(lasttoken, token);
 		configparser(pParser, token_id, token, context);
 
 		token = buffer_init();
@@ -972,7 +986,7 @@
 	int ret;
 	buffer *filename;
 
-	if (buffer_is_empty(context->basedir) ||
+	if (buffer_string_is_empty(context->basedir) ||
 			(fn[0] == '/' || fn[0] == '\\') ||
 			(fn[0] == '.' && (fn[1] == '/' || fn[1] == '\\'))) {
 		filename = buffer_init_string(fn);
@@ -982,14 +996,9 @@
 	}
 
 	if (0 != stream_open(&s, filename)) {
-		if (s.size == 0) {
-			/* the file was empty, nothing to parse */
-			ret = 0;
-		} else {
-			log_error_write(srv, __FILE__, __LINE__, "sbss",
-					"opening configfile ", filename, "failed:", strerror(errno));
-			ret = -1;
-		} 
+		log_error_write(srv, __FILE__, __LINE__, "sbss",
+				"opening configfile ", filename, "failed:", strerror(errno));
+		ret = -1;
 	} else {
 		tokenizer_init(&t, filename, s.start, s.size);
 		ret = config_parse(srv, context, &t);
@@ -1012,7 +1021,10 @@
 	s = malloc(len);
 	if (!s) return NULL;
 	while (NULL == getcwd(s, len)) {
-		if (errno != ERANGE || SSIZE_MAX - len < len) return NULL;
+		if (errno != ERANGE || SSIZE_MAX - len < len) {
+			free(s);
+			return NULL;
+		}
 		len *= 2;
 		s1 = realloc(s, len);
 		if (!s1) {
@@ -1040,7 +1052,7 @@
 	source = buffer_init_string(cmd);
 	out = buffer_init();
 
-	if (!buffer_is_empty(context->basedir)) {
+	if (!buffer_string_is_empty(context->basedir)) {
 		chdir(context->basedir->ptr);
 	}
 
@@ -1049,7 +1061,7 @@
 				"opening", source, "failed:", strerror(errno));
 		ret = -1;
 	} else {
-		tokenizer_init(&t, source, out->ptr, out->used);
+		tokenizer_init(&t, source, CONST_BUF_LEN(out));
 		ret = config_parse(srv, context, &t);
 	}
 
@@ -1098,7 +1110,7 @@
 	dc = data_config_init();
 	buffer_copy_string_len(dc->key, CONST_STR_LEN("global"));
 
-	assert(context.all_configs->used == 0);
+	force_assert(context.all_configs->used == 0);
 	dc->context_ndx = context.all_configs->used;
 	array_insert_unique(context.all_configs, (data_unset *)dc);
 	context.current = dc;
@@ -1111,17 +1123,19 @@
 	array_insert_unique(srv->config, (data_unset *)dpid);
 
 	dcwd = data_string_init();
-	buffer_prepare_copy(dcwd->value, 1024);
+	buffer_string_prepare_copy(dcwd->value, 1023);
 	if (NULL != getcwd(dcwd->value->ptr, dcwd->value->size - 1)) {
-		dcwd->value->used = strlen(dcwd->value->ptr) + 1;
+		buffer_commit(dcwd->value, strlen(dcwd->value->ptr));
 		buffer_copy_string_len(dcwd->key, CONST_STR_LEN("var.CWD"));
 		array_insert_unique(srv->config, (data_unset *)dcwd);
+	} else {
+		dcwd->free((data_unset*) dcwd);
 	}
 
 	ret = config_parse_file(srv, &context, fn);
 
 	/* remains nothing if parser is ok */
-	assert(!(0 == ret && context.ok && 0 != context.configs_stack->used));
+	force_assert(!(0 == ret && context.ok && 0 != context.configs_stack->used));
 	context_free(&context);
 
 	if (0 != ret) {
@@ -1153,7 +1167,8 @@
 		}
 
 		prepends = (data_array *)configparser_merge_data((data_unset *)prepends, (data_unset *)modules);
-		buffer_copy_string_buffer(prepends->key, modules->key);
+		force_assert(NULL != prepends);
+		buffer_copy_buffer(prepends->key, modules->key);
 		array_replace(srv->config, (data_unset *)prepends);
 		modules->free((data_unset *)modules);
 		modules = prepends;
@@ -1235,36 +1250,27 @@
 		{ FDEVENT_HANDLER_UNSET,          NULL }
 	};
 
-
-	if (buffer_is_empty(s->document_root)) {
-		log_error_write(srv, __FILE__, __LINE__, "s",
-				"a default document-root has to be set");
-
-		return -1;
-	}
-
-	if (buffer_is_empty(srv->srvconf.changeroot)) {
-		if (-1 == stat(s->document_root->ptr, &st1)) {
+	if (!buffer_string_is_empty(srv->srvconf.changeroot)) {
+		if (-1 == stat(srv->srvconf.changeroot->ptr, &st1)) {
 			log_error_write(srv, __FILE__, __LINE__, "sb",
-					"base-docroot doesn't exist:",
-					s->document_root);
+					"server.chroot doesn't exist:", srv->srvconf.changeroot);
 			return -1;
 		}
-
-	} else {
-		buffer_copy_string_buffer(srv->tmp_buf, srv->srvconf.changeroot);
-		buffer_append_string_buffer(srv->tmp_buf, s->document_root);
-
-		if (-1 == stat(srv->tmp_buf->ptr, &st1)) {
+		if (!S_ISDIR(st1.st_mode)) {
 			log_error_write(srv, __FILE__, __LINE__, "sb",
-					"base-docroot doesn't exist:",
-					srv->tmp_buf);
+					"server.chroot isn't a directory:", srv->srvconf.changeroot);
 			return -1;
 		}
+	}
+
+	if (buffer_string_is_empty(s->document_root)) {
+		log_error_write(srv, __FILE__, __LINE__, "s",
+				"a default document-root has to be set");
 
+		return -1;
 	}
 
-	buffer_copy_string_buffer(srv->tmp_buf, s->document_root);
+	buffer_copy_buffer(srv->tmp_buf, s->document_root);
 
 	buffer_to_lower(srv->tmp_buf);
 
@@ -1277,7 +1283,7 @@
 			is_lower = buffer_is_equal(srv->tmp_buf, s->document_root);
 
 			/* lower-case existed, check upper-case */
-			buffer_copy_string_buffer(srv->tmp_buf, s->document_root);
+			buffer_copy_buffer(srv->tmp_buf, s->document_root);
 
 			buffer_to_upper(srv->tmp_buf);
 
@@ -1306,10 +1312,10 @@
 	}
 
 	if (srv->srvconf.port == 0) {
-		srv->srvconf.port = s->is_ssl ? 443 : 80;
+		srv->srvconf.port = s->ssl_enabled ? 443 : 80;
 	}
 
-	if (srv->srvconf.event_handler->used == 0) {
+	if (buffer_string_is_empty(srv->srvconf.event_handler)) {
 		/* choose a good default
 		 *
 		 * the event_handler list is sorted by 'goodness'
@@ -1344,8 +1350,8 @@
 		}
 	}
 
-	if (s->is_ssl) {
-		if (buffer_is_empty(s->ssl_pemfile)) {
+	if (s->ssl_enabled) {
+		if (buffer_string_is_empty(s->ssl_pemfile)) {
 			/* PEM file is require */
 
 			log_error_write(srv, __FILE__, __LINE__, "s",
diff -u lighttpd-1.4.32/src/configfile-glue.c lighttpd-1.4.36/src/configfile-glue.c
--- lighttpd-1.4.32/src/configfile-glue.c	2012-11-07 08:50:51.000000000 -0600
+++ lighttpd-1.4.36/src/configfile-glue.c	2015-07-26 05:36:36.000000000 -0500
@@ -46,19 +46,19 @@
 					if (da->value->data[j]->type == TYPE_STRING) {
 						data_string *ds = data_string_init();
 
-						buffer_copy_string_buffer(ds->value, ((data_string *)(da->value->data[j]))->value);
+						buffer_copy_buffer(ds->value, ((data_string *)(da->value->data[j]))->value);
 						if (!da->is_index_key) {
 							/* the id's were generated automaticly, as we copy now we might have to renumber them
 							 * this is used to prepend server.modules by mod_indexfile as it has to be loaded
 							 * before mod_fastcgi and friends */
-							buffer_copy_string_buffer(ds->key, ((data_string *)(da->value->data[j]))->key);
+							buffer_copy_buffer(ds->key, ((data_string *)(da->value->data[j]))->key);
 						}
 
 						array_insert_unique(cv[i].destination, (data_unset *)ds);
 					} else {
-						log_error_write(srv, __FILE__, __LINE__, "sssd",
-								"the key of an array can only be a string or a integer, variable:",
-								cv[i].key, "type:", da->value->data[j]->type);
+						log_error_write(srv, __FILE__, __LINE__, "sssbsd",
+								"the value of an array can only be a string, variable:",
+								cv[i].key, "[", da->value->data[j]->key, "], type:", da->value->data[j]->type);
 
 						return -1;
 					}
@@ -73,7 +73,7 @@
 			if (du->type == TYPE_STRING) {
 				data_string *ds = (data_string *)du;
 
-				buffer_copy_string_buffer(cv[i].destination, ds->value);
+				buffer_copy_buffer(cv[i].destination, ds->value);
 			} else {
 				log_error_write(srv, __FILE__, __LINE__, "ssss", cv[i].key, "should have been a string like ... = \"...\"");
 
@@ -202,7 +202,7 @@
 		touched = data_string_init();
 
 		buffer_copy_string_len(touched->value, CONST_STR_LEN(""));
-		buffer_copy_string_buffer(touched->key, du->key);
+		buffer_copy_buffer(touched->key, du->key);
 
 		array_insert_unique(srv->config_touched, (data_unset *)touched);
 	}
@@ -285,7 +285,7 @@
 	case COMP_HTTP_HOST: {
 		char *ck_colon = NULL, *val_colon = NULL;
 
-		if (!buffer_is_empty(con->uri.authority)) {
+		if (!buffer_string_is_empty(con->uri.authority)) {
 
 			/*
 			 * append server-port to the HTTP_POST if necessary
@@ -301,9 +301,9 @@
 
 				if (NULL != ck_colon && NULL == val_colon) {
 					/* condition "host:port" but client send "host" */
-					buffer_copy_string_buffer(srv->cond_check_buf, l);
+					buffer_copy_buffer(srv->cond_check_buf, l);
 					buffer_append_string_len(srv->cond_check_buf, CONST_STR_LEN(":"));
-					buffer_append_long(srv->cond_check_buf, sock_addr_get_port(&(srv_sock->addr)));
+					buffer_append_int(srv->cond_check_buf, sock_addr_get_port(&(srv_sock->addr)));
 					l = srv->cond_check_buf;
 				} else if (NULL != val_colon && NULL == ck_colon) {
 					/* condition "host" but client send "host:port" */
@@ -315,7 +315,7 @@
 				break;
 			}
 #if defined USE_OPENSSL && ! defined OPENSSL_NO_TLSEXT
-		} else if (!buffer_is_empty(con->tlsext_server_name)) {
+		} else if (!buffer_string_is_empty(con->tlsext_server_name)) {
 			l = con->tlsext_server_name;
 #endif
 		} else {
@@ -357,6 +357,12 @@
 				return COND_RESULT_FALSE;
 			}
 
+			if (nm_bits > 32 || nm_bits < 0) {
+				log_error_write(srv, __FILE__, __LINE__, "sbs", "ERROR: invalid netmask:", dc->string, err);
+
+				return COND_RESULT_FALSE;
+			}
+
 			/* take IP convert to the native */
 			buffer_copy_string_len(srv->cond_check_buf, dc->string->ptr, nm_slash - dc->string->ptr);
 #ifdef __WIN32
@@ -375,7 +381,7 @@
 #endif
 
 			/* build netmask */
-			nm = htonl(~((1 << (32 - nm_bits)) - 1));
+			nm = nm_bits ? htonl(~((1 << (32 - nm_bits)) - 1)) : 0;
 
 			if ((val_inp.s_addr & nm) == (con->dst_addr.ipv4.sin_addr.s_addr & nm)) {
 				return (dc->cond == CONFIG_COND_EQ) ? COND_RESULT_TRUE : COND_RESULT_FALSE;
@@ -485,7 +491,7 @@
 #ifndef elementsof
 #define elementsof(x) (sizeof(x) / sizeof(x[0]))
 #endif
-		n = pcre_exec(dc->regex, dc->regex_study, l->ptr, l->used - 1, 0, 0,
+		n = pcre_exec(dc->regex, dc->regex_study, CONST_BUF_LEN(l), 0, 0,
 				cache->matches, elementsof(cache->matches));
 
 		cache->patterncount = n;
Only in lighttpd-1.4.36/src: config.h.cmake
diff -u lighttpd-1.4.32/src/configparser.c lighttpd-1.4.36/src/configparser.c
--- lighttpd-1.4.32/src/configparser.c	2012-11-20 04:56:43.000000000 -0600
+++ lighttpd-1.4.36/src/configparser.c	2015-07-26 05:37:02.000000000 -0500
@@ -17,7 +17,7 @@
 static void configparser_push(config_t *ctx, data_config *dc, int isnew) {
   if (isnew) {
     dc->context_ndx = ctx->all_configs->used;
-    assert(dc->context_ndx > ctx->current->context_ndx);
+    force_assert(dc->context_ndx > ctx->current->context_ndx);
     array_insert_unique(ctx->all_configs, (data_unset *)dc);
     dc->parent = ctx->current;
     array_insert_unique(dc->parent->childs, (data_unset *)dc);
@@ -64,11 +64,11 @@
   if (op1->type != op2->type) {
     if (op1->type == TYPE_STRING && op2->type == TYPE_INTEGER) {
       data_string *ds = (data_string *)op1;
-      buffer_append_long(ds->value, ((data_integer*)op2)->value);
+      buffer_append_int(ds->value, ((data_integer*)op2)->value);
       return op1;
     } else if (op1->type == TYPE_INTEGER && op2->type == TYPE_STRING) {
       data_string *ds = data_string_init();
-      buffer_append_long(ds->value, ((data_integer*)op1)->value);
+      buffer_append_int(ds->value, ((data_integer*)op1)->value);
       buffer_append_string_buffer(ds->value, ((data_string*)op2)->value);
       op1->free(op1);
       return (data_unset *)ds;
@@ -99,7 +99,7 @@
       }
       break;
     default:
-      assert(0);
+      force_assert(0);
       break;
     }
   }
@@ -841,7 +841,7 @@
 #line 146 "../../src/configparser.y"
 {
   if (ctx->ok) {
-    buffer_copy_string_buffer(yymsp[0].minor.yy41->key, yymsp[-2].minor.yy43);
+    buffer_copy_buffer(yymsp[0].minor.yy41->key, yymsp[-2].minor.yy43);
     if (strncmp(yymsp[-2].minor.yy43->ptr, "env.", sizeof("env.") - 1) == 0) {
       fprintf(stderr, "Setting env variable is not supported in conditional %d %s: %s\n",
           ctx->current->context_ndx,
@@ -883,7 +883,7 @@
       ctx->ok = 0;
     }
     else {
-      buffer_copy_string_buffer(du->key, yymsp[-2].minor.yy43);
+      buffer_copy_buffer(du->key, yymsp[-2].minor.yy43);
       array_replace(vars, du);
     }
     yymsp[0].minor.yy41->free(yymsp[0].minor.yy41);
@@ -893,12 +893,12 @@
       ctx->ok = 0;
     }
     else {
-      buffer_copy_string_buffer(du->key, yymsp[-2].minor.yy43);
+      buffer_copy_buffer(du->key, yymsp[-2].minor.yy43);
       array_insert_unique(ctx->current->value, du);
     }
     yymsp[0].minor.yy41->free(yymsp[0].minor.yy41);
   } else {
-    buffer_copy_string_buffer(yymsp[0].minor.yy41->key, yymsp[-2].minor.yy43);
+    buffer_copy_buffer(yymsp[0].minor.yy41->key, yymsp[-2].minor.yy43);
     array_insert_unique(ctx->current->value, yymsp[0].minor.yy41);
   }
   buffer_free(yymsp[-2].minor.yy43);
@@ -979,7 +979,7 @@
 #line 263 "../../src/configparser.y"
 {
   yygotominor.yy41 = (data_unset *)data_string_init();
-  buffer_copy_string_buffer(((data_string *)(yygotominor.yy41))->value, yymsp[0].minor.yy0);
+  buffer_copy_buffer(((data_string *)(yygotominor.yy41))->value, yymsp[0].minor.yy0);
   buffer_free(yymsp[0].minor.yy0);
   yymsp[0].minor.yy0 = NULL;
 }
@@ -1074,7 +1074,7 @@
       case 24:
 #line 322 "../../src/configparser.y"
 {
-  buffer_copy_string_buffer(yymsp[0].minor.yy41->key, yymsp[-2].minor.yy43);
+  buffer_copy_buffer(yymsp[0].minor.yy41->key, yymsp[-2].minor.yy43);
   buffer_free(yymsp[-2].minor.yy43);
   yymsp[-2].minor.yy43 = NULL;
 
@@ -1094,7 +1094,7 @@
 {
   data_config *dc;
   dc = (data_config *)array_get_element(ctx->srv->config_context, "global");
-  assert(dc);
+  force_assert(dc);
   configparser_push(ctx, dc, 0);
 }
 #line 1100 "configparser.c"
@@ -1108,7 +1108,7 @@
   cur = ctx->current;
   configparser_pop(ctx);
 
-  assert(cur && ctx->current);
+  force_assert(cur && ctx->current);
 
   yygotominor.yy78 = cur;
 }
@@ -1151,7 +1151,7 @@
   cur = ctx->current;
   configparser_pop(ctx);
 
-  assert(cur && ctx->current);
+  force_assert(cur && ctx->current);
 
   yygotominor.yy78 = cur;
 }
@@ -1186,12 +1186,12 @@
     op = buffer_init_string("=~");
     break;
   default:
-    assert(0);
+    force_assert(0);
     return;
   }
 
   b = buffer_init();
-  buffer_copy_string_buffer(b, ctx->current->key);
+  buffer_copy_buffer(b, ctx->current->key);
   buffer_append_string(b, "/");
   buffer_append_string_buffer(b, yymsp[-5].minor.yy0);
   buffer_append_string_buffer(b, yymsp[-3].minor.yy43);
@@ -1227,9 +1227,9 @@
 
     dc = data_config_init();
 
-    buffer_copy_string_buffer(dc->key, b);
-    buffer_copy_string_buffer(dc->op, op);
-    buffer_copy_string_buffer(dc->comp_key, yymsp[-5].minor.yy0);
+    buffer_copy_buffer(dc->key, b);
+    buffer_copy_buffer(dc->op, op);
+    buffer_copy_buffer(dc->comp_key, yymsp[-5].minor.yy0);
     buffer_append_string_len(dc->comp_key, CONST_STR_LEN("[\""));
     buffer_append_string_buffer(dc->comp_key, yymsp[-3].minor.yy43);
     buffer_append_string_len(dc->comp_key, CONST_STR_LEN("\"]"));
@@ -1358,7 +1358,7 @@
       yygotominor.yy43 = buffer_init_buffer(((data_string*)yymsp[0].minor.yy41)->value);
     } else if (yymsp[0].minor.yy41->type == TYPE_INTEGER) {
       yygotominor.yy43 = buffer_init();
-      buffer_copy_long(yygotominor.yy43, ((data_integer *)yymsp[0].minor.yy41)->value);
+      buffer_copy_int(yygotominor.yy43, ((data_integer *)yymsp[0].minor.yy41)->value);
     } else {
       fprintf(stderr, "operand must be string");
       ctx->ok = 0;
diff -u lighttpd-1.4.32/src/configparser.y lighttpd-1.4.36/src/configparser.y
--- lighttpd-1.4.32/src/configparser.y	2012-04-08 02:57:56.000000000 -0500
+++ lighttpd-1.4.36/src/configparser.y	2015-07-26 05:36:36.000000000 -0500
@@ -14,7 +14,7 @@
 static void configparser_push(config_t *ctx, data_config *dc, int isnew) {
   if (isnew) {
     dc->context_ndx = ctx->all_configs->used;
-    assert(dc->context_ndx > ctx->current->context_ndx);
+    force_assert(dc->context_ndx > ctx->current->context_ndx);
     array_insert_unique(ctx->all_configs, (data_unset *)dc);
     dc->parent = ctx->current;
     array_insert_unique(dc->parent->childs, (data_unset *)dc);
@@ -61,11 +61,11 @@
   if (op1->type != op2->type) {
     if (op1->type == TYPE_STRING && op2->type == TYPE_INTEGER) {
       data_string *ds = (data_string *)op1;
-      buffer_append_long(ds->value, ((data_integer*)op2)->value);
+      buffer_append_int(ds->value, ((data_integer*)op2)->value);
       return op1;
     } else if (op1->type == TYPE_INTEGER && op2->type == TYPE_STRING) {
       data_string *ds = data_string_init();
-      buffer_append_long(ds->value, ((data_integer*)op1)->value);
+      buffer_append_int(ds->value, ((data_integer*)op1)->value);
       buffer_append_string_buffer(ds->value, ((data_string*)op2)->value);
       op1->free(op1);
       return (data_unset *)ds;
@@ -96,7 +96,7 @@
       }
       break;
     default:
-      assert(0);
+      force_assert(0);
       break;
     }
   }
@@ -145,7 +145,7 @@
 
 varline ::= key(A) ASSIGN expression(B). {
   if (ctx->ok) {
-    buffer_copy_string_buffer(B->key, A);
+    buffer_copy_buffer(B->key, A);
     if (strncmp(A->ptr, "env.", sizeof("env.") - 1) == 0) {
       fprintf(stderr, "Setting env variable is not supported in conditional %d %s: %s\n",
           ctx->current->context_ndx,
@@ -183,7 +183,7 @@
       ctx->ok = 0;
     }
     else {
-      buffer_copy_string_buffer(du->key, A);
+      buffer_copy_buffer(du->key, A);
       array_replace(vars, du);
     }
     B->free(B);
@@ -193,12 +193,12 @@
       ctx->ok = 0;
     }
     else {
-      buffer_copy_string_buffer(du->key, A);
+      buffer_copy_buffer(du->key, A);
       array_insert_unique(ctx->current->value, du);
     }
     B->free(B);
   } else {
-    buffer_copy_string_buffer(B->key, A);
+    buffer_copy_buffer(B->key, A);
     array_insert_unique(ctx->current->value, B);
   }
   buffer_free(A);
@@ -262,7 +262,7 @@
 
 value(A) ::= STRING(B). {
   A = (data_unset *)data_string_init();
-  buffer_copy_string_buffer(((data_string *)(A))->value, B);
+  buffer_copy_buffer(((data_string *)(A))->value, B);
   buffer_free(B);
   B = NULL;
 }
@@ -320,7 +320,7 @@
   B = NULL;
 }
 aelement(A) ::= stringop(B) ARRAY_ASSIGN expression(C). {
-  buffer_copy_string_buffer(C->key, B);
+  buffer_copy_buffer(C->key, B);
   buffer_free(B);
   B = NULL;
 
@@ -334,7 +334,7 @@
 globalstart ::= GLOBAL. {
   data_config *dc;
   dc = (data_config *)array_get_element(ctx->srv->config_context, "global");
-  assert(dc);
+  force_assert(dc);
   configparser_push(ctx, dc, 0);
 }
 
@@ -344,7 +344,7 @@
   cur = ctx->current;
   configparser_pop(ctx);
 
-  assert(cur && ctx->current);
+  force_assert(cur && ctx->current);
 
   A = cur;
 }
@@ -372,7 +372,7 @@
   cur = ctx->current;
   configparser_pop(ctx);
 
-  assert(cur && ctx->current);
+  force_assert(cur && ctx->current);
 
   A = cur;
 }
@@ -400,12 +400,12 @@
     op = buffer_init_string("=~");
     break;
   default:
-    assert(0);
+    force_assert(0);
     return;
   }
 
   b = buffer_init();
-  buffer_copy_string_buffer(b, ctx->current->key);
+  buffer_copy_buffer(b, ctx->current->key);
   buffer_append_string(b, "/");
   buffer_append_string_buffer(b, B);
   buffer_append_string_buffer(b, C);
@@ -441,9 +441,9 @@
 
     dc = data_config_init();
 
-    buffer_copy_string_buffer(dc->key, b);
-    buffer_copy_string_buffer(dc->op, op);
-    buffer_copy_string_buffer(dc->comp_key, B);
+    buffer_copy_buffer(dc->key, b);
+    buffer_copy_buffer(dc->op, op);
+    buffer_copy_buffer(dc->comp_key, B);
     buffer_append_string_len(dc->comp_key, CONST_STR_LEN("[\""));
     buffer_append_string_buffer(dc->comp_key, C);
     buffer_append_string_len(dc->comp_key, CONST_STR_LEN("\"]"));
@@ -546,7 +546,7 @@
       A = buffer_init_buffer(((data_string*)B)->value);
     } else if (B->type == TYPE_INTEGER) {
       A = buffer_init();
-      buffer_copy_long(A, ((data_integer *)B)->value);
+      buffer_copy_int(A, ((data_integer *)B)->value);
     } else {
       fprintf(stderr, "operand must be string");
       ctx->ok = 0;
diff -u lighttpd-1.4.32/src/connections.c lighttpd-1.4.36/src/connections.c
--- lighttpd-1.4.32/src/connections.c	2012-11-07 07:16:36.000000000 -0600
+++ lighttpd-1.4.36/src/connections.c	2015-07-26 05:36:36.000000000 -0500
@@ -197,48 +197,34 @@
 
 static int connection_handle_read_ssl(server *srv, connection *con) {
 #ifdef USE_OPENSSL
-	int r, ssl_err, len, count = 0, read_offset, toread;
-	buffer *b = NULL;
+	int r, ssl_err, len, count = 0;
+	char *mem = NULL;
+	size_t mem_len = 0;
 
-	if (!con->conf.is_ssl) return -1;
+	if (!con->srv_socket->is_ssl) return -1;
 
 	ERR_clear_error();
 	do {
-		if (NULL != con->read_queue->last) {
-			b = con->read_queue->last->mem;
-		}
-
-		if (NULL == b || b->size - b->used < 1024) {
-			b = chunkqueue_get_append_buffer(con->read_queue);
-			len = SSL_pending(con->ssl);
-			if (len < 4*1024) len = 4*1024; /* always alloc >= 4k buffer */
-			buffer_prepare_copy(b, len + 1);
-
-			/* overwrite everything with 0 */
-			memset(b->ptr, 0, b->size);
-		}
-
-		read_offset = (b->used > 0) ? b->used - 1 : 0;
-		toread = b->size - 1 - read_offset;
+		chunkqueue_get_memory(con->read_queue, &mem, &mem_len, 0, SSL_pending(con->ssl));
+#if 0
+		/* overwrite everything with 0 */
+		memset(mem, 0, mem_len);
+#endif
 
-		len = SSL_read(con->ssl, b->ptr + read_offset, toread);
+		len = SSL_read(con->ssl, mem, mem_len);
+		chunkqueue_use_memory(con->read_queue, len > 0 ? len : 0);
 
 		if (con->renegotiations > 1 && con->conf.ssl_disable_client_renegotiation) {
+			log_error_write(srv, __FILE__, __LINE__, "s", "SSL: renegotiation initiated by client, killing connection");
 			connection_set_state(srv, con, CON_STATE_ERROR);
-			log_error_write(srv, __FILE__, __LINE__, "s", "SSL: renegotiation initiated by client");
 			return -1;
 		}
 
 		if (len > 0) {
-			if (b->used > 0) b->used--;
-			b->used += len;
-			b->ptr[b->used++] = '\0';
-
 			con->bytes_read += len;
-
 			count += len;
 		}
-	} while (len == toread && count < MAX_READ_LIMIT);
+	} while (len == (ssize_t) mem_len && count < MAX_READ_LIMIT);
 
 
 	if (len < 0) {
@@ -331,44 +317,36 @@
 /* 0: everything ok, -1: error, -2: con closed */
 static int connection_handle_read(server *srv, connection *con) {
 	int len;
-	buffer *b;
-	int toread, read_offset;
+	char *mem = NULL;
+	size_t mem_len = 0;
+	int toread;
 
-	if (con->conf.is_ssl) {
+	if (con->srv_socket->is_ssl) {
 		return connection_handle_read_ssl(srv, con);
 	}
 
-	b = (NULL != con->read_queue->last) ? con->read_queue->last->mem : NULL;
-
 	/* default size for chunks is 4kb; only use bigger chunks if FIONREAD tells
 	 *  us more than 4kb is available
 	 * if FIONREAD doesn't signal a big chunk we fill the previous buffer
 	 *  if it has >= 1kb free
 	 */
 #if defined(__WIN32)
-	if (NULL == b || b->size - b->used < 1024) {
-		b = chunkqueue_get_append_buffer(con->read_queue);
-		buffer_prepare_copy(b, 4 * 1024);
-	}
+	chunkqueue_get_memory(con->read_queue, &mem, &mem_len, 0, 4096);
 
-	read_offset = (b->used == 0) ? 0 : b->used - 1;
-	len = recv(con->fd, b->ptr + read_offset, b->size - 1 - read_offset, 0);
+	len = recv(con->fd, mem, mem_len, 0);
 #else
 	if (ioctl(con->fd, FIONREAD, &toread) || toread == 0 || toread <= 4*1024) {
-		if (NULL == b || b->size - b->used < 1024) {
-			b = chunkqueue_get_append_buffer(con->read_queue);
-			buffer_prepare_copy(b, 4 * 1024);
-		}
-	} else {
 		if (toread > MAX_READ_LIMIT) toread = MAX_READ_LIMIT;
-		b = chunkqueue_get_append_buffer(con->read_queue);
-		buffer_prepare_copy(b, toread + 1);
+	} else {
+		toread = 4096;
 	}
+	chunkqueue_get_memory(con->read_queue, &mem, &mem_len, 0, toread);
 
-	read_offset = (b->used == 0) ? 0 : b->used - 1;
-	len = read(con->fd, b->ptr + read_offset, b->size - 1 - read_offset);
+	len = read(con->fd, mem, mem_len);
 #endif
 
+	chunkqueue_use_memory(con->read_queue, len > 0 ? len : 0);
+
 	if (len < 0) {
 		con->is_readable = 0;
 
@@ -394,16 +372,12 @@
 		/* pipelining */
 
 		return -2;
-	} else if ((size_t)len < b->size - 1) {
+	} else if (len != (ssize_t) mem_len) {
 		/* we got less then expected, wait for the next fd-event */
 
 		con->is_readable = 0;
 	}
 
-	if (b->used > 0) b->used--;
-	b->used += len;
-	b->ptr[b->used++] = '\0';
-
 	con->bytes_read += len;
 #if 0
 	dump_packet(b->ptr, len);
@@ -419,16 +393,6 @@
 		case HTTP_METHOD_GET:
 		case HTTP_METHOD_POST:
 		case HTTP_METHOD_HEAD:
-		case HTTP_METHOD_PUT:
-		case HTTP_METHOD_PATCH:
-		case HTTP_METHOD_MKCOL:
-		case HTTP_METHOD_DELETE:
-		case HTTP_METHOD_COPY:
-		case HTTP_METHOD_MOVE:
-		case HTTP_METHOD_PROPFIND:
-		case HTTP_METHOD_PROPPATCH:
-		case HTTP_METHOD_LOCK:
-		case HTTP_METHOD_UNLOCK:
 			break;
 		case HTTP_METHOD_OPTIONS:
 			/*
@@ -436,7 +400,7 @@
 			 * 403 is from the response handler when noone else catched it
 			 *
 			 * */
-			if ((!con->http_status || con->http_status == 200) && con->uri.path->used &&
+			if ((!con->http_status || con->http_status == 200) && !buffer_string_is_empty(con->uri.path) &&
 			    con->uri.path->ptr[0] != '*') {
 				response_header_insert(srv, con, CONST_STR_LEN("Allow"), CONST_STR_LEN("OPTIONS, GET, HEAD, POST"));
 
@@ -450,16 +414,8 @@
 			}
 			break;
 		default:
-			switch(con->http_status) {
-			case 400: /* bad request */
-			case 401: /* authorization required */
-			case 414: /* overload request header */
-			case 505: /* unknown protocol */
-			case 207: /* this was webdav */
-				break;
-			default:
+			if (0 == con->http_status) {
 				con->http_status = 501;
-				break;
 			}
 			break;
 		}
@@ -491,11 +447,11 @@
 		buffer_reset(con->physical.path);
 
 		/* try to send static errorfile */
-		if (!buffer_is_empty(con->conf.errorfile_prefix)) {
+		if (!buffer_string_is_empty(con->conf.errorfile_prefix)) {
 			stat_cache_entry *sce = NULL;
 
-			buffer_copy_string_buffer(con->physical.path, con->conf.errorfile_prefix);
-			buffer_append_long(con->physical.path, con->http_status);
+			buffer_copy_buffer(con->physical.path, con->conf.errorfile_prefix);
+			buffer_append_int(con->physical.path, con->http_status);
 			buffer_append_string_len(con->physical.path, CONST_STR_LEN(".html"));
 
 			if (HANDLER_ERROR != stat_cache_get_entry(srv, con, con->physical.path, &sce)) {
@@ -512,7 +468,7 @@
 			buffer_reset(con->physical.path);
 
 			con->file_finished = 1;
-			b = chunkqueue_get_append_buffer(con->write_queue);
+			b = buffer_init();
 
 			/* build default error-page */
 			buffer_copy_string_len(b, CONST_STR_LEN(
@@ -522,7 +478,7 @@
 					   "<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n"
 					   " <head>\n"
 					   "  <title>"));
-			buffer_append_long(b, con->http_status);
+			buffer_append_int(b, con->http_status);
 			buffer_append_string_len(b, CONST_STR_LEN(" - "));
 			buffer_append_string(b, get_http_status_name(con->http_status));
 
@@ -531,7 +487,7 @@
 					     " </head>\n"
 					     " <body>\n"
 					     "  <h1>"));
-			buffer_append_long(b, con->http_status);
+			buffer_append_int(b, con->http_status);
 			buffer_append_string_len(b, CONST_STR_LEN(" - "));
 			buffer_append_string(b, get_http_status_name(con->http_status));
 
@@ -540,6 +496,10 @@
 					     "</html>\n"
 					     ));
 
+			http_chunk_append_buffer(srv, con, b);
+			buffer_free(b);
+			http_chunk_close(srv, con);
+
 			response_header_overwrite(srv, con, CONST_STR_LEN("Content-Type"), CONST_STR_LEN("text/html"));
 		}
 		break;
@@ -572,7 +532,7 @@
 				/* qlen = 0 is important for Redirects (301, ...) as they MAY have
 				 * a content. Browsers are waiting for a Content otherwise
 				 */
-				buffer_copy_off_t(srv->tmp_buf, qlen);
+				buffer_copy_int(srv->tmp_buf, qlen);
 
 				response_header_overwrite(srv, con, CONST_STR_LEN("Content-Length"), CONST_BUF_LEN(srv->tmp_buf));
 			}
@@ -694,7 +654,6 @@
 	CLEAN(physical.etag);
 	CLEAN(parse_request);
 
-	CLEAN(authed_user);
 	CLEAN(server_name);
 	CLEAN(error_handler);
 	CLEAN(dst_addr_buf);
@@ -761,7 +720,6 @@
 		CLEAN(physical.rel_path);
 		CLEAN(parse_request);
 
-		CLEAN(authed_user);
 		CLEAN(server_name);
 		CLEAN(error_handler);
 		CLEAN(dst_addr_buf);
@@ -835,7 +793,6 @@
 
 	CLEAN(parse_request);
 
-	CLEAN(authed_user);
 	CLEAN(server_name);
 	CLEAN(error_handler);
 #if defined USE_OPENSSL && ! defined OPENSSL_NO_TLSEXT
@@ -916,42 +873,7 @@
 		}
 	}
 
-	/* the last chunk might be empty */
-	for (c = cq->first; c;) {
-		if (cq->first == c && c->mem->used == 0) {
-			/* the first node is empty */
-			/* ... and it is empty, move it to unused */
-
-			cq->first = c->next;
-			if (cq->first == NULL) cq->last = NULL;
-
-			c->next = cq->unused;
-			cq->unused = c;
-			cq->unused_chunks++;
-
-			c = cq->first;
-		} else if (c->next && c->next->mem->used == 0) {
-			chunk *fc;
-			/* next node is the last one */
-			/* ... and it is empty, move it to unused */
-
-			fc = c->next;
-			c->next = fc->next;
-
-			fc->next = cq->unused;
-			cq->unused = fc;
-			cq->unused_chunks++;
-
-			/* the last node was empty */
-			if (c->next == NULL) {
-				cq->last = c;
-			}
-
-			c = c->next;
-		} else {
-			c = c->next;
-		}
-	}
+	chunkqueue_remove_finished_chunks(cq);
 
 	/* we might have got several packets at once
 	 */
@@ -970,15 +892,12 @@
 		last_offset = 0;
 
 		for (c = cq->first; c; c = c->next) {
-			buffer b;
 			size_t i;
+			size_t len = buffer_string_length(c->mem) - c->offset;
+			const char *b = c->mem->ptr + c->offset;
 
-			b.ptr = c->mem->ptr + c->offset;
-			b.used = c->mem->used - c->offset;
-			if (b.used > 0) b.used--; /* buffer "used" includes terminating zero */
-
-			for (i = 0; i < b.used; i++) {
-				char ch = b.ptr[i];
+			for (i = 0; i < len; ++i) {
+				char ch = b[i];
 
 				if ('\r' == ch) {
 					/* chec if \n\r\n follows */
@@ -988,13 +907,11 @@
 					int header_end_match_pos = 1;
 
 					for ( ; cc; cc = cc->next, j = 0 ) {
-						buffer bb;
-						bb.ptr = cc->mem->ptr + cc->offset;
-						bb.used = cc->mem->used - cc->offset;
-						if (bb.used > 0) bb.used--; /* buffer "used" includes terminating zero */
+						size_t bblen = buffer_string_length(cc->mem) - cc->offset;
+						const char *bb = c->mem->ptr + cc->offset;
 
-						for ( ; j < bb.used; j++) {
-							ch = bb.ptr[j];
+						for ( ; j < bblen; j++) {
+							ch = bb[j];
 
 							if (ch == header_end[header_end_match_pos]) {
 								header_end_match_pos++;
@@ -1019,25 +936,16 @@
 			buffer_reset(con->request.request);
 
 			for (c = cq->first; c; c = c->next) {
-				buffer b;
-
-				b.ptr = c->mem->ptr + c->offset;
-				b.used = c->mem->used - c->offset;
+				size_t len = buffer_string_length(c->mem) - c->offset;
 
 				if (c == last_chunk) {
-					b.used = last_offset + 1;
+					len = last_offset;
 				}
 
-				buffer_append_string_buffer(con->request.request, &b);
-
-				if (c == last_chunk) {
-					c->offset += last_offset;
+				buffer_append_string_len(con->request.request, c->mem->ptr + c->offset, len);
+				c->offset += len;
 
-					break;
-				} else {
-					/* the whole packet was copied */
-					c->offset = c->mem->used - 1;
-				}
+				if (c == last_chunk) break;
 			}
 
 			connection_set_state(srv, con, CON_STATE_REQUEST_END);
@@ -1050,121 +958,10 @@
 		}
 		break;
 	case CON_STATE_READ_POST:
-		for (c = cq->first; c && (dst_cq->bytes_in != (off_t)con->request.content_length); c = c->next) {
-			off_t weWant, weHave, toRead;
-
-			weWant = con->request.content_length - dst_cq->bytes_in;
-
-			assert(c->mem->used);
-
-			weHave = c->mem->used - c->offset - 1;
-
-			toRead = weHave > weWant ? weWant : weHave;
-
-			/* the new way, copy everything into a chunkqueue whcih might use tempfiles */
-			if (con->request.content_length > 64 * 1024) {
-				chunk *dst_c = NULL;
-				/* copy everything to max 1Mb sized tempfiles */
-
-				/*
-				 * if the last chunk is
-				 * - smaller than 1Mb (size < 1Mb)
-				 * - not read yet (offset == 0)
-				 * -> append to it
-				 * otherwise
-				 * -> create a new chunk
-				 *
-				 * */
-
-				if (dst_cq->last &&
-				    dst_cq->last->type == FILE_CHUNK &&
-				    dst_cq->last->file.is_temp &&
-				    dst_cq->last->offset == 0) {
-					/* ok, take the last chunk for our job */
-
-			 		if (dst_cq->last->file.length < 1 * 1024 * 1024) {
-						dst_c = dst_cq->last;
-
-						if (dst_c->file.fd == -1) {
-							/* this should not happen as we cache the fd, but you never know */
-							dst_c->file.fd = open(dst_c->file.name->ptr, O_WRONLY | O_APPEND);
-#ifdef FD_CLOEXEC
-							fcntl(dst_c->file.fd, F_SETFD, FD_CLOEXEC);
-#endif
-						}
-					} else {
-						/* the chunk is too large now, close it */
-						dst_c = dst_cq->last;
-
-						if (dst_c->file.fd != -1) {
-							close(dst_c->file.fd);
-							dst_c->file.fd = -1;
-						}
-						dst_c = chunkqueue_get_append_tempfile(dst_cq);
-					}
-				} else {
-					dst_c = chunkqueue_get_append_tempfile(dst_cq);
-				}
-
-				/* we have a chunk, let's write to it */
-
-				if (dst_c->file.fd == -1) {
-					/* we don't have file to write to,
-					 * EACCES might be one reason.
-					 *
-					 * Instead of sending 500 we send 413 and say the request is too large
-					 *  */
-
-					log_error_write(srv, __FILE__, __LINE__, "sbs",
-							"denying upload as opening to temp-file for upload failed:",
-							dst_c->file.name, strerror(errno));
-
-					con->http_status = 413; /* Request-Entity too large */
-					con->keep_alive = 0;
-					connection_set_state(srv, con, CON_STATE_HANDLE_REQUEST);
-
-					break;
-				}
-
-				if (toRead != write(dst_c->file.fd, c->mem->ptr + c->offset, toRead)) {
-					/* write failed for some reason ... disk full ? */
-					log_error_write(srv, __FILE__, __LINE__, "sbs",
-							"denying upload as writing to file failed:",
-							dst_c->file.name, strerror(errno));
-
-					con->http_status = 413; /* Request-Entity too large */
-					con->keep_alive = 0;
-					connection_set_state(srv, con, CON_STATE_HANDLE_REQUEST);
-
-					close(dst_c->file.fd);
-					dst_c->file.fd = -1;
-
-					break;
-				}
-
-				dst_c->file.length += toRead;
-
-				if (dst_cq->bytes_in + toRead == (off_t)con->request.content_length) {
-					/* we read everything, close the chunk */
-					close(dst_c->file.fd);
-					dst_c->file.fd = -1;
-				}
-			} else {
-				buffer *b;
-
-				if (dst_cq->last &&
-				    dst_cq->last->type == MEM_CHUNK) {
-					b = dst_cq->last->mem;
-				} else {
-					b = chunkqueue_get_append_buffer(dst_cq);
-					/* prepare buffer size for remaining POST data; is < 64kb */
-					buffer_prepare_copy(b, con->request.content_length - dst_cq->bytes_in + 1);
-				}
-				buffer_append_string_len(b, c->mem->ptr + c->offset, toRead);
-			}
-
-			c->offset += toRead;
-			dst_cq->bytes_in += toRead;
+		if (0 != chunkqueue_steal_with_tempfiles(srv, dst_cq, cq, con->request.content_length - dst_cq->bytes_in )) {
+			con->http_status = 413; /* Request-Entity too large */
+			con->keep_alive = 0;
+			connection_set_state(srv, con, CON_STATE_HANDLE_REQUEST);
 		}
 
 		/* Content is ready */
@@ -1192,7 +989,7 @@
 
 	joblist_append(srv, con);
 
-	if (con->conf.is_ssl) {
+	if (con->srv_socket->is_ssl) {
 		/* ssl may read and write for both reads and writes */
 		if (revents & (FDEVENT_IN | FDEVENT_OUT)) {
 			con->is_readable = 1;
@@ -1363,7 +1160,6 @@
 			con->renegotiations = 0;
 			SSL_set_app_data(con->ssl, con);
 			SSL_set_accept_state(con->ssl);
-			con->conf.is_ssl=1;
 
 			if (1 != (SSL_set_fd(con->ssl, cnt))) {
 				log_error_write(srv, __FILE__, __LINE__, "ss", "SSL:",
@@ -1408,12 +1204,6 @@
 
 			connection_set_state(srv, con, CON_STATE_READ);
 
-			/* patch con->conf.is_ssl if the connection is a ssl-socket already */
-
-#ifdef USE_OPENSSL
-			con->conf.is_ssl = srv_sock->is_ssl;
-#endif
-
 			break;
 		case CON_STATE_REQUEST_END: /* transient */
 			if (srv->srvconf.log_state_handling) {
@@ -1460,17 +1250,17 @@
 						/* 404 error-handler */
 
 						if (con->in_error_handler == 0 &&
-						    (!buffer_is_empty(con->conf.error_handler) ||
-						     !buffer_is_empty(con->error_handler))) {
+						    (!buffer_string_is_empty(con->conf.error_handler) ||
+						     !buffer_string_is_empty(con->error_handler))) {
 							/* call error-handler */
 
 							con->error_handler_saved_status = con->http_status;
 							con->http_status = 0;
 
-							if (buffer_is_empty(con->error_handler)) {
-								buffer_copy_string_buffer(con->request.uri, con->conf.error_handler);
+							if (buffer_string_is_empty(con->error_handler)) {
+								buffer_copy_buffer(con->request.uri, con->conf.error_handler);
 							} else {
-								buffer_copy_string_buffer(con->request.uri, con->error_handler);
+								buffer_copy_buffer(con->request.uri, con->error_handler);
 							}
 							buffer_reset(con->physical.path);
 
@@ -1505,6 +1295,7 @@
 				break;
 			case HANDLER_COMEBACK:
 				done = -1;
+				/* fallthrough */
 			case HANDLER_WAIT_FOR_EVENT:
 				/* come back here */
 				connection_set_state(srv, con, CON_STATE_HANDLE_REQUEST);
@@ -1661,20 +1452,16 @@
 
 			/* only try to write if we have something in the queue */
 			if (!chunkqueue_is_empty(con->write_queue)) {
-#if 0
-				log_error_write(srv, __FILE__, __LINE__, "dsd",
-						con->fd,
-						"packets to write:",
-						con->write_queue->used);
-#endif
-			}
-			if (!chunkqueue_is_empty(con->write_queue) && con->is_writable) {
-				if (-1 == connection_handle_write(srv, con)) {
-					log_error_write(srv, __FILE__, __LINE__, "ds",
-							con->fd,
-							"handle write failed.");
-					connection_set_state(srv, con, CON_STATE_ERROR);
+				if (con->is_writable) {
+					if (-1 == connection_handle_write(srv, con)) {
+						log_error_write(srv, __FILE__, __LINE__, "ds",
+								con->fd,
+								"handle write failed.");
+						connection_set_state(srv, con, CON_STATE_ERROR);
+					}
 				}
+			} else if (con->file_finished) {
+				connection_set_state(srv, con, CON_STATE_RESPONSE_END);
 			}
 
 			break;
@@ -1736,8 +1523,8 @@
 						break;
 					}
 				}
+				ERR_clear_error();
 			}
-			ERR_clear_error();
 #endif
 
 			switch(con->mode) {
diff -u lighttpd-1.4.32/src/crc32.c lighttpd-1.4.36/src/crc32.c
--- lighttpd-1.4.32/src/crc32.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/crc32.c	2015-07-26 05:36:36.000000000 -0500
@@ -70,7 +70,7 @@
 };
 
 
-uint32_t generate_crc32c(char *buffer, size_t length) {
+uint32_t generate_crc32c(const char *buffer, size_t length) {
   size_t i;
   uint32_t crc32 = ~0L;
 
diff -u lighttpd-1.4.32/src/crc32.h lighttpd-1.4.36/src/crc32.h
--- lighttpd-1.4.32/src/crc32.h	2010-02-01 17:28:20.000000000 -0600
+++ lighttpd-1.4.36/src/crc32.h	2015-07-26 05:36:36.000000000 -0500
@@ -13,6 +13,6 @@
 # include <inttypes.h>
 #endif
 
-uint32_t generate_crc32c(char *string, size_t length);
+uint32_t generate_crc32c(const char *string, size_t length);
 
 #endif
diff -u lighttpd-1.4.32/src/data_array.c lighttpd-1.4.36/src/data_array.c
--- lighttpd-1.4.32/src/data_array.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/data_array.c	2015-07-26 05:36:36.000000000 -0500
@@ -8,7 +8,7 @@
 	data_array *src = (data_array *)s;
 	data_array *ds = data_array_init();
 
-	buffer_copy_string_buffer(ds->key, src->key);
+	buffer_copy_buffer(ds->key, src->key);
 	array_free(ds->value);
 	ds->value = array_init_array(src->value);
 	ds->is_index_key = src->is_index_key;
diff -u lighttpd-1.4.32/src/data_config.c lighttpd-1.4.36/src/data_config.c
--- lighttpd-1.4.32/src/data_config.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/data_config.c	2015-07-26 05:36:36.000000000 -0500
@@ -8,8 +8,8 @@
 	data_config *src = (data_config *)s;
 	data_config *ds = data_config_init();
 
-	buffer_copy_string_buffer(ds->key, src->key);
-	buffer_copy_string_buffer(ds->comp_key, src->comp_key);
+	buffer_copy_buffer(ds->key, src->key);
+	buffer_copy_buffer(ds->comp_key, src->comp_key);
 	array_free(ds->value);
 	ds->value = array_init_array(src->value);
 	return (data_unset *)ds;
diff -u lighttpd-1.4.32/src/data_count.c lighttpd-1.4.36/src/data_count.c
--- lighttpd-1.4.32/src/data_count.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/data_count.c	2015-07-26 05:36:36.000000000 -0500
@@ -8,7 +8,7 @@
 	data_count *src = (data_count *)s;
 	data_count *ds = data_count_init();
 
-	buffer_copy_string_buffer(ds->key, src->key);
+	buffer_copy_buffer(ds->key, src->key);
 	ds->count = src->count;
 	ds->is_index_key = src->is_index_key;
 	return (data_unset *)ds;
diff -u lighttpd-1.4.32/src/data_fastcgi.c lighttpd-1.4.36/src/data_fastcgi.c
--- lighttpd-1.4.32/src/data_fastcgi.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/data_fastcgi.c	2015-07-26 05:36:36.000000000 -0500
@@ -9,8 +9,8 @@
 	data_fastcgi *src = (data_fastcgi *)s;
 	data_fastcgi *ds = data_fastcgi_init();
 
-	buffer_copy_string_buffer(ds->key, src->key);
-	buffer_copy_string_buffer(ds->host, src->host);
+	buffer_copy_buffer(ds->key, src->key);
+	buffer_copy_buffer(ds->host, src->host);
 	ds->is_index_key = src->is_index_key;
 	return (data_unset *)ds;
 }
diff -u lighttpd-1.4.32/src/data_integer.c lighttpd-1.4.36/src/data_integer.c
--- lighttpd-1.4.32/src/data_integer.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/data_integer.c	2015-07-26 05:36:36.000000000 -0500
@@ -8,7 +8,7 @@
 	data_integer *src = (data_integer *)s;
 	data_integer *ds = data_integer_init();
 
-	buffer_copy_string_buffer(ds->key, src->key);
+	buffer_copy_buffer(ds->key, src->key);
 	ds->is_index_key = src->is_index_key;
 	ds->value = src->value;
 	return (data_unset *)ds;
diff -u lighttpd-1.4.32/src/data_string.c lighttpd-1.4.36/src/data_string.c
--- lighttpd-1.4.32/src/data_string.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/data_string.c	2015-07-26 05:36:36.000000000 -0500
@@ -9,8 +9,8 @@
 	data_string *src = (data_string *)s;
 	data_string *ds = data_string_init();
 
-	buffer_copy_string_buffer(ds->key, src->key);
-	buffer_copy_string_buffer(ds->value, src->value);
+	buffer_copy_buffer(ds->key, src->key);
+	buffer_copy_buffer(ds->value, src->value);
 	ds->is_index_key = src->is_index_key;
 	return (data_unset *)ds;
 }
@@ -36,11 +36,11 @@
 	data_string *ds_dst = (data_string *)dst;
 	data_string *ds_src = (data_string *)src;
 
-	if (ds_dst->value->used) {
+	if (!buffer_is_empty(ds_dst->value)) {
 		buffer_append_string_len(ds_dst->value, CONST_STR_LEN(", "));
 		buffer_append_string_buffer(ds_dst->value, ds_src->value);
 	} else {
-		buffer_copy_string_buffer(ds_dst->value, ds_src->value);
+		buffer_copy_buffer(ds_dst->value, ds_src->value);
 	}
 
 	src->free(src);
@@ -52,13 +52,13 @@
 	data_string *ds_dst = (data_string *)dst;
 	data_string *ds_src = (data_string *)src;
 
-	if (ds_dst->value->used) {
+	if (!buffer_is_empty(ds_dst->value)) {
 		buffer_append_string_len(ds_dst->value, CONST_STR_LEN("\r\n"));
 		buffer_append_string_buffer(ds_dst->value, ds_dst->key);
 		buffer_append_string_len(ds_dst->value, CONST_STR_LEN(": "));
 		buffer_append_string_buffer(ds_dst->value, ds_src->value);
 	} else {
-		buffer_copy_string_buffer(ds_dst->value, ds_src->value);
+		buffer_copy_buffer(ds_dst->value, ds_src->value);
 	}
 
 	src->free(src);
@@ -69,18 +69,19 @@
 
 static void data_string_print(const data_unset *d, int depth) {
 	data_string *ds = (data_string *)d;
-	unsigned int i;
+	size_t i, len;
 	UNUSED(depth);
 
 	/* empty and uninitialized strings */
-	if (ds->value->used < 1) {
+	if (buffer_string_is_empty(ds->value)) {
 		fputs("\"\"", stdout);
 		return;
 	}
 
 	/* print out the string as is, except prepend " with backslash */
 	putc('"', stdout);
-	for (i = 0; i < ds->value->used - 1; i++) {
+	len = buffer_string_length(ds->value);
+	for (i = 0; i < len; i++) {
 		unsigned char c = ds->value->ptr[i];
 		if (c == '"') {
 			fputs("\\\"", stdout);
@@ -96,7 +97,7 @@
 	data_string *ds;
 
 	ds = calloc(1, sizeof(*ds));
-	assert(ds);
+	force_assert(ds);
 
 	ds->key = buffer_init();
 	ds->value = buffer_init();
diff -u lighttpd-1.4.32/src/etag.c lighttpd-1.4.36/src/etag.c
--- lighttpd-1.4.32/src/etag.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/etag.c	2015-07-26 05:36:36.000000000 -0500
@@ -9,8 +9,140 @@
 
 #include <string.h>
 
-int etag_is_equal(buffer *etag, const char *matches) {
-	if (etag && !buffer_is_empty(etag) && 0 == strcmp(etag->ptr, matches)) return 1;
+int etag_is_equal(buffer *etag, const char *line, int weak_ok) {
+	enum {
+		START = 0,
+		CHECK,
+		CHECK_QUOTED,
+		SKIP,
+		SKIP_QUOTED,
+		TAIL
+	} state = START;
+
+	const char *current;
+	const char *tok_start;
+	const char *tok = NULL;
+	int matched;
+
+	if ('*' == line[0] && '\0' == line[1]) {
+		return 1;
+	}
+
+	if (!etag || buffer_string_is_empty(etag)) return 0;
+	tok_start = etag->ptr;
+
+	if ('W' == tok_start[0]) {
+		if (!weak_ok || '/' != tok_start[1]) return 0; /* bad etag */
+		tok_start = tok_start + 2;
+	}
+
+	if ('"' != tok_start[0]) return 0; /* bad etag */
+	/* we start comparing after the first '"' */
+	++tok_start;
+
+	for (current = line; *current; ++current) {
+		switch (state) {
+		case START:
+			/* wait for etag to start; ignore whitespace and ',' */
+			switch (*current) {
+			case 'W':
+				/* weak etag always starts with 'W/"' */
+				if ('/' != *++current) return 0; /* bad etag list */
+				if ('"' != *++current) return 0; /* bad etag list */
+				if (!weak_ok) {
+					state = SKIP;
+				} else {
+					state = CHECK;
+					tok = tok_start;
+				}
+				break;
+			case '"':
+				/* strong etag starts with '"' */
+				state = CHECK;
+				tok = tok_start;
+				break;
+			case ' ':
+			case ',':
+			case '\t':
+			case '\r':
+			case '\n':
+				break;
+			default:
+				return 0; /* bad etag list */
+			}
+			break;
+		case CHECK:
+			/* compare etags (after the beginning '"')
+			 * quoted-pairs must match too (i.e. quoted in both strings):
+			 * > (RFC 2616:) both validators MUST be identical in every way
+			 */
+			matched = *tok && *tok == *current;
+			++tok;
+			switch (*current) {
+			case '\\':
+				state = matched ? CHECK_QUOTED : SKIP_QUOTED;
+				break;
+			case '"':
+				if (*tok)  {
+					/* bad etag - string should end after '"' */
+					return 0;
+				}
+				if (matched) {
+					/* matching etag: strings were equal */
+					return 1;
+				}
+
+				state = TAIL;
+				break;
+			default:
+				if (!matched) {
+					/* strings not matching, skip remainder of etag */
+					state = SKIP;
+				}
+				break;
+			}
+			break;
+		case CHECK_QUOTED:
+			if (!*tok || *tok != *current) {
+				/* strings not matching, skip remainder of etag */
+				state = SKIP;
+				break;
+			}
+			++tok;
+			state = CHECK;
+			break;
+		case SKIP:
+			/* wait for final (not quoted) '"' */
+			switch (*current) {
+			case '\\':
+				state = SKIP_QUOTED;
+				break;
+			case '"':
+				state = TAIL;
+				break;
+			}
+			break;
+		case SKIP_QUOTED:
+			state = SKIP;
+			break;
+		case TAIL:
+			/* search for ',', ignore white space */
+			switch (*current) {
+			case ',':
+				state = START;
+				break;
+			case ' ':
+			case '\t':
+			case '\r':
+			case '\n':
+				break;
+			default:
+				return 0; /* bad etag list */
+			}
+			break;
+		}
+	}
+	/* no matching etag found */
 	return 0;
 }
 
@@ -20,31 +152,32 @@
 	buffer_reset(etag);
 
 	if (flags & ETAG_USE_INODE) {
-		buffer_append_off_t(etag, st->st_ino);
+		buffer_append_int(etag, st->st_ino);
 		buffer_append_string_len(etag, CONST_STR_LEN("-"));
 	}
 	
 	if (flags & ETAG_USE_SIZE) {
-		buffer_append_off_t(etag, st->st_size);
+		buffer_append_int(etag, st->st_size);
 		buffer_append_string_len(etag, CONST_STR_LEN("-"));
 	}
 	
 	if (flags & ETAG_USE_MTIME) {
-		buffer_append_long(etag, st->st_mtime);
+		buffer_append_int(etag, st->st_mtime);
 	}
 
 	return 0;
 }
 
 int etag_mutate(buffer *mut, buffer *etag) {
-	size_t i;
+	size_t i, len;
 	uint32_t h;
 
-	for (h=0, i=0; i < etag->used-1; ++i) h = (h<<5)^(h>>27)^(etag->ptr[i]);
+	len = buffer_string_length(etag);
+	for (h=0, i=0; i < len; ++i) h = (h<<5)^(h>>27)^(etag->ptr[i]);
 
 	buffer_reset(mut);
 	buffer_copy_string_len(mut, CONST_STR_LEN("\""));
-	buffer_append_off_t(mut, h);
+	buffer_append_int(mut, h);
 	buffer_append_string_len(mut, CONST_STR_LEN("\""));
 
 	return 0;
diff -u lighttpd-1.4.32/src/etag.h lighttpd-1.4.36/src/etag.h
--- lighttpd-1.4.32/src/etag.h	2010-02-01 17:28:20.000000000 -0600
+++ lighttpd-1.4.36/src/etag.h	2015-07-26 05:36:36.000000000 -0500
@@ -9,7 +9,7 @@
 
 typedef enum { ETAG_USE_INODE = 1, ETAG_USE_MTIME = 2, ETAG_USE_SIZE = 4 } etag_flags_t;
 
-int etag_is_equal(buffer *etag, const char *matches);
+int etag_is_equal(buffer *etag, const char *matches, int weak_ok);
 int etag_create(buffer *etag, struct stat *st, etag_flags_t flags);
 int etag_mutate(buffer *mut, buffer *etag);
 
diff -u lighttpd-1.4.32/src/fdevent.c lighttpd-1.4.36/src/fdevent.c
--- lighttpd-1.4.32/src/fdevent.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.36/src/fdevent.c	2015-07-26 05:36:36.000000000 -0500
@@ -23,59 +23,62 @@
 	switch(type) {
 	case FDEVENT_HANDLER_POLL:
 		if (0 != fdevent_poll_init(ev)) {
-			log_error_write(ev->srv, __FILE__, __LINE__, "S",
+			log_error_write(srv, __FILE__, __LINE__, "S",
 				"event-handler poll failed");
-
-			return NULL;
+			goto error;
 		}
 		return ev;
 	case FDEVENT_HANDLER_SELECT:
 		if (0 != fdevent_select_init(ev)) {
-			log_error_write(ev->srv, __FILE__, __LINE__, "S",
+			log_error_write(srv, __FILE__, __LINE__, "S",
 				"event-handler select failed");
-			return NULL;
+			goto error;
 		}
 		return ev;
 	case FDEVENT_HANDLER_LINUX_SYSEPOLL:
 		if (0 != fdevent_linux_sysepoll_init(ev)) {
-			log_error_write(ev->srv, __FILE__, __LINE__, "S",
+			log_error_write(srv, __FILE__, __LINE__, "S",
 				"event-handler linux-sysepoll failed, try to set server.event-handler = \"poll\" or \"select\"");
-			return NULL;
+			goto error;
 		}
 		return ev;
 	case FDEVENT_HANDLER_SOLARIS_DEVPOLL:
 		if (0 != fdevent_solaris_devpoll_init(ev)) {
-			log_error_write(ev->srv, __FILE__, __LINE__, "S",
+			log_error_write(srv, __FILE__, __LINE__, "S",
 				"event-handler solaris-devpoll failed, try to set server.event-handler = \"poll\" or \"select\"");
-			return NULL;
+			goto error;
 		}
 		return ev;
 	case FDEVENT_HANDLER_SOLARIS_PORT:
 		if (0 != fdevent_solaris_port_init(ev)) {
-			log_error_write(ev->srv, __FILE__, __LINE__, "S",
+			log_error_write(srv, __FILE__, __LINE__, "S",
 				"event-handler solaris-eventports failed, try to set server.event-handler = \"poll\" or \"select\"");
-			return NULL;
+			goto error;
 		}
 		return ev;
 	case FDEVENT_HANDLER_FREEBSD_KQUEUE:
 		if (0 != fdevent_freebsd_kqueue_init(ev)) {
-			log_error_write(ev->srv, __FILE__, __LINE__, "S",
+			log_error_write(srv, __FILE__, __LINE__, "S",
 				"event-handler freebsd-kqueue failed, try to set server.event-handler = \"poll\" or \"select\"");
-			return NULL;
+			goto error;
 		}
 		return ev;
 	case FDEVENT_HANDLER_LIBEV:
 		if (0 != fdevent_libev_init(ev)) {
-			log_error_write(ev->srv, __FILE__, __LINE__, "S",
+			log_error_write(srv, __FILE__, __LINE__, "S",
 				"event-handler libev failed, try to set server.event-handler = \"poll\" or \"select\"");
-			return NULL;
+			goto error;
 		}
 		return ev;
 	case FDEVENT_HANDLER_UNSET:
 		break;
 	}
 
-	log_error_write(ev->srv, __FILE__, __LINE__, "S",
+error:
+	free(ev->fdarray);
+	free(ev);
+
+	log_error_write(srv, __FILE__, __LINE__, "S",
 		"event-handler is unknown, try to set server.event-handler = \"poll\" or \"select\"");
 	return NULL;
 }
@@ -133,7 +136,7 @@
 	if (!ev) return 0;
 	fdn = ev->fdarray[fd];
 
-	assert(fdn->events == 0);
+	force_assert(fdn->events == 0);
 
 	fdnode_free(fdn);
 
@@ -197,11 +200,17 @@
 	return ev->fdarray[fd]->ctx;
 }
 
-int fdevent_fcntl_set(fdevents *ev, int fd) {
+void fd_close_on_exec(int fd) {
 #ifdef FD_CLOEXEC
-	/* close fd on exec (cgi) */
-	fcntl(fd, F_SETFD, FD_CLOEXEC);
+	if (fd < 0) return;
+	force_assert(-1 != fcntl(fd, F_SETFD, FD_CLOEXEC));
+#else
+	UNUSED(fd);
 #endif
+}
+
+int fdevent_fcntl_set(fdevents *ev, int fd) {
+	fd_close_on_exec(fd);
 	if ((ev) && (ev->fcntl_set)) return ev->fcntl_set(ev, fd);
 #ifdef O_NONBLOCK
 	return fcntl(fd, F_SETFL, O_NONBLOCK | O_RDWR);
diff -u lighttpd-1.4.32/src/fdevent.h lighttpd-1.4.36/src/fdevent.h
--- lighttpd-1.4.32/src/fdevent.h	2011-12-25 09:20:30.000000000 -0600
+++ lighttpd-1.4.36/src/fdevent.h	2015-07-26 05:36:36.000000000 -0500
@@ -6,7 +6,6 @@
 #endif
 
 #include "settings.h"
-#include "bitset.h"
 
 #if defined HAVE_STDINT_H
 # include <stdint.h>
@@ -191,6 +190,7 @@
 int fdevent_register(fdevents *ev, int fd, fdevent_handler handler, void *ctx);
 int fdevent_unregister(fdevents *ev, int fd);
 
+void fd_close_on_exec(int fd);
 int fdevent_fcntl_set(fdevents *ev, int fd);
 
 int fdevent_select_init(fdevents *ev);
diff -u lighttpd-1.4.32/src/fdevent_libev.c lighttpd-1.4.36/src/fdevent_libev.c
--- lighttpd-1.4.32/src/fdevent_libev.c	2011-12-25 09:19:29.000000000 -0600
+++ lighttpd-1.4.36/src/fdevent_libev.c	2015-07-26 05:36:36.000000000 -0500
@@ -67,7 +67,7 @@
 
 	if (!watcher) {
 		fdn->handler_ctx = watcher = calloc(1, sizeof(ev_io));
-		assert(watcher);
+		force_assert(watcher);
 
 		ev_io_init(watcher, io_watcher_cb, fd, ev_events);
 		watcher->data = ev;
@@ -87,19 +87,28 @@
 	UNUSED(loop);
 	UNUSED(w);
 	UNUSED(revents);
+
+	ev_timer_stop(loop, w);
 }
 
 
 static int fdevent_libev_poll(fdevents *ev, int timeout_ms) {
-	ev_timer timeout_watcher;
-
-	ev_init(&timeout_watcher, timeout_watcher_cb);
-	ev_timer_set(&timeout_watcher, ((ev_tstamp) timeout_ms)/1000.0, 0.0);
-	ev_timer_start(ev->libev_loop, &timeout_watcher);
+	union {
+		struct ev_watcher w;
+		struct ev_timer timer;
+	} timeout_watcher;
+
+	if (!timeout_ms) timeout_ms = 1;
+
+	ev_init(&timeout_watcher.w, NULL);
+	ev_set_cb(&timeout_watcher.timer, timeout_watcher_cb);
+	timeout_watcher.timer.repeat = ((ev_tstamp) timeout_ms)/1000.0;
+	force_assert(timeout_watcher.timer.repeat);
+	ev_timer_again(ev->libev_loop, &timeout_watcher.timer);
 
 	ev_loop(ev->libev_loop, EVLOOP_ONESHOT);
 
-	ev_timer_stop(ev->libev_loop, &timeout_watcher);
+	ev_timer_stop(ev->libev_loop, &timeout_watcher.timer);
 
 	return 0;
 }
diff -u lighttpd-1.4.32/src/fdevent_linux_sysepoll.c lighttpd-1.4.36/src/fdevent_linux_sysepoll.c
--- lighttpd-1.4.32/src/fdevent_linux_sysepoll.c	2011-12-25 09:19:23.000000000 -0600
+++ lighttpd-1.4.36/src/fdevent_linux_sysepoll.c	2015-07-26 05:36:36.000000000 -0500
@@ -140,14 +140,7 @@
 		return -1;
 	}
 
-	if (-1 == fcntl(ev->epoll_fd, F_SETFD, FD_CLOEXEC)) {
-		log_error_write(ev->srv, __FILE__, __LINE__, "SSS",
-			"fcntl on epoll-fd failed (", strerror(errno), "), try to set server.event-handler = \"poll\" or \"select\"");
-
-		close(ev->epoll_fd);
-
-		return -1;
-	}
+	fd_close_on_exec(ev->epoll_fd);
 
 	ev->epoll_events = malloc(ev->maxfds * sizeof(*ev->epoll_events));
 
diff -u lighttpd-1.4.32/src/fdevent_select.c lighttpd-1.4.36/src/fdevent_select.c
--- lighttpd-1.4.32/src/fdevent_select.c	2010-08-17 04:06:03.000000000 -0500
+++ lighttpd-1.4.36/src/fdevent_select.c	2015-07-26 05:36:36.000000000 -0500
@@ -38,7 +38,7 @@
 	UNUSED(fde_ndx);
 
 	/* we should be protected by max-fds, but you never know */
-	assert(fd < ((int)FD_SETSIZE));
+	force_assert(fd < ((int)FD_SETSIZE));
 
 	if (events & FDEVENT_IN) {
 		FD_SET(fd, &(ev->select_set_read));
diff -u lighttpd-1.4.32/src/fdevent_solaris_devpoll.c lighttpd-1.4.36/src/fdevent_solaris_devpoll.c
--- lighttpd-1.4.32/src/fdevent_solaris_devpoll.c	2011-12-25 09:20:19.000000000 -0600
+++ lighttpd-1.4.36/src/fdevent_solaris_devpoll.c	2015-07-26 05:36:36.000000000 -0500
@@ -121,14 +121,7 @@
 		return -1;
 	}
 
-	if (fcntl(ev->devpoll_fd, F_SETFD, FD_CLOEXEC) < 0) {
-		log_error_write(ev->srv, __FILE__, __LINE__, "SSS",
-			"fcntl /dev/poll fd failed (", strerror(errno), "), try to set server.event-handler = \"poll\" or \"select\"");
-
-		close(ev->devpoll_fd);
-
-		return -1;
-	}
+	fd_close_on_exec(ev->devpoll_fd);
 	return 0;
 }
 int fdevent_solaris_devpoll_init(fdevents *ev) {
diff -u lighttpd-1.4.32/src/http_auth.c lighttpd-1.4.36/src/http_auth.c
--- lighttpd-1.4.32/src/http_auth.c	2012-05-17 04:29:24.000000000 -0500
+++ lighttpd-1.4.36/src/http_auth.c	2015-07-26 05:36:36.000000000 -0500
@@ -29,19 +29,17 @@
 
 #include "md5.h"
 
+#ifdef USE_OPENSSL
+#include <openssl/sha.h>
+#endif
+
 #define HASHLEN 16
 #define HASHHEXLEN 32
 typedef unsigned char HASH[HASHLEN];
 typedef char HASHHEX[HASHHEXLEN+1];
 
 static void CvtHex(const HASH Bin, char Hex[33]) {
-	unsigned short i;
-
-	for (i = 0; i < 16; i++) {
-		Hex[i*2] = int2hex((Bin[i] >> 4) & 0xf);
-		Hex[i*2+1] = int2hex(Bin[i] & 0xf);
-	}
-	Hex[32] = '\0';
+	li_tohex(Hex, (const char*) Bin, 16);
 }
 
 /**
@@ -87,60 +85,71 @@
 
 static unsigned char * base64_decode(buffer *out, const char *in) {
 	unsigned char *result;
-	int ch, j = 0, k;
+	unsigned int j = 0; /* current output character (position) that is decoded. can contain partial result */
+	unsigned int group = 0; /* how many base64 digits in the current group were decoded already. each group has up to 4 digits */
 	size_t i;
 
 	size_t in_len = strlen(in);
 
-	buffer_prepare_copy(out, in_len);
-
-	result = (unsigned char *)out->ptr;
+	result = (unsigned char *) buffer_string_prepare_copy(out, in_len);
 
-	ch = in[0];
 	/* run through the whole string, converting as we go */
 	for (i = 0; i < in_len; i++) {
-		ch = (unsigned char) in[i];
+		unsigned char c = (unsigned char) in[i];
+		short ch;
 
-		if (ch == '\0') break;
+		if (c == '\0') break;
 
-		if (ch == base64_pad) break;
+		if (c == base64_pad) {
+			/* pad character can only come after 2 base64 digits in a group */
+			if (group < 2) return NULL;
+			break;
+		}
 
-		ch = base64_reverse_table[ch];
-		if (ch < 0) continue;
+		ch = base64_reverse_table[c];
+		if (ch < 0) continue; /* skip invalid characters */
 
-		switch(i % 4) {
+		switch(group) {
 		case 0:
 			result[j] = ch << 2;
+			group = 1;
 			break;
 		case 1:
 			result[j++] |= ch >> 4;
 			result[j] = (ch & 0x0f) << 4;
+			group = 2;
 			break;
 		case 2:
 			result[j++] |= ch >>2;
 			result[j] = (ch & 0x03) << 6;
+			group = 3;
 			break;
 		case 3:
 			result[j++] |= ch;
+			group = 0;
 			break;
 		}
 	}
-	k = j;
-	/* mop things up if we ended on a boundary */
-	if (ch == base64_pad) {
-		switch(i % 4) {
-		case 0:
-		case 1:
-			return NULL;
-		case 2:
-			k++;
-		case 3:
-			result[k++] = 0;
-		}
+
+	switch(group) {
+	case 0:
+		/* ended on boundary */
+		break;
+	case 1:
+		/* need at least 2 base64 digits per group */
+		return NULL;
+	case 2:
+		/* have 2 base64 digits in last group => one real octect, two zeroes padded */
+	case 3:
+		/* have 3 base64 digits in last group => two real octects, one zero padded */
+
+		/* for both cases the current index already is on the first zero padded octet
+		 * - check it really is zero (overlapping bits) */
+		if (0 != result[j]) return NULL;
+		break;
 	}
-	result[k] = '\0';
 
-	out->used = k;
+	buffer_commit(out, j);
 
 	return result;
 }
@@ -148,13 +157,13 @@
 static int http_auth_get_password(server *srv, mod_auth_plugin_data *p, buffer *username, buffer *realm, buffer *password) {
 	int ret = -1;
 
-	if (!username->used|| !realm->used) return -1;
+	if (buffer_is_empty(username) || buffer_is_empty(realm)) return -1;
 
 	if (p->conf.auth_backend == AUTH_BACKEND_HTDIGEST) {
 		stream f;
 		char * f_line;
 
-		if (buffer_is_empty(p->conf.auth_htdigest_userfile)) return -1;
+		if (buffer_string_is_empty(p->conf.auth_htdigest_userfile)) return -1;
 
 		if (0 != stream_open(&f, p->conf.auth_htdigest_userfile)) {
 			log_error_write(srv, __FILE__, __LINE__, "sbss", "opening digest-userfile", p->conf.auth_htdigest_userfile, "failed:", strerror(errno));
@@ -208,8 +217,8 @@
 				pwd_len = f.size - (f_pwd - f.start);
 			}
 
-			if (username->used - 1 == u_len &&
-			    (realm->used - 1 == r_len) &&
+			if (buffer_string_length(username) == u_len &&
+			    (buffer_string_length(realm) == r_len) &&
 			    (0 == strncmp(username->ptr, f_user, u_len)) &&
 			    (0 == strncmp(realm->ptr, f_realm, r_len))) {
 				/* found */
@@ -235,7 +244,7 @@
 
 		auth_fn = (p->conf.auth_backend == AUTH_BACKEND_HTPASSWD) ? p->conf.auth_htpasswd_userfile : p->conf.auth_plain_userfile;
 
-		if (buffer_is_empty(auth_fn)) return -1;
+		if (buffer_string_is_empty(auth_fn)) return -1;
 
 		if (0 != stream_open(&f, auth_fn)) {
 			log_error_write(srv, __FILE__, __LINE__, "sbss",
@@ -278,7 +287,7 @@
 				pwd_len = f.size - (f_pwd - f.start);
 			}
 
-			if (username->used - 1 == u_len &&
+			if (buffer_string_length(username) == u_len &&
 			    (0 == strncmp(username->ptr, f_user, u_len))) {
 				/* found */
 
@@ -304,32 +313,14 @@
 	return ret;
 }
 
-static int http_auth_match_rules(server *srv, mod_auth_plugin_data *p, const char *url, const char *username, const char *group, const char *host) {
+int http_auth_match_rules(server *srv, array *req, const char *username, const char *group, const char *host) {
 	const char *r = NULL, *rules = NULL;
-	size_t i;
 	int username_len;
 	data_string *require;
-	array *req;
 
 	UNUSED(group);
 	UNUSED(host);
 
-	/* check what has to be match to fullfil the request */
-	/* search auth-directives for path */
-	for (i = 0; i < p->conf.auth_require->used; i++) {
-		if (p->conf.auth_require->data[i]->key->used == 0) continue;
-
-		if (0 == strncmp(url, p->conf.auth_require->data[i]->key->ptr, p->conf.auth_require->data[i]->key->used - 1)) {
-			break;
-		}
-	}
-
-	if (i == p->conf.auth_require->used) {
-		return -1;
-	}
-
-	req = ((data_array *)(p->conf.auth_require->data[i]))->value;
-
 	require = (data_string *)array_get_element(req, "require");
 
 	/* if we get here, the user we got a authed user */
@@ -599,6 +590,35 @@
     apr_cpystrn(result, passwd, nbytes - 1);
 }
 
+#ifdef USE_OPENSSL
+static void apr_sha_encode(const char *pw, char *result, size_t nbytes) {
+	static const unsigned char base64_data[65] =
+		"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+	unsigned char digest[21]; /* multiple of 3 for base64 encoding */
+	int i;
+
+	memset(result, 0, nbytes);
+
+	/* need 5 bytes for "{SHA}", 28 for base64 (3 bytes -> 4 bytes) of SHA1 (20 bytes), 1 terminating */
+	if (nbytes < 5 + 28 + 1) return;
+
+	SHA1((const unsigned char*) pw, strlen(pw), digest);
+	digest[20] = 0;
+
+	strcpy(result, "{SHA}");
+	result = result + 5;
+	for (i = 0; i < 21; i += 3) {
+		unsigned int v = (digest[i] << 16) | (digest[i+1] << 8) | digest[i+2];
+		result[3] = base64_data[v & 0x3f]; v >>= 6;
+		result[2] = base64_data[v & 0x3f]; v >>= 6;
+		result[1] = base64_data[v & 0x3f]; v >>= 6;
+		result[0] = base64_data[v & 0x3f];
+		result += 4;
+	}
+	result[-1] = '='; /* last digest character was already end of string, pad it */
+	*result = '\0';
+}
+#endif
 
 /**
  *
@@ -623,10 +643,10 @@
 		char a1[256];
 
 		li_MD5_Init(&Md5Ctx);
-		li_MD5_Update(&Md5Ctx, (unsigned char *)username->ptr, username->used - 1);
-		li_MD5_Update(&Md5Ctx, (unsigned char *)":", 1);
-		li_MD5_Update(&Md5Ctx, (unsigned char *)realm->ptr, realm->used - 1);
-		li_MD5_Update(&Md5Ctx, (unsigned char *)":", 1);
+		li_MD5_Update(&Md5Ctx, CONST_BUF_LEN(username));
+		li_MD5_Update(&Md5Ctx, CONST_STR_LEN(":"));
+		li_MD5_Update(&Md5Ctx, CONST_BUF_LEN(realm));
+		li_MD5_Update(&Md5Ctx, CONST_STR_LEN(":"));
 		li_MD5_Update(&Md5Ctx, (unsigned char *)pw, strlen(pw));
 		li_MD5_Final(HA1, &Md5Ctx);
 
@@ -643,58 +663,38 @@
 			 */
 			apr_md5_encode(pw, password->ptr, sample, sizeof(sample));
 			return (strcmp(sample, password->ptr) == 0) ? 0 : 1;
+#ifdef USE_OPENSSL
+		} else if (0 == strncmp(password->ptr, "{SHA}", 5)) {
+			apr_sha_encode(pw, sample, sizeof(sample));
+			return (strcmp(sample, password->ptr) == 0) ? 0 : 1;
+#endif
 		} else {
-#ifdef HAVE_CRYPT
-		char salt[32];
-		char *crypted;
-		size_t salt_len = 0;
-		/*
-		 * htpasswd format
-		 *
-		 * user:crypted password
-		 */
-
-		/*
-		 *  Algorithm      Salt
-		 *  CRYPT_STD_DES   2-character (Default)
-		 *  CRYPT_EXT_DES   9-character
-		 *  CRYPT_MD5       12-character beginning with $1$
-		 *  CRYPT_BLOWFISH  16-character beginning with $2$
-		 */
-
-		if (password->used < 13 + 1) {
-			return -1;
-		}
-
-		if (password->used == 13 + 1) {
-			/* a simple DES password is 2 + 11 characters */
-			salt_len = 2;
-		} else if (password->ptr[0] == '$' && password->ptr[2] == '$') {
-			char *dollar = NULL;
+#if defined(HAVE_CRYPT_R) || defined(HAVE_CRYPT)
+			char *crypted;
+#if defined(HAVE_CRYPT_R)
+			struct crypt_data crypt_tmp_data;
+			crypt_tmp_data.initialized = 0;
+#endif
 
-			if (NULL == (dollar = strchr(password->ptr + 3, '$'))) {
+			/* a simple DES password is 2 + 11 characters. everything else should be longer. */
+			if (buffer_string_length(password) < 13) {
 				return -1;
 			}
 
-			salt_len = dollar - password->ptr;
-		}
-
-		if (salt_len > sizeof(salt) - 1) {
-			return -1;
-		}
-
-		strncpy(salt, password->ptr, salt_len);
-
-		salt[salt_len] = '\0';
-
-		crypted = crypt(pw, salt);
-
-		if (0 == strcmp(password->ptr, crypted)) {
-			return 0;
-		}
+#if defined(HAVE_CRYPT_R)
+			if (0 == (crypted = crypt_r(pw, password->ptr, &crypt_tmp_data))) {
+#else
+			if (0 == (crypted = crypt(pw, password->ptr))) {
+#endif
+				/* crypt failed. */
+				return -1;
+			}
 
+			if (0 == strcmp(password->ptr, crypted)) {
+				return 0;
+			}
 #endif
-	}
+		}
 	} else if (p->conf.auth_backend == AUTH_BACKEND_PLAIN) {
 		if (0 == strcmp(password->ptr, pw)) {
 			return 0;
@@ -706,7 +706,7 @@
 		char *dn;
 		int ret;
 		char *attrs[] = { LDAP_NO_ATTRS, NULL };
-		size_t i;
+		size_t i, len;
 
 		/* for now we stay synchronous */
 
@@ -725,7 +725,8 @@
 		 * a unpleasant way
 		 */
 
-		for (i = 0; i < username->used - 1; i++) {
+		len = buffer_string_length(username);
+		for (i = 0; i < len; i++) {
 			char c = username->ptr[i];
 
 			if (!isalpha(c) &&
@@ -747,7 +748,7 @@
 			return -1;
 
 		/* build filter */
-		buffer_copy_string_buffer(p->ldap_filter, p->conf.ldap_filter_pre);
+		buffer_copy_buffer(p->ldap_filter, p->conf.ldap_filter_pre);
 		buffer_append_string_buffer(p->ldap_filter, username);
 		buffer_append_string_buffer(p->ldap_filter, p->conf.ldap_filter_post);
 
@@ -763,8 +764,9 @@
 				if (auth_ldap_init(srv, p->anon_conf) != HANDLER_GO_ON)
 					return -1;
 
-				if (p->anon_conf->ldap == NULL ||
-				    LDAP_SUCCESS != (ret = ldap_search_s(p->anon_conf->ldap, p->conf.auth_ldap_basedn->ptr, LDAP_SCOPE_SUBTREE, p->ldap_filter->ptr, attrs, 0, &lm))) {
+				if (NULL == p->anon_conf->ldap) return -1;
+
+				if (LDAP_SUCCESS != (ret = ldap_search_s(p->anon_conf->ldap, p->conf.auth_ldap_basedn->ptr, LDAP_SCOPE_SUBTREE, p->ldap_filter->ptr, attrs, 0, &lm))) {
 					log_error_write(srv, __FILE__, __LINE__, "sssb",
 							"ldap:", ldap_err2string(ret), "filter:", p->ldap_filter);
 					return -1;
@@ -836,7 +838,7 @@
 	return -1;
 }
 
-int http_auth_basic_check(server *srv, connection *con, mod_auth_plugin_data *p, array *req, buffer *url, const char *realm_str) {
+int http_auth_basic_check(server *srv, connection *con, mod_auth_plugin_data *p, array *req, const char *realm_str) {
 	buffer *username, *password;
 	char *pw;
 
@@ -861,9 +863,8 @@
 		return 0;
 	}
 
-	*pw++ = '\0';
-
-	username->used = pw - username->ptr;
+	buffer_string_set_length(username, pw - username->ptr);
+	pw++;
 
 	password = buffer_init();
 	/* copy password to r1 */
@@ -891,7 +892,7 @@
 	}
 
 	/* value is our allow-rules */
-	if (http_auth_match_rules(srv, p, url->ptr, username->ptr, NULL, NULL)) {
+	if (http_auth_match_rules(srv, req, username->ptr, NULL, NULL)) {
 		buffer_free(username);
 		buffer_free(password);
 
@@ -901,7 +902,7 @@
 	}
 
 	/* remember the username */
-	buffer_copy_string_buffer(p->auth_user, username);
+	buffer_copy_buffer(p->auth_user, username);
 
 	buffer_free(username);
 	buffer_free(password);
@@ -915,7 +916,8 @@
 	char **ptr;
 } digest_kv;
 
-int http_auth_digest_check(server *srv, connection *con, mod_auth_plugin_data *p, array *req, buffer *url, const char *realm_str) {
+/* return values: -1: error/bad request, 0: failed, 1: success */
+int http_auth_digest_check(server *srv, connection *con, mod_auth_plugin_data *p, array *req, const char *realm_str) {
 	char a1[256];
 	char a2[256];
 
@@ -1052,6 +1054,14 @@
 		return -1;
 	}
 
+	if (qop && strcasecmp(qop, "auth-int") == 0) {
+		log_error_write(srv, __FILE__, __LINE__, "s",
+				"digest: qop=auth-int not supported");
+
+		buffer_free(b);
+		return -1;
+	}
+
 	m = get_http_method_name(con->request.http_method);
 
 	/* password-string == HA1 */
@@ -1073,10 +1083,10 @@
 		/* generate password from plain-text */
 		li_MD5_Init(&Md5Ctx);
 		li_MD5_Update(&Md5Ctx, (unsigned char *)username, strlen(username));
-		li_MD5_Update(&Md5Ctx, (unsigned char *)":", 1);
+		li_MD5_Update(&Md5Ctx, CONST_STR_LEN(":"));
 		li_MD5_Update(&Md5Ctx, (unsigned char *)realm, strlen(realm));
-		li_MD5_Update(&Md5Ctx, (unsigned char *)":", 1);
-		li_MD5_Update(&Md5Ctx, (unsigned char *)password->ptr, password->used - 1);
+		li_MD5_Update(&Md5Ctx, CONST_STR_LEN(":"));
+		li_MD5_Update(&Md5Ctx, CONST_BUF_LEN(password));
 		li_MD5_Final(HA1, &Md5Ctx);
 	} else if (p->conf.auth_backend == AUTH_BACKEND_HTDIGEST) {
 		/* HA1 */
@@ -1098,9 +1108,9 @@
 		/* Errata ID 1649: http://www.rfc-editor.org/errata_search.php?rfc=2617 */
 		CvtHex(HA1, a1);
 		li_MD5_Update(&Md5Ctx, (unsigned char *)a1, 32);
-		li_MD5_Update(&Md5Ctx, (unsigned char *)":", 1);
+		li_MD5_Update(&Md5Ctx, CONST_STR_LEN(":"));
 		li_MD5_Update(&Md5Ctx, (unsigned char *)nonce, strlen(nonce));
-		li_MD5_Update(&Md5Ctx, (unsigned char *)":", 1);
+		li_MD5_Update(&Md5Ctx, CONST_STR_LEN(":"));
 		li_MD5_Update(&Md5Ctx, (unsigned char *)cnonce, strlen(cnonce));
 		li_MD5_Final(HA1, &Md5Ctx);
 	}
@@ -1110,28 +1120,31 @@
 	/* calculate H(A2) */
 	li_MD5_Init(&Md5Ctx);
 	li_MD5_Update(&Md5Ctx, (unsigned char *)m, strlen(m));
-	li_MD5_Update(&Md5Ctx, (unsigned char *)":", 1);
+	li_MD5_Update(&Md5Ctx, CONST_STR_LEN(":"));
 	li_MD5_Update(&Md5Ctx, (unsigned char *)uri, strlen(uri));
+	/* qop=auth-int not supported, already checked above */
+/*
 	if (qop && strcasecmp(qop, "auth-int") == 0) {
-		li_MD5_Update(&Md5Ctx, (unsigned char *)":", 1);
-		li_MD5_Update(&Md5Ctx, (unsigned char *)"", HASHHEXLEN);
+		li_MD5_Update(&Md5Ctx, CONST_STR_LEN(":"));
+		li_MD5_Update(&Md5Ctx, (unsigned char *) [body checksum], HASHHEXLEN);
 	}
+*/
 	li_MD5_Final(HA2, &Md5Ctx);
 	CvtHex(HA2, HA2Hex);
 
 	/* calculate response */
 	li_MD5_Init(&Md5Ctx);
 	li_MD5_Update(&Md5Ctx, (unsigned char *)a1, HASHHEXLEN);
-	li_MD5_Update(&Md5Ctx, (unsigned char *)":", 1);
+	li_MD5_Update(&Md5Ctx, CONST_STR_LEN(":"));
 	li_MD5_Update(&Md5Ctx, (unsigned char *)nonce, strlen(nonce));
-	li_MD5_Update(&Md5Ctx, (unsigned char *)":", 1);
+	li_MD5_Update(&Md5Ctx, CONST_STR_LEN(":"));
 	if (qop && *qop) {
 		li_MD5_Update(&Md5Ctx, (unsigned char *)nc, strlen(nc));
-		li_MD5_Update(&Md5Ctx, (unsigned char *)":", 1);
+		li_MD5_Update(&Md5Ctx, CONST_STR_LEN(":"));
 		li_MD5_Update(&Md5Ctx, (unsigned char *)cnonce, strlen(cnonce));
-		li_MD5_Update(&Md5Ctx, (unsigned char *)":", 1);
+		li_MD5_Update(&Md5Ctx, CONST_STR_LEN(":"));
 		li_MD5_Update(&Md5Ctx, (unsigned char *)qop, strlen(qop));
-		li_MD5_Update(&Md5Ctx, (unsigned char *)":", 1);
+		li_MD5_Update(&Md5Ctx, CONST_STR_LEN(":"));
 	};
 	li_MD5_Update(&Md5Ctx, (unsigned char *)HA2Hex, HASHHEXLEN);
 	li_MD5_Final(RespHash, &Md5Ctx);
@@ -1153,7 +1166,7 @@
 	}
 
 	/* value is our allow-rules */
-	if (http_auth_match_rules(srv, p, url->ptr, username, NULL, NULL)) {
+	if (http_auth_match_rules(srv, req, username, NULL, NULL)) {
 		buffer_free(b);
 
 		log_error_write(srv, __FILE__, __LINE__, "s",
@@ -1178,20 +1191,20 @@
 int http_auth_digest_generate_nonce(server *srv, mod_auth_plugin_data *p, buffer *fn, char out[33]) {
 	HASH h;
 	li_MD5_CTX Md5Ctx;
-	char hh[32];
+	char hh[LI_ITOSTRING_LENGTH];
 
 	UNUSED(p);
 
 	/* generate shared-secret */
 	li_MD5_Init(&Md5Ctx);
-	li_MD5_Update(&Md5Ctx, (unsigned char *)fn->ptr, fn->used - 1);
-	li_MD5_Update(&Md5Ctx, (unsigned char *)"+", 1);
+	li_MD5_Update(&Md5Ctx, CONST_BUF_LEN(fn));
+	li_MD5_Update(&Md5Ctx, CONST_STR_LEN("+"));
 
 	/* we assume sizeof(time_t) == 4 here, but if not it ain't a problem at all */
-	LI_ltostr(hh, srv->cur_ts);
+	li_itostr(hh, srv->cur_ts);
 	li_MD5_Update(&Md5Ctx, (unsigned char *)hh, strlen(hh));
 	li_MD5_Update(&Md5Ctx, (unsigned char *)srv->entropy, sizeof(srv->entropy));
-	LI_ltostr(hh, rand());
+	li_itostr(hh, rand());
 	li_MD5_Update(&Md5Ctx, (unsigned char *)hh, strlen(hh));
 
 	li_MD5_Final(h, &Md5Ctx);
diff -u lighttpd-1.4.32/src/http_auth.h lighttpd-1.4.36/src/http_auth.h
--- lighttpd-1.4.32/src/http_auth.h	2010-02-01 17:28:20.000000000 -0600
+++ lighttpd-1.4.36/src/http_auth.h	2015-07-26 05:36:36.000000000 -0500
@@ -66,8 +66,9 @@
 	mod_auth_plugin_config conf, *anon_conf; /* this is only used as long as no handler_ctx is setup */
 } mod_auth_plugin_data;
 
-int http_auth_basic_check(server *srv, connection *con, mod_auth_plugin_data *p, array *req, buffer *url, const char *realm_str);
-int http_auth_digest_check(server *srv, connection *con, mod_auth_plugin_data *p, array *req, buffer *url, const char *realm_str);
+int http_auth_basic_check(server *srv, connection *con, mod_auth_plugin_data *p, array *req, const char *realm_str);
+int http_auth_digest_check(server *srv, connection *con, mod_auth_plugin_data *p, array *req, const char *realm_str);
 int http_auth_digest_generate_nonce(server *srv, mod_auth_plugin_data *p, buffer *fn, char hh[33]);
+int http_auth_match_rules(server *srv, array *req, const char *username, const char *group, const char *host);
 
 #endif
diff -u lighttpd-1.4.32/src/http_chunk.c lighttpd-1.4.36/src/http_chunk.c
--- lighttpd-1.4.32/src/http_chunk.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/http_chunk.c	2015-07-26 05:36:36.000000000 -0500
@@ -20,113 +20,87 @@
 #include <errno.h>
 #include <string.h>
 
-static int http_chunk_append_len(server *srv, connection *con, size_t len) {
-	size_t i, olen = len, j;
+static void http_chunk_append_len(server *srv, connection *con, size_t len) {
 	buffer *b;
 
-	b = srv->tmp_chunk_len;
+	force_assert(NULL != srv);
 
-	if (len == 0) {
-		buffer_copy_string_len(b, CONST_STR_LEN("0"));
-	} else {
-		for (i = 0; i < 8 && len; i++) {
-			len >>= 4;
-		}
-
-		/* i is the number of hex digits we have */
-		buffer_prepare_copy(b, i + 1);
-
-		for (j = i-1, len = olen; j+1 > 0; j--) {
-			b->ptr[j] = (len & 0xf) + (((len & 0xf) <= 9) ? '0' : 'a' - 10);
-			len >>= 4;
-		}
-		b->used = i;
-		b->ptr[b->used++] = '\0';
-	}
+	b = srv->tmp_chunk_len;
 
+	buffer_string_set_length(b, 0);
+	buffer_append_uint_hex(b, len);
 	buffer_append_string_len(b, CONST_STR_LEN("\r\n"));
-	chunkqueue_append_buffer(con->write_queue, b);
 
-	return 0;
+	chunkqueue_append_buffer(con->write_queue, b);
 }
 
 
-int http_chunk_append_file(server *srv, connection *con, buffer *fn, off_t offset, off_t len) {
+void http_chunk_append_file(server *srv, connection *con, buffer *fn, off_t offset, off_t len) {
 	chunkqueue *cq;
 
-	if (!con) return -1;
+	force_assert(NULL != con);
+	if (0 == len) return;
 
 	cq = con->write_queue;
 
+
 	if (con->response.transfer_encoding & HTTP_TRANSFER_ENCODING_CHUNKED) {
 		http_chunk_append_len(srv, con, len);
 	}
 
 	chunkqueue_append_file(cq, fn, offset, len);
 
-	if (con->response.transfer_encoding & HTTP_TRANSFER_ENCODING_CHUNKED && len > 0) {
-		chunkqueue_append_mem(cq, "\r\n", 2 + 1);
+	if (con->response.transfer_encoding & HTTP_TRANSFER_ENCODING_CHUNKED) {
+		chunkqueue_append_mem(cq, CONST_STR_LEN("\r\n"));
 	}
-
-	return 0;
 }
 
-int http_chunk_append_buffer(server *srv, connection *con, buffer *mem) {
+void http_chunk_append_buffer(server *srv, connection *con, buffer *mem) {
 	chunkqueue *cq;
 
-	if (!con) return -1;
+	force_assert(NULL != con);
+
+	if (buffer_string_is_empty(mem)) return;
 
 	cq = con->write_queue;
 
 	if (con->response.transfer_encoding & HTTP_TRANSFER_ENCODING_CHUNKED) {
-		http_chunk_append_len(srv, con, mem->used - 1);
+		http_chunk_append_len(srv, con, buffer_string_length(mem));
 	}
 
 	chunkqueue_append_buffer(cq, mem);
 
-	if (con->response.transfer_encoding & HTTP_TRANSFER_ENCODING_CHUNKED && mem->used > 0) {
-		chunkqueue_append_mem(cq, "\r\n", 2 + 1);
+	if (con->response.transfer_encoding & HTTP_TRANSFER_ENCODING_CHUNKED) {
+		chunkqueue_append_mem(cq, CONST_STR_LEN("\r\n"));
 	}
-
-	return 0;
 }
 
-int http_chunk_append_mem(server *srv, connection *con, const char * mem, size_t len) {
+void http_chunk_append_mem(server *srv, connection *con, const char * mem, size_t len) {
 	chunkqueue *cq;
 
-	if (!con) return -1;
+	force_assert(NULL != con);
+	force_assert(NULL != mem || 0 == len);
 
-	cq = con->write_queue;
+	if (NULL == mem || 0 == len) return;
 
-	if (len == 0) {
-		if (con->response.transfer_encoding & HTTP_TRANSFER_ENCODING_CHUNKED) {
-			chunkqueue_append_mem(cq, "0\r\n\r\n", 5 + 1);
-		} else {
-			chunkqueue_append_mem(cq, "", 1);
-		}
-		return 0;
-	}
+	cq = con->write_queue;
 
 	if (con->response.transfer_encoding & HTTP_TRANSFER_ENCODING_CHUNKED) {
-		http_chunk_append_len(srv, con, len - 1);
+		http_chunk_append_len(srv, con, len);
 	}
 
 	chunkqueue_append_mem(cq, mem, len);
 
 	if (con->response.transfer_encoding & HTTP_TRANSFER_ENCODING_CHUNKED) {
-		chunkqueue_append_mem(cq, "\r\n", 2 + 1);
+		chunkqueue_append_mem(cq, CONST_STR_LEN("\r\n"));
 	}
-
-	return 0;
 }
 
+void http_chunk_close(server *srv, connection *con) {
+	UNUSED(srv);
+	force_assert(NULL != con);
 
-off_t http_chunkqueue_length(server *srv, connection *con) {
-	if (!con) {
-		log_error_write(srv, __FILE__, __LINE__, "s", "connection is NULL!!");
-
-		return 0;
+	if (con->response.transfer_encoding & HTTP_TRANSFER_ENCODING_CHUNKED) {
+		chunkqueue_append_mem(con->write_queue, CONST_STR_LEN("0\r\n\r\n"));
 	}
-
-	return chunkqueue_length(con->write_queue);
 }
diff -u lighttpd-1.4.32/src/http_chunk.h lighttpd-1.4.36/src/http_chunk.h
--- lighttpd-1.4.32/src/http_chunk.h	2009-09-01 13:34:54.000000000 -0500
+++ lighttpd-1.4.36/src/http_chunk.h	2015-07-26 05:36:36.000000000 -0500
@@ -4,9 +4,9 @@
 #include "server.h"
 #include <sys/types.h>
 
-int http_chunk_append_mem(server *srv, connection *con, const char * mem, size_t len);
-int http_chunk_append_buffer(server *srv, connection *con, buffer *mem);
-int http_chunk_append_file(server *srv, connection *con, buffer *fn, off_t offset, off_t len);
-off_t http_chunkqueue_length(server *srv, connection *con);
+void http_chunk_append_mem(server *srv, connection *con, const char * mem, size_t len); /* copies memory */
+void http_chunk_append_buffer(server *srv, connection *con, buffer *mem); /* may reset "mem" */
+void http_chunk_append_file(server *srv, connection *con, buffer *fn, off_t offset, off_t len); /* copies "fn" */
+void http_chunk_close(server *srv, connection *con);
 
 #endif
diff -u lighttpd-1.4.32/src/http-header-glue.c lighttpd-1.4.36/src/http-header-glue.c
--- lighttpd-1.4.32/src/http-header-glue.c	2012-11-17 11:32:01.000000000 -0600
+++ lighttpd-1.4.36/src/http-header-glue.c	2015-07-26 05:36:36.000000000 -0500
@@ -123,12 +123,9 @@
 
 	o = buffer_init();
 
-	if (con->conf.is_ssl) {
-		buffer_copy_string_len(o, CONST_STR_LEN("https://"));
-	} else {
-		buffer_copy_string_len(o, CONST_STR_LEN("http://"));
-	}
-	if (con->uri.authority->used) {
+	buffer_copy_buffer(o, con->uri.scheme);
+	buffer_append_string_len(o, CONST_STR_LEN("://"));
+	if (!buffer_is_empty(con->uri.authority)) {
 		buffer_append_string_buffer(o, con->uri.authority);
 	} else {
 		/* get the name of the currently connected socket */
@@ -193,15 +190,20 @@
 			return -1;
 		}
 
-		if (!((con->conf.is_ssl == 0 && srv->srvconf.port == 80) ||
-		      (con->conf.is_ssl == 1 && srv->srvconf.port == 443))) {
-			buffer_append_string_len(o, CONST_STR_LEN(":"));
-			buffer_append_long(o, srv->srvconf.port);
+		{
+			unsigned short default_port = 80;
+			if (buffer_is_equal_caseless_string(con->uri.scheme, CONST_STR_LEN("https"))) {
+				default_port = 443;
+			}
+			if (default_port != srv->srvconf.port) {
+				buffer_append_string_len(o, CONST_STR_LEN(":"));
+				buffer_append_int(o, srv->srvconf.port);
+			}
 		}
 	}
 	buffer_append_string_buffer(o, con->uri.path);
 	buffer_append_string_len(o, CONST_STR_LEN("/"));
-	if (!buffer_is_empty(con->uri.query)) {
+	if (!buffer_string_is_empty(con->uri.query)) {
 		buffer_append_string_len(o, CONST_STR_LEN("?"));
 		buffer_append_string_buffer(o, con->uri.query);
 	}
@@ -233,18 +235,20 @@
 	}
 
 	srv->mtime_cache[i].mtime = last_mod;
-	buffer_prepare_copy(srv->mtime_cache[i].str, 1024);
+	buffer_string_prepare_copy(srv->mtime_cache[i].str, 1023);
 	tm = gmtime(&(srv->mtime_cache[i].mtime));
-	srv->mtime_cache[i].str->used = strftime(srv->mtime_cache[i].str->ptr,
-						 srv->mtime_cache[i].str->size - 1,
-						 "%a, %d %b %Y %H:%M:%S GMT", tm);
-	srv->mtime_cache[i].str->used++;
+	buffer_append_strftime(srv->mtime_cache[i].str, "%a, %d %b %Y %H:%M:%S GMT", tm);
 
 	return srv->mtime_cache[i].str;
 }
 
 
 int http_response_handle_cachable(server *srv, connection *con, buffer *mtime) {
+	int head_or_get =
+		(  HTTP_METHOD_GET  == con->request.http_method
+		|| HTTP_METHOD_HEAD == con->request.http_method);
+	UNUSED(srv);
+
 	/*
 	 * 14.26 If-None-Match
 	 *    [...]
@@ -255,74 +259,22 @@
 	 *    return a 304 (Not Modified) response.
 	 */
 
-	/* last-modified handling */
 	if (con->request.http_if_none_match) {
-		if (etag_is_equal(con->physical.etag, con->request.http_if_none_match)) {
-			if (con->request.http_method == HTTP_METHOD_GET ||
-			    con->request.http_method == HTTP_METHOD_HEAD) {
-
-				/* check if etag + last-modified */
-				if (con->request.http_if_modified_since) {
-					size_t used_len;
-					char *semicolon;
-
-					if (NULL == (semicolon = strchr(con->request.http_if_modified_since, ';'))) {
-						used_len = strlen(con->request.http_if_modified_since);
-					} else {
-						used_len = semicolon - con->request.http_if_modified_since;
-					}
-
-					if (0 == strncmp(con->request.http_if_modified_since, mtime->ptr, used_len)) {
-						if ('\0' == mtime->ptr[used_len]) con->http_status = 304;
-						return HANDLER_FINISHED;
-					} else {
-						char buf[sizeof("Sat, 23 Jul 2005 21:20:01 GMT")];
-						time_t t_header, t_file;
-						struct tm tm;
-
-						/* check if we can safely copy the string */
-						if (used_len >= sizeof(buf)) {
-							log_error_write(srv, __FILE__, __LINE__, "ssdd",
-									"DEBUG: Last-Modified check failed as the received timestamp was too long:",
-									con->request.http_if_modified_since, used_len, sizeof(buf) - 1);
-
-							con->http_status = 412;
-							con->mode = DIRECT;
-							return HANDLER_FINISHED;
-						}
-
-
-						strncpy(buf, con->request.http_if_modified_since, used_len);
-						buf[used_len] = '\0';
-
-						if (NULL == strptime(buf, "%a, %d %b %Y %H:%M:%S GMT", &tm)) {
-							con->http_status = 412;
-							con->mode = DIRECT;
-							return HANDLER_FINISHED;
-						}
-						tm.tm_isdst = 0;
-						t_header = mktime(&tm);
-
-						strptime(mtime->ptr, "%a, %d %b %Y %H:%M:%S GMT", &tm);
-						tm.tm_isdst = 0;
-						t_file = mktime(&tm);
-
-						if (t_file > t_header) return HANDLER_GO_ON;
-
-						con->http_status = 304;
-						return HANDLER_FINISHED;
-					}
-				} else {
-					con->http_status = 304;
-					return HANDLER_FINISHED;
-				}
+		/* use strong etag checking for now: weak comparison must not be used
+		 * for ranged requests
+		 */
+		if (etag_is_equal(con->physical.etag, con->request.http_if_none_match, 0)) {
+			if (head_or_get) {
+				con->http_status = 304;
+				return HANDLER_FINISHED;
 			} else {
 				con->http_status = 412;
 				con->mode = DIRECT;
 				return HANDLER_FINISHED;
 			}
 		}
-	} else if (con->request.http_if_modified_since) {
+	} else if (con->request.http_if_modified_since && head_or_get) {
+		/* last-modified handling */
 		size_t used_len;
 		char *semicolon;
 
diff -u lighttpd-1.4.32/src/keyvalue.c lighttpd-1.4.36/src/keyvalue.c
--- lighttpd-1.4.32/src/keyvalue.c	2012-11-07 07:16:36.000000000 -0600
+++ lighttpd-1.4.36/src/keyvalue.c	2015-07-26 05:36:36.000000000 -0500
@@ -13,29 +13,44 @@
 };
 
 static keyvalue http_methods[] = {
-	{ HTTP_METHOD_GET,  "GET" },
-	{ HTTP_METHOD_POST, "POST" },
+	{ HTTP_METHOD_GET, "GET" },
 	{ HTTP_METHOD_HEAD, "HEAD" },
-	{ HTTP_METHOD_PROPFIND, "PROPFIND" },
-	{ HTTP_METHOD_PROPPATCH, "PROPPATCH" },
-	{ HTTP_METHOD_REPORT, "REPORT" },
-	{ HTTP_METHOD_OPTIONS, "OPTIONS" },
-	{ HTTP_METHOD_MKCOL, "MKCOL" },
+	{ HTTP_METHOD_POST, "POST" },
 	{ HTTP_METHOD_PUT, "PUT" },
-	{ HTTP_METHOD_PATCH, "PATCH" },
 	{ HTTP_METHOD_DELETE, "DELETE" },
+	{ HTTP_METHOD_CONNECT, "CONNECT" },
+	{ HTTP_METHOD_OPTIONS, "OPTIONS" },
+	{ HTTP_METHOD_TRACE, "TRACE" },
+	{ HTTP_METHOD_ACL, "ACL" },
+	{ HTTP_METHOD_BASELINE_CONTROL, "BASELINE-CONTROL" },
+	{ HTTP_METHOD_BIND, "BIND" },
+	{ HTTP_METHOD_CHECKIN, "CHECKIN" },
+	{ HTTP_METHOD_CHECKOUT, "CHECKOUT" },
 	{ HTTP_METHOD_COPY, "COPY" },
-	{ HTTP_METHOD_MOVE, "MOVE" },
 	{ HTTP_METHOD_LABEL, "LABEL" },
-	{ HTTP_METHOD_CHECKOUT, "CHECKOUT" },
-	{ HTTP_METHOD_CHECKIN, "CHECKIN" },
-	{ HTTP_METHOD_MERGE, "MERGE" },
+	{ HTTP_METHOD_LINK, "LINK" },
 	{ HTTP_METHOD_LOCK, "LOCK" },
-	{ HTTP_METHOD_UNLOCK, "UNLOCK" },
+	{ HTTP_METHOD_MERGE, "MERGE" },
 	{ HTTP_METHOD_MKACTIVITY, "MKACTIVITY" },
+	{ HTTP_METHOD_MKCALENDAR, "MKCALENDAR" },
+	{ HTTP_METHOD_MKCOL, "MKCOL" },
+	{ HTTP_METHOD_MKREDIRECTREF, "MKREDIRECTREF" },
+	{ HTTP_METHOD_MKWORKSPACE, "MKWORKSPACE" },
+	{ HTTP_METHOD_MOVE, "MOVE" },
+	{ HTTP_METHOD_ORDERPATCH, "ORDERPATCH" },
+	{ HTTP_METHOD_PATCH, "PATCH" },
+	{ HTTP_METHOD_PROPFIND, "PROPFIND" },
+	{ HTTP_METHOD_PROPPATCH, "PROPPATCH" },
+	{ HTTP_METHOD_REBIND, "REBIND" },
+	{ HTTP_METHOD_REPORT, "REPORT" },
+	{ HTTP_METHOD_SEARCH, "SEARCH" },
+	{ HTTP_METHOD_UNBIND, "UNBIND" },
 	{ HTTP_METHOD_UNCHECKOUT, "UNCHECKOUT" },
+	{ HTTP_METHOD_UNLINK, "UNLINK" },
+	{ HTTP_METHOD_UNLOCK, "UNLOCK" },
+	{ HTTP_METHOD_UPDATE, "UPDATE" },
+	{ HTTP_METHOD_UPDATEREDIRECTREF, "UPDATEREDIRECTREF" },
 	{ HTTP_METHOD_VERSION_CONTROL, "VERSION-CONTROL" },
-	{ HTTP_METHOD_CONNECT, "CONNECT" },
 
 	{ HTTP_METHOD_UNSET, NULL }
 };
diff -u lighttpd-1.4.32/src/keyvalue.h lighttpd-1.4.36/src/keyvalue.h
--- lighttpd-1.4.32/src/keyvalue.h	2012-11-07 07:16:36.000000000 -0600
+++ lighttpd-1.4.36/src/keyvalue.h	2015-07-26 05:36:36.000000000 -0500
@@ -11,31 +11,56 @@
 
 struct server;
 
+/* sources:
+ * - [RFC2616], Section 9
+ *   (or http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22)
+ * - http://tools.ietf.org/html/draft-ietf-httpbis-method-registrations-11, Appendix A
+ *
+ * http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22, Section 8.1 defines
+ * a new registry (not available yet):
+ *   http://www.iana.org/assignments/http-methods
+ */
+
 typedef enum {
 	HTTP_METHOD_UNSET = -1,
-	HTTP_METHOD_GET,
-	HTTP_METHOD_POST,
-	HTTP_METHOD_HEAD,
-	HTTP_METHOD_OPTIONS,
-	HTTP_METHOD_PROPFIND,  /* WebDAV */
-	HTTP_METHOD_MKCOL,
-	HTTP_METHOD_PUT,
-	HTTP_METHOD_PATCH,
-	HTTP_METHOD_DELETE,
-	HTTP_METHOD_COPY,
-	HTTP_METHOD_MOVE,
-	HTTP_METHOD_PROPPATCH,
-	HTTP_METHOD_REPORT, /* DeltaV */
-	HTTP_METHOD_CHECKOUT,
-	HTTP_METHOD_CHECKIN,
-	HTTP_METHOD_VERSION_CONTROL,
-	HTTP_METHOD_UNCHECKOUT,
-	HTTP_METHOD_MKACTIVITY,
-	HTTP_METHOD_MERGE,
-	HTTP_METHOD_LOCK,
-	HTTP_METHOD_UNLOCK,
-	HTTP_METHOD_LABEL,
-	HTTP_METHOD_CONNECT
+	HTTP_METHOD_GET,               /* [RFC2616], Section 9.3 */
+	HTTP_METHOD_HEAD,              /* [RFC2616], Section 9.4 */
+	HTTP_METHOD_POST,              /* [RFC2616], Section 9.5 */
+	HTTP_METHOD_PUT,               /* [RFC2616], Section 9.6 */
+	HTTP_METHOD_DELETE,            /* [RFC2616], Section 9.7 */
+	HTTP_METHOD_CONNECT,           /* [RFC2616], Section 9.9 */
+	HTTP_METHOD_OPTIONS,           /* [RFC2616], Section 9.2 */
+	HTTP_METHOD_TRACE,             /* [RFC2616], Section 9.8 */
+	HTTP_METHOD_ACL,               /* [RFC3744], Section 8.1 */
+	HTTP_METHOD_BASELINE_CONTROL,  /* [RFC3253], Section 12.6 */
+	HTTP_METHOD_BIND,              /* [RFC5842], Section 4 */
+	HTTP_METHOD_CHECKIN,           /* [RFC3253], Section 4.4 and [RFC3253], Section 9.4 */
+	HTTP_METHOD_CHECKOUT,          /* [RFC3253], Section 4.3 and [RFC3253], Section 8.8 */
+	HTTP_METHOD_COPY,              /* [RFC4918], Section 9.8 */
+	HTTP_METHOD_LABEL,             /* [RFC3253], Section 8.2 */
+	HTTP_METHOD_LINK,              /* [RFC2068], Section 19.6.1.2 */
+	HTTP_METHOD_LOCK,              /* [RFC4918], Section 9.10 */
+	HTTP_METHOD_MERGE,             /* [RFC3253], Section 11.2 */
+	HTTP_METHOD_MKACTIVITY,        /* [RFC3253], Section 13.5 */
+	HTTP_METHOD_MKCALENDAR,        /* [RFC4791], Section 5.3.1 */
+	HTTP_METHOD_MKCOL,             /* [RFC4918], Section 9.3 */
+	HTTP_METHOD_MKREDIRECTREF,     /* [RFC4437], Section 6 */
+	HTTP_METHOD_MKWORKSPACE,       /* [RFC3253], Section 6.3 */
+	HTTP_METHOD_MOVE,              /* [RFC4918], Section 9.9 */
+	HTTP_METHOD_ORDERPATCH,        /* [RFC3648], Section 7 */
+	HTTP_METHOD_PATCH,             /* [RFC5789], Section 2 */
+	HTTP_METHOD_PROPFIND,          /* [RFC4918], Section 9.1 */
+	HTTP_METHOD_PROPPATCH,         /* [RFC4918], Section 9.2 */
+	HTTP_METHOD_REBIND,            /* [RFC5842], Section 6 */
+	HTTP_METHOD_REPORT,            /* [RFC3253], Section 3.6 */
+	HTTP_METHOD_SEARCH,            /* [RFC5323], Section 2 */
+	HTTP_METHOD_UNBIND,            /* [RFC5842], Section 5 */
+	HTTP_METHOD_UNCHECKOUT,        /* [RFC3253], Section 4.5 */
+	HTTP_METHOD_UNLINK,            /* [RFC2068], Section 19.6.1.3 */
+	HTTP_METHOD_UNLOCK,            /* [RFC4918], Section 9.11 */
+	HTTP_METHOD_UPDATE,            /* [RFC3253], Section 7.1 */
+	HTTP_METHOD_UPDATEREDIRECTREF, /* [RFC4437], Section 7 */
+	HTTP_METHOD_VERSION_CONTROL    /* [RFC3253], Section 3.5 */
 } http_method_t;
 
 typedef enum { HTTP_VERSION_UNSET = -1, HTTP_VERSION_1_0, HTTP_VERSION_1_1 } http_version_t;
diff -u lighttpd-1.4.32/src/lemon.c lighttpd-1.4.36/src/lemon.c
--- lighttpd-1.4.32/src/lemon.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.36/src/lemon.c	2015-07-26 05:36:36.000000000 -0500
@@ -1613,12 +1613,14 @@
 int k;
 FILE *err;
 {
-  int spcnt, i;
-  if( argv[0] ) fprintf(err,"%s",argv[0]);
-  spcnt = strlen(argv[0]) + 1;
+  int spcnt = 0, i;
+  if( argv[0] ) {
+    fprintf(err,"%s",argv[0]);
+    spcnt += strlen(argv[0]) + 1;
+  }
   for(i=1; i<n && argv[i]; i++){
     fprintf(err," %s",argv[i]);
-    spcnt += strlen(argv[i]+1);
+    spcnt += strlen(argv[i]) + 1;
   }
   spcnt += k;
   for(; argv[i]; i++) fprintf(err," %s",argv[i]);
@@ -3105,7 +3107,7 @@
     stddt[j] = 0;
     hash = 0;
     for(j=0; stddt[j]; j++){
-      hash = hash*53 + stddt[j];
+      hash = (unsigned int)hash*53u + (unsigned int) stddt[j];
     }
     hash = (hash & 0x7fffffff)%arraysize;
     while( types[hash] ){
@@ -3751,8 +3753,8 @@
 PRIVATE int strhash(x)
 char *x;
 {
-  int h = 0;
-  while( *x) h = h*13 + *(x++);
+  unsigned int h = 0;
+  while( *x) h = h*13u + (unsigned int) *(x++);
   return h;
 }
 
@@ -4124,9 +4126,9 @@
 PRIVATE int statehash(a)
 struct config *a;
 {
-  int h=0;
+  unsigned int h=0;
   while( a ){
-    h = h*571 + a->rp->index*37 + a->dot;
+    h = h*571u + (unsigned int)a->rp->index*37u + (unsigned int)a->dot;
     a = a->bp;
   }
   return h;
diff -u lighttpd-1.4.32/src/log.c lighttpd-1.4.36/src/log.c
--- lighttpd-1.4.32/src/log.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/log.c	2015-07-26 05:36:36.000000000 -0500
@@ -122,9 +122,7 @@
 		return -1;
 	}
 
-#ifdef FD_CLOEXEC
-	fcntl(fd, F_SETFD, FD_CLOEXEC);
-#endif
+	fd_close_on_exec(fd);
 
 	return fd;
 }
@@ -154,7 +152,7 @@
 
 	if (srv->srvconf.errorlog_use_syslog) {
 		srv->errorlog_mode = ERRORLOG_SYSLOG;
-	} else if (!buffer_is_empty(srv->srvconf.errorlog_file)) {
+	} else if (!buffer_string_is_empty(srv->srvconf.errorlog_file)) {
 		const char *logfile = srv->srvconf.errorlog_file->ptr;
 
 		if (-1 == (srv->errorlog_fd = open_logfile_or_pipe(srv, logfile))) {
@@ -172,15 +170,13 @@
 		srv->errorlog_fd = -1;
 	}
 
-	if (!buffer_is_empty(srv->srvconf.breakagelog_file)) {
+	if (!buffer_string_is_empty(srv->srvconf.breakagelog_file)) {
 		int breakage_fd;
 		const char *logfile = srv->srvconf.breakagelog_file->ptr;
 
 		if (srv->errorlog_mode == ERRORLOG_FD) {
 			srv->errorlog_fd = dup(STDERR_FILENO);
-#ifdef FD_CLOEXEC
-			fcntl(srv->errorlog_fd, F_SETFD, FD_CLOEXEC);
-#endif
+			fd_close_on_exec(srv->errorlog_fd);
 		}
 
 		if (-1 == (breakage_fd = open_logfile_or_pipe(srv, logfile))) {
@@ -231,10 +227,7 @@
 			/* ok, new log is open, close the old one */
 			close(srv->errorlog_fd);
 			srv->errorlog_fd = new_fd;
-#ifdef FD_CLOEXEC
-			/* close fd on exec (cgi) */
-			fcntl(srv->errorlog_fd, F_SETFD, FD_CLOEXEC);
-#endif
+			fd_close_on_exec(srv->errorlog_fd);
 		}
 	}
 
@@ -263,39 +256,9 @@
 	return 0;
 }
 
-int log_error_write(server *srv, const char *filename, unsigned int line, const char *fmt, ...) {
-	va_list ap;
-
-	switch(srv->errorlog_mode) {
-	case ERRORLOG_PIPE:
-	case ERRORLOG_FILE:
-	case ERRORLOG_FD:
-		if (-1 == srv->errorlog_fd) return 0;
-		/* cache the generated timestamp */
-		if (srv->cur_ts != srv->last_generated_debug_ts) {
-			buffer_prepare_copy(srv->ts_debug_str, 255);
-			strftime(srv->ts_debug_str->ptr, srv->ts_debug_str->size - 1, "%Y-%m-%d %H:%M:%S", localtime(&(srv->cur_ts)));
-			srv->ts_debug_str->used = strlen(srv->ts_debug_str->ptr) + 1;
-
-			srv->last_generated_debug_ts = srv->cur_ts;
-		}
-
-		buffer_copy_string_buffer(srv->errorlog_buf, srv->ts_debug_str);
-		buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN(": ("));
-		break;
-	case ERRORLOG_SYSLOG:
-		/* syslog is generating its own timestamps */
-		buffer_copy_string_len(srv->errorlog_buf, CONST_STR_LEN("("));
-		break;
-	}
-
-	buffer_append_string(srv->errorlog_buf, filename);
-	buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN("."));
-	buffer_append_long(srv->errorlog_buf, line);
-	buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN(") "));
-
-
-	for(va_start(ap, fmt); *fmt; fmt++) {
+/* lowercase: append space, uppercase: don't */
+static void log_buffer_append_printf(buffer *out, const char *fmt, va_list ap) {
+	for(; *fmt; fmt++) {
 		int d;
 		char *s;
 		buffer *b;
@@ -304,50 +267,50 @@
 		switch(*fmt) {
 		case 's':           /* string */
 			s = va_arg(ap, char *);
-			buffer_append_string(srv->errorlog_buf, s);
-			buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN(" "));
+			buffer_append_string_c_escaped(out, s, (NULL != s) ? strlen(s) : 0);
+			buffer_append_string_len(out, CONST_STR_LEN(" "));
 			break;
 		case 'b':           /* buffer */
 			b = va_arg(ap, buffer *);
-			buffer_append_string_buffer(srv->errorlog_buf, b);
-			buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN(" "));
+			buffer_append_string_c_escaped(out, CONST_BUF_LEN(b));
+			buffer_append_string_len(out, CONST_STR_LEN(" "));
 			break;
 		case 'd':           /* int */
 			d = va_arg(ap, int);
-			buffer_append_long(srv->errorlog_buf, d);
-			buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN(" "));
+			buffer_append_int(out, d);
+			buffer_append_string_len(out, CONST_STR_LEN(" "));
 			break;
 		case 'o':           /* off_t */
 			o = va_arg(ap, off_t);
-			buffer_append_off_t(srv->errorlog_buf, o);
-			buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN(" "));
+			buffer_append_int(out, o);
+			buffer_append_string_len(out, CONST_STR_LEN(" "));
 			break;
 		case 'x':           /* int (hex) */
 			d = va_arg(ap, int);
-			buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN("0x"));
-			buffer_append_long_hex(srv->errorlog_buf, d);
-			buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN(" "));
+			buffer_append_string_len(out, CONST_STR_LEN("0x"));
+			buffer_append_uint_hex(out, d);
+			buffer_append_string_len(out, CONST_STR_LEN(" "));
 			break;
 		case 'S':           /* string */
 			s = va_arg(ap, char *);
-			buffer_append_string(srv->errorlog_buf, s);
+			buffer_append_string_c_escaped(out, s, (NULL != s) ? strlen(s) : 0);
 			break;
 		case 'B':           /* buffer */
 			b = va_arg(ap, buffer *);
-			buffer_append_string_buffer(srv->errorlog_buf, b);
+			buffer_append_string_c_escaped(out, CONST_BUF_LEN(b));
 			break;
 		case 'D':           /* int */
 			d = va_arg(ap, int);
-			buffer_append_long(srv->errorlog_buf, d);
+			buffer_append_int(out, d);
 			break;
 		case 'O':           /* off_t */
 			o = va_arg(ap, off_t);
-			buffer_append_off_t(srv->errorlog_buf, o);
+			buffer_append_int(out, o);
 			break;
 		case 'X':           /* int (hex) */
 			d = va_arg(ap, int);
-			buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN("0x"));
-			buffer_append_long_hex(srv->errorlog_buf, d);
+			buffer_append_string_len(out, CONST_STR_LEN("0x"));
+			buffer_append_uint_hex(out, d);
 			break;
 		case '(':
 		case ')':
@@ -355,24 +318,108 @@
 		case '>':
 		case ',':
 		case ' ':
-			buffer_append_string_len(srv->errorlog_buf, fmt, 1);
+			buffer_append_string_len(out, fmt, 1);
 			break;
 		}
 	}
-	va_end(ap);
+}
 
+static int log_buffer_prepare(buffer *b, server *srv, const char *filename, unsigned int line) {
 	switch(srv->errorlog_mode) {
 	case ERRORLOG_PIPE:
 	case ERRORLOG_FILE:
 	case ERRORLOG_FD:
-		buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN("\n"));
-		write(srv->errorlog_fd, srv->errorlog_buf->ptr, srv->errorlog_buf->used - 1);
+		if (-1 == srv->errorlog_fd) return -1;
+		/* cache the generated timestamp */
+		if (srv->cur_ts != srv->last_generated_debug_ts) {
+			buffer_string_prepare_copy(srv->ts_debug_str, 255);
+			buffer_append_strftime(srv->ts_debug_str, "%Y-%m-%d %H:%M:%S", localtime(&(srv->cur_ts)));
+
+			srv->last_generated_debug_ts = srv->cur_ts;
+		}
+
+		buffer_copy_buffer(b, srv->ts_debug_str);
+		buffer_append_string_len(b, CONST_STR_LEN(": ("));
 		break;
 	case ERRORLOG_SYSLOG:
-		syslog(LOG_ERR, "%s", srv->errorlog_buf->ptr);
+		/* syslog is generating its own timestamps */
+		buffer_copy_string_len(b, CONST_STR_LEN("("));
 		break;
 	}
 
+	buffer_append_string(b, filename);
+	buffer_append_string_len(b, CONST_STR_LEN("."));
+	buffer_append_int(b, line);
+	buffer_append_string_len(b, CONST_STR_LEN(") "));
+
 	return 0;
 }
 
+static void log_write(server *srv, buffer *b) {
+	switch(srv->errorlog_mode) {
+	case ERRORLOG_PIPE:
+	case ERRORLOG_FILE:
+	case ERRORLOG_FD:
+		buffer_append_string_len(b, CONST_STR_LEN("\n"));
+		write(srv->errorlog_fd, CONST_BUF_LEN(b));
+		break;
+	case ERRORLOG_SYSLOG:
+		syslog(LOG_ERR, "%s", b->ptr);
+		break;
+	}
+}
+
+int log_error_write(server *srv, const char *filename, unsigned int line, const char *fmt, ...) {
+	va_list ap;
+
+	if (-1 == log_buffer_prepare(srv->errorlog_buf, srv, filename, line)) return 0;
+
+	va_start(ap, fmt);
+	log_buffer_append_printf(srv->errorlog_buf, fmt, ap);
+	va_end(ap);
+
+	log_write(srv, srv->errorlog_buf);
+
+	return 0;
+}
+
+int log_error_write_multiline_buffer(server *srv, const char *filename, unsigned int line, buffer *multiline, const char *fmt, ...) {
+	va_list ap;
+	size_t prefix_len;
+	buffer *b = srv->errorlog_buf;
+	char *pos, *end, *current_line;
+
+	if (buffer_string_is_empty(multiline)) return 0;
+
+	if (-1 == log_buffer_prepare(b, srv, filename, line)) return 0;
+
+	va_start(ap, fmt);
+	log_buffer_append_printf(b, fmt, ap);
+	va_end(ap);
+
+	prefix_len = buffer_string_length(b);
+
+	current_line = pos = multiline->ptr;
+	end = multiline->ptr + buffer_string_length(multiline);
+
+	for ( ; pos <= end ; ++pos) {
+		switch (*pos) {
+		case '\n':
+		case '\r':
+		case '\0': /* handles end of string */
+			if (current_line < pos) {
+				/* truncate to prefix */
+				buffer_string_set_length(b, prefix_len);
+
+				buffer_append_string_len(b, current_line, pos - current_line);
+				log_write(srv, b);
+			}
+			current_line = pos + 1;
+			break;
+		default:
+			break;
+		}
+	}
+
+	return 0;
+}
diff -u lighttpd-1.4.32/src/log.h lighttpd-1.4.36/src/log.h
--- lighttpd-1.4.32/src/log.h	2010-02-01 17:28:20.000000000 -0600
+++ lighttpd-1.4.36/src/log.h	2015-07-26 05:36:36.000000000 -0500
@@ -8,13 +8,12 @@
  */
 int openDevNull(int fd);
 
-#define WP() log_error_write(srv, __FILE__, __LINE__, "");
-
 int open_logfile_or_pipe(server *srv, const char* logfile);
 
 int log_error_open(server *srv);
 int log_error_close(server *srv);
 int log_error_write(server *srv, const char *filename, unsigned int line, const char *fmt, ...);
+int log_error_write_multiline_buffer(server *srv, const char *filename, unsigned int line, buffer *multiline, const char *fmt, ...);
 int log_error_cycle(server *srv);
 
 #endif
diff -u lighttpd-1.4.32/src/Makefile.am lighttpd-1.4.36/src/Makefile.am
--- lighttpd-1.4.32/src/Makefile.am	2012-11-17 11:32:01.000000000 -0600
+++ lighttpd-1.4.36/src/Makefile.am	2015-07-26 05:36:36.000000000 -0500
@@ -1,4 +1,4 @@
-AM_CFLAGS = $(FAM_CFLAGS)
+AM_CFLAGS = $(FAM_CFLAGS) $(LIBUNWIND_CFLAGS)
 
 noinst_PROGRAMS=proc_open lemon # simple-fcgi #graphic evalo bench ajp ssl error_test adserver gen-license
 sbin_PROGRAMS=lighttpd lighttpd-angel
@@ -57,27 +57,27 @@
 CLEANFILES = versionstamp.h versionstamp.h.tmp
 
 common_src=buffer.c log.c \
-      keyvalue.c chunk.c  \
-      http_chunk.c stream.c fdevent.c \
-      stat_cache.c plugin.c joblist.c etag.c array.c \
-      data_string.c data_count.c data_array.c \
-      data_integer.c md5.c data_fastcgi.c \
-      fdevent_select.c fdevent_libev.c \
-      fdevent_poll.c fdevent_linux_sysepoll.c \
-      fdevent_solaris_devpoll.c fdevent_solaris_port.c \
-      fdevent_freebsd_kqueue.c \
-      data_config.c bitset.c \
-      inet_ntop_cache.c crc32.c \
-      connections-glue.c \
-      configfile-glue.c \
-      http-header-glue.c \
-      network_write.c network_linux_sendfile.c \
-      network_freebsd_sendfile.c network_writev.c \
-      network_solaris_sendfilev.c network_openssl.c \
-      splaytree.c status_counter.c
+	keyvalue.c chunk.c  \
+	http_chunk.c stream.c fdevent.c \
+	stat_cache.c plugin.c joblist.c etag.c array.c \
+	data_string.c data_count.c data_array.c \
+	data_integer.c md5.c data_fastcgi.c \
+	fdevent_select.c fdevent_libev.c \
+	fdevent_poll.c fdevent_linux_sysepoll.c \
+	fdevent_solaris_devpoll.c fdevent_solaris_port.c \
+	fdevent_freebsd_kqueue.c \
+	data_config.c \
+	inet_ntop_cache.c crc32.c \
+	connections-glue.c \
+	configfile-glue.c \
+	http-header-glue.c \
+	network_write.c network_linux_sendfile.c \
+	network_freebsd_sendfile.c network_writev.c \
+	network_solaris_sendfilev.c network_openssl.c \
+	splaytree.c status_counter.c
 
 src = server.c response.c connections.c network.c \
-      configfile.c configparser.c request.c proc_open.c
+	configfile.c configparser.c request.c proc_open.c
 
 lib_LTLIBRARIES =
 
@@ -98,197 +98,198 @@
 
 lib_LTLIBRARIES += mod_flv_streaming.la
 mod_flv_streaming_la_SOURCES = mod_flv_streaming.c
-mod_flv_streaming_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_flv_streaming_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_flv_streaming_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_evasive.la
 mod_evasive_la_SOURCES = mod_evasive.c
-mod_evasive_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_evasive_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_evasive_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_webdav.la
 mod_webdav_la_SOURCES = mod_webdav.c
 mod_webdav_la_CFLAGS = $(AM_CFLAGS) $(XML_CFLAGS) $(SQLITE_CFLAGS) 
-mod_webdav_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_webdav_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_webdav_la_LIBADD = $(common_libadd) $(XML_LIBS) $(SQLITE_LIBS) $(UUID_LIBS)
 
 lib_LTLIBRARIES += mod_magnet.la
 mod_magnet_la_SOURCES = mod_magnet.c mod_magnet_cache.c
 mod_magnet_la_CFLAGS = $(AM_CFLAGS) $(LUA_CFLAGS)
-mod_magnet_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_magnet_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_magnet_la_LIBADD = $(common_libadd) $(LUA_LIBS) -lm
 
 lib_LTLIBRARIES += mod_cml.la
 mod_cml_la_SOURCES = mod_cml.c mod_cml_lua.c mod_cml_funcs.c
 mod_cml_la_CFLAGS = $(AM_CFLAGS) $(LUA_CFLAGS)
-mod_cml_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_cml_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_cml_la_LIBADD = $(MEMCACHE_LIB) $(common_libadd) $(LUA_LIBS) -lm
 
 lib_LTLIBRARIES += mod_trigger_b4_dl.la
 mod_trigger_b4_dl_la_SOURCES = mod_trigger_b4_dl.c
-mod_trigger_b4_dl_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_trigger_b4_dl_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_trigger_b4_dl_la_LIBADD = $(GDBM_LIB) $(MEMCACHE_LIB) $(PCRE_LIB) $(common_libadd)
 
 lib_LTLIBRARIES += mod_mysql_vhost.la
 mod_mysql_vhost_la_SOURCES = mod_mysql_vhost.c
-mod_mysql_vhost_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_mysql_vhost_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_mysql_vhost_la_LIBADD = $(MYSQL_LIBS) $(common_libadd)
 mod_mysql_vhost_la_CPPFLAGS = $(MYSQL_INCLUDE)
 
 lib_LTLIBRARIES += mod_cgi.la
 mod_cgi_la_SOURCES = mod_cgi.c
-mod_cgi_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_cgi_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_cgi_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_scgi.la
 mod_scgi_la_SOURCES = mod_scgi.c
-mod_scgi_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_scgi_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_scgi_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_staticfile.la
 mod_staticfile_la_SOURCES = mod_staticfile.c
-mod_staticfile_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_staticfile_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_staticfile_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_dirlisting.la
 mod_dirlisting_la_SOURCES = mod_dirlisting.c
-mod_dirlisting_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_dirlisting_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_dirlisting_la_LIBADD = $(common_libadd) $(PCRE_LIB)
 
 lib_LTLIBRARIES += mod_indexfile.la
 mod_indexfile_la_SOURCES = mod_indexfile.c
-mod_indexfile_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_indexfile_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_indexfile_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_setenv.la
 mod_setenv_la_SOURCES = mod_setenv.c
-mod_setenv_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_setenv_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_setenv_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_alias.la
 mod_alias_la_SOURCES = mod_alias.c
-mod_alias_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_alias_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_alias_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_userdir.la
 mod_userdir_la_SOURCES = mod_userdir.c
-mod_userdir_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_userdir_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_userdir_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_rrdtool.la
 mod_rrdtool_la_SOURCES = mod_rrdtool.c
-mod_rrdtool_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_rrdtool_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_rrdtool_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_usertrack.la
 mod_usertrack_la_SOURCES = mod_usertrack.c
-mod_usertrack_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_usertrack_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_usertrack_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_proxy.la
 mod_proxy_la_SOURCES = mod_proxy.c
-mod_proxy_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_proxy_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_proxy_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_ssi.la
 mod_ssi_la_SOURCES = mod_ssi_exprparser.c mod_ssi_expr.c mod_ssi.c
-mod_ssi_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_ssi_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_ssi_la_LIBADD = $(common_libadd) $(PCRE_LIB)
 
 lib_LTLIBRARIES += mod_secdownload.la
 mod_secdownload_la_SOURCES = mod_secure_download.c
-mod_secdownload_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_secdownload_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_secdownload_la_LIBADD = $(common_libadd)
 
 #lib_LTLIBRARIES += mod_httptls.la
 #mod_httptls_la_SOURCES = mod_httptls.c
-#mod_httptls_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+#mod_httptls_la_LDFLAGS = -module -export-dynamic -avoid-version
 #mod_httptls_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_expire.la
 mod_expire_la_SOURCES = mod_expire.c
-mod_expire_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_expire_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_expire_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_evhost.la
 mod_evhost_la_SOURCES = mod_evhost.c
-mod_evhost_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_evhost_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_evhost_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_simple_vhost.la
 mod_simple_vhost_la_SOURCES = mod_simple_vhost.c
-mod_simple_vhost_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_simple_vhost_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_simple_vhost_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_fastcgi.la
 mod_fastcgi_la_SOURCES = mod_fastcgi.c
-mod_fastcgi_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_fastcgi_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_fastcgi_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_extforward.la
 mod_extforward_la_SOURCES = mod_extforward.c
-mod_extforward_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_extforward_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_extforward_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_access.la
 mod_access_la_SOURCES = mod_access.c
-mod_access_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_access_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_access_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_compress.la
 mod_compress_la_SOURCES = mod_compress.c
-mod_compress_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_compress_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_compress_la_LIBADD = $(Z_LIB) $(BZ_LIB) $(common_libadd)
 
 lib_LTLIBRARIES += mod_auth.la
 mod_auth_la_SOURCES = mod_auth.c http_auth.c
-mod_auth_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
-mod_auth_la_LIBADD = $(CRYPT_LIB) $(LDAP_LIB) $(LBER_LIB) $(common_libadd)
+mod_auth_la_LDFLAGS = -module -export-dynamic -avoid-version
+mod_auth_la_LIBADD = $(CRYPT_LIB) $(SSL_LIB) $(LDAP_LIB) $(LBER_LIB) $(common_libadd)
 
 lib_LTLIBRARIES += mod_rewrite.la
 mod_rewrite_la_SOURCES = mod_rewrite.c
-mod_rewrite_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_rewrite_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_rewrite_la_LIBADD = $(PCRE_LIB) $(common_libadd)
 
 lib_LTLIBRARIES += mod_redirect.la
 mod_redirect_la_SOURCES = mod_redirect.c
-mod_redirect_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_redirect_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_redirect_la_LIBADD = $(PCRE_LIB) $(common_libadd)
 
 lib_LTLIBRARIES += mod_status.la
 mod_status_la_SOURCES = mod_status.c
-mod_status_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_status_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_status_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_accesslog.la
 mod_accesslog_la_SOURCES = mod_accesslog.c
-mod_accesslog_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_accesslog_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_accesslog_la_LIBADD = $(common_libadd)
 
 
 hdr = server.h buffer.h network.h log.h keyvalue.h \
-      response.h request.h fastcgi.h chunk.h \
-      settings.h http_chunk.h \
-      md5.h http_auth.h stream.h \
-      fdevent.h connections.h base.h stat_cache.h \
-      plugin.h mod_auth.h \
-      etag.h joblist.h array.h crc32.h \
-      network_backends.h configfile.h bitset.h \
-      mod_ssi.h mod_ssi_expr.h inet_ntop_cache.h \
-      configparser.h mod_ssi_exprparser.h \
-      sys-mmap.h sys-socket.h mod_cml.h mod_cml_funcs.h \
-      splaytree.h proc_open.h status_counter.h \
-      mod_magnet_cache.h \
-      version.h
+	response.h request.h fastcgi.h chunk.h \
+	settings.h http_chunk.h \
+	md5.h http_auth.h stream.h \
+	fdevent.h connections.h base.h stat_cache.h \
+	plugin.h mod_auth.h \
+	etag.h joblist.h array.h crc32.h \
+	network_backends.h configfile.h \
+	mod_ssi.h mod_ssi_expr.h inet_ntop_cache.h \
+	configparser.h mod_ssi_exprparser.h \
+	sys-mmap.h sys-socket.h mod_cml.h mod_cml_funcs.h \
+	splaytree.h proc_open.h status_counter.h \
+	mod_magnet_cache.h \
+	version.h
 
 DEFS= @DEFS@ -DHAVE_VERSION_H -DLIBRARY_DIR="\"$(libdir)\"" -DSBIN_DIR="\"$(sbindir)\""
 
 lighttpd_SOURCES = $(src)
-lighttpd_LDADD = $(PCRE_LIB) $(DL_LIB) $(SENDFILE_LIB) $(ATTR_LIB) $(common_libadd) $(SSL_LIB) $(FAM_LIBS) $(LIBEV_LIBS)
+lighttpd_LDADD = $(PCRE_LIB) $(DL_LIB) $(SENDFILE_LIB) $(ATTR_LIB) $(common_libadd) $(SSL_LIB) $(FAM_LIBS) $(LIBEV_LIBS) $(LIBUNWIND_LIBS)
 lighttpd_LDFLAGS = -export-dynamic
 lighttpd_CCPFLAGS = $(FAM_CFLAGS) $(LIBEV_CFLAGS)
 
 proc_open_SOURCES = proc_open.c buffer.c
+proc_open_LDADD = $(LIBUNWIND_LIBS)
 proc_open_CPPFLAGS= -DDEBUG_PROC_OPEN
 
 #gen_license_SOURCES = license.c md5.c buffer.c gen_license.c
@@ -306,5 +307,10 @@
 #ajp_SOURCES = ajp.c
 
 noinst_HEADERS   = $(hdr)
-EXTRA_DIST = mod_skeleton.c configparser.y mod_ssi_exprparser.y lempar.c SConscript
-
+EXTRA_DIST = \
+	mod_skeleton.c \
+	configparser.y \
+	mod_ssi_exprparser.y \
+	lempar.c \
+	SConscript \
+	CMakeLists.txt config.h.cmake
diff -u lighttpd-1.4.32/src/Makefile.in lighttpd-1.4.36/src/Makefile.in
--- lighttpd-1.4.32/src/Makefile.in	2012-11-20 04:56:23.000000000 -0600
+++ lighttpd-1.4.36/src/Makefile.in	2015-07-26 05:36:49.000000000 -0500
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.6 from Makefile.am.
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -18,23 +17,51 @@
 
 
 VPATH = @srcdir@
-am__make_dryrun = \
-  { \
-    am__dry=no; \
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
     case $$MAKEFLAGS in \
       *\\[\ \	]*) \
-        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
-          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
-      *) \
-        for am__flg in $$MAKEFLAGS; do \
-          case $$am__flg in \
-            *=*|--*) ;; \
-            *n*) am__dry=yes; break;; \
-          esac; \
-        done;; \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
     esac; \
-    test $$am__dry = yes; \
-  }
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -63,8 +90,8 @@
 @NO_RDYNAMIC_TRUE@am__append_1 = liblightcomp.la
 @NO_RDYNAMIC_FALSE@am__append_2 = $(common_src)
 subdir = src
-DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
-	$(srcdir)/Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
+	$(top_srcdir)/depcomp $(noinst_HEADERS)
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
 	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
@@ -116,11 +143,11 @@
 	fdevent_select.c fdevent_libev.c fdevent_poll.c \
 	fdevent_linux_sysepoll.c fdevent_solaris_devpoll.c \
 	fdevent_solaris_port.c fdevent_freebsd_kqueue.c data_config.c \
-	bitset.c inet_ntop_cache.c crc32.c connections-glue.c \
-	configfile-glue.c http-header-glue.c network_write.c \
-	network_linux_sendfile.c network_freebsd_sendfile.c \
-	network_writev.c network_solaris_sendfilev.c network_openssl.c \
-	splaytree.c status_counter.c
+	inet_ntop_cache.c crc32.c connections-glue.c configfile-glue.c \
+	http-header-glue.c network_write.c network_linux_sendfile.c \
+	network_freebsd_sendfile.c network_writev.c \
+	network_solaris_sendfilev.c network_openssl.c splaytree.c \
+	status_counter.c
 am__objects_1 = liblightcomp_la-buffer.lo liblightcomp_la-log.lo \
 	liblightcomp_la-keyvalue.lo liblightcomp_la-chunk.lo \
 	liblightcomp_la-http_chunk.lo liblightcomp_la-stream.lo \
@@ -137,7 +164,7 @@
 	liblightcomp_la-fdevent_solaris_devpoll.lo \
 	liblightcomp_la-fdevent_solaris_port.lo \
 	liblightcomp_la-fdevent_freebsd_kqueue.lo \
-	liblightcomp_la-data_config.lo liblightcomp_la-bitset.lo \
+	liblightcomp_la-data_config.lo \
 	liblightcomp_la-inet_ntop_cache.lo liblightcomp_la-crc32.lo \
 	liblightcomp_la-connections-glue.lo \
 	liblightcomp_la-configfile-glue.lo \
@@ -154,6 +181,7 @@
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
+am__v_lt_1 = 
 liblightcomp_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
 	$(liblightcomp_la_CFLAGS) $(CFLAGS) $(liblightcomp_la_LDFLAGS) \
@@ -180,7 +208,8 @@
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(mod_alias_la_LDFLAGS) $(LDFLAGS) -o $@
 mod_auth_la_DEPENDENCIES = $(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_2)
+	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_2)
 am_mod_auth_la_OBJECTS = mod_auth.lo http_auth.lo
 mod_auth_la_OBJECTS = $(am_mod_auth_la_OBJECTS)
 mod_auth_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
@@ -397,11 +426,11 @@
 	data_fastcgi.c fdevent_select.c fdevent_libev.c fdevent_poll.c \
 	fdevent_linux_sysepoll.c fdevent_solaris_devpoll.c \
 	fdevent_solaris_port.c fdevent_freebsd_kqueue.c data_config.c \
-	bitset.c inet_ntop_cache.c crc32.c connections-glue.c \
-	configfile-glue.c http-header-glue.c network_write.c \
-	network_linux_sendfile.c network_freebsd_sendfile.c \
-	network_writev.c network_solaris_sendfilev.c network_openssl.c \
-	splaytree.c status_counter.c
+	inet_ntop_cache.c crc32.c connections-glue.c configfile-glue.c \
+	http-header-glue.c network_write.c network_linux_sendfile.c \
+	network_freebsd_sendfile.c network_writev.c \
+	network_solaris_sendfilev.c network_openssl.c splaytree.c \
+	status_counter.c
 am__objects_2 = buffer.$(OBJEXT) log.$(OBJEXT) keyvalue.$(OBJEXT) \
 	chunk.$(OBJEXT) http_chunk.$(OBJEXT) stream.$(OBJEXT) \
 	fdevent.$(OBJEXT) stat_cache.$(OBJEXT) plugin.$(OBJEXT) \
@@ -414,7 +443,7 @@
 	fdevent_solaris_devpoll.$(OBJEXT) \
 	fdevent_solaris_port.$(OBJEXT) \
 	fdevent_freebsd_kqueue.$(OBJEXT) data_config.$(OBJEXT) \
-	bitset.$(OBJEXT) inet_ntop_cache.$(OBJEXT) crc32.$(OBJEXT) \
+	inet_ntop_cache.$(OBJEXT) crc32.$(OBJEXT) \
 	connections-glue.$(OBJEXT) configfile-glue.$(OBJEXT) \
 	http-header-glue.$(OBJEXT) network_write.$(OBJEXT) \
 	network_linux_sendfile.$(OBJEXT) \
@@ -431,7 +460,8 @@
 lighttpd_DEPENDENCIES = $(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
+	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_1)
 lighttpd_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(lighttpd_LDFLAGS) $(LDFLAGS) -o $@
@@ -441,7 +471,19 @@
 am_proc_open_OBJECTS = proc_open-proc_open.$(OBJEXT) \
 	proc_open-buffer.$(OBJEXT)
 proc_open_OBJECTS = $(am_proc_open_OBJECTS)
-proc_open_LDADD = $(LDADD)
+proc_open_DEPENDENCIES = $(am__DEPENDENCIES_1)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
@@ -454,20 +496,16 @@
 	$(AM_CFLAGS) $(CFLAGS)
 AM_V_CC = $(am__v_CC_@AM_V@)
 am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
-am__v_CC_0 = @echo "  CC    " $@;
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(AM_LDFLAGS) $(LDFLAGS) -o $@
 AM_V_CCLD = $(am__v_CCLD_@AM_V@)
 am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
-am__v_CCLD_0 = @echo "  CCLD  " $@;
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN   " $@;
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(liblightcomp_la_SOURCES) $(mod_access_la_SOURCES) \
 	$(mod_accesslog_la_SOURCES) $(mod_alias_la_SOURCES) \
 	$(mod_auth_la_SOURCES) $(mod_cgi_la_SOURCES) \
@@ -511,6 +549,23 @@
     *) (install-info --version) >/dev/null 2>&1;; \
   esac
 HEADERS = $(noinst_HEADERS)
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
@@ -561,6 +616,8 @@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBTOOL = @LIBTOOL@
+LIBUNWIND_CFLAGS =
+LIBUNWIND_LIBS =
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
@@ -662,7 +719,7 @@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
-AM_CFLAGS = $(FAM_CFLAGS)
+AM_CFLAGS = $(FAM_CFLAGS) $(LIBUNWIND_CFLAGS)
 LEMON = $(top_builddir)/src/lemon$(EXEEXT)
 lemon_SOURCES = lemon.c
 lighttpd_angel_SOURCES = lighttpd-angel.c
@@ -670,31 +727,31 @@
 MAINTAINERCLEANFILES = configparser.c configparser.h mod_ssi_exprparser.c mod_ssi_exprparser.h
 CLEANFILES = versionstamp.h versionstamp.h.tmp
 common_src = buffer.c log.c \
-      keyvalue.c chunk.c  \
-      http_chunk.c stream.c fdevent.c \
-      stat_cache.c plugin.c joblist.c etag.c array.c \
-      data_string.c data_count.c data_array.c \
-      data_integer.c md5.c data_fastcgi.c \
-      fdevent_select.c fdevent_libev.c \
-      fdevent_poll.c fdevent_linux_sysepoll.c \
-      fdevent_solaris_devpoll.c fdevent_solaris_port.c \
-      fdevent_freebsd_kqueue.c \
-      data_config.c bitset.c \
-      inet_ntop_cache.c crc32.c \
-      connections-glue.c \
-      configfile-glue.c \
-      http-header-glue.c \
-      network_write.c network_linux_sendfile.c \
-      network_freebsd_sendfile.c network_writev.c \
-      network_solaris_sendfilev.c network_openssl.c \
-      splaytree.c status_counter.c
+	keyvalue.c chunk.c  \
+	http_chunk.c stream.c fdevent.c \
+	stat_cache.c plugin.c joblist.c etag.c array.c \
+	data_string.c data_count.c data_array.c \
+	data_integer.c md5.c data_fastcgi.c \
+	fdevent_select.c fdevent_libev.c \
+	fdevent_poll.c fdevent_linux_sysepoll.c \
+	fdevent_solaris_devpoll.c fdevent_solaris_port.c \
+	fdevent_freebsd_kqueue.c \
+	data_config.c \
+	inet_ntop_cache.c crc32.c \
+	connections-glue.c \
+	configfile-glue.c \
+	http-header-glue.c \
+	network_write.c network_linux_sendfile.c \
+	network_freebsd_sendfile.c network_writev.c \
+	network_solaris_sendfilev.c network_openssl.c \
+	splaytree.c status_counter.c
 
 src = server.c response.c connections.c network.c configfile.c \
 	configparser.c request.c proc_open.c $(am__append_2)
 
 #lib_LTLIBRARIES += mod_httptls.la
 #mod_httptls_la_SOURCES = mod_httptls.c
-#mod_httptls_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+#mod_httptls_la_LDFLAGS = -module -export-dynamic -avoid-version
 #mod_httptls_la_LIBADD = $(common_libadd)
 lib_LTLIBRARIES = $(am__append_1) mod_flv_streaming.la mod_evasive.la \
 	mod_webdav.la mod_magnet.la mod_cml.la mod_trigger_b4_dl.la \
@@ -712,125 +769,126 @@
 @NO_RDYNAMIC_FALSE@common_libadd = 
 @NO_RDYNAMIC_TRUE@common_libadd = liblightcomp.la
 mod_flv_streaming_la_SOURCES = mod_flv_streaming.c
-mod_flv_streaming_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_flv_streaming_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_flv_streaming_la_LIBADD = $(common_libadd)
 mod_evasive_la_SOURCES = mod_evasive.c
-mod_evasive_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_evasive_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_evasive_la_LIBADD = $(common_libadd)
 mod_webdav_la_SOURCES = mod_webdav.c
 mod_webdav_la_CFLAGS = $(AM_CFLAGS) $(XML_CFLAGS) $(SQLITE_CFLAGS) 
-mod_webdav_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_webdav_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_webdav_la_LIBADD = $(common_libadd) $(XML_LIBS) $(SQLITE_LIBS) $(UUID_LIBS)
 mod_magnet_la_SOURCES = mod_magnet.c mod_magnet_cache.c
 mod_magnet_la_CFLAGS = $(AM_CFLAGS) $(LUA_CFLAGS)
-mod_magnet_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_magnet_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_magnet_la_LIBADD = $(common_libadd) $(LUA_LIBS) -lm
 mod_cml_la_SOURCES = mod_cml.c mod_cml_lua.c mod_cml_funcs.c
 mod_cml_la_CFLAGS = $(AM_CFLAGS) $(LUA_CFLAGS)
-mod_cml_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_cml_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_cml_la_LIBADD = $(MEMCACHE_LIB) $(common_libadd) $(LUA_LIBS) -lm
 mod_trigger_b4_dl_la_SOURCES = mod_trigger_b4_dl.c
-mod_trigger_b4_dl_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_trigger_b4_dl_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_trigger_b4_dl_la_LIBADD = $(GDBM_LIB) $(MEMCACHE_LIB) $(PCRE_LIB) $(common_libadd)
 mod_mysql_vhost_la_SOURCES = mod_mysql_vhost.c
-mod_mysql_vhost_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_mysql_vhost_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_mysql_vhost_la_LIBADD = $(MYSQL_LIBS) $(common_libadd)
 mod_mysql_vhost_la_CPPFLAGS = $(MYSQL_INCLUDE)
 mod_cgi_la_SOURCES = mod_cgi.c
-mod_cgi_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_cgi_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_cgi_la_LIBADD = $(common_libadd)
 mod_scgi_la_SOURCES = mod_scgi.c
-mod_scgi_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_scgi_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_scgi_la_LIBADD = $(common_libadd)
 mod_staticfile_la_SOURCES = mod_staticfile.c
-mod_staticfile_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_staticfile_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_staticfile_la_LIBADD = $(common_libadd)
 mod_dirlisting_la_SOURCES = mod_dirlisting.c
-mod_dirlisting_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_dirlisting_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_dirlisting_la_LIBADD = $(common_libadd) $(PCRE_LIB)
 mod_indexfile_la_SOURCES = mod_indexfile.c
-mod_indexfile_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_indexfile_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_indexfile_la_LIBADD = $(common_libadd)
 mod_setenv_la_SOURCES = mod_setenv.c
-mod_setenv_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_setenv_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_setenv_la_LIBADD = $(common_libadd)
 mod_alias_la_SOURCES = mod_alias.c
-mod_alias_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_alias_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_alias_la_LIBADD = $(common_libadd)
 mod_userdir_la_SOURCES = mod_userdir.c
-mod_userdir_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_userdir_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_userdir_la_LIBADD = $(common_libadd)
 mod_rrdtool_la_SOURCES = mod_rrdtool.c
-mod_rrdtool_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_rrdtool_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_rrdtool_la_LIBADD = $(common_libadd)
 mod_usertrack_la_SOURCES = mod_usertrack.c
-mod_usertrack_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_usertrack_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_usertrack_la_LIBADD = $(common_libadd)
 mod_proxy_la_SOURCES = mod_proxy.c
-mod_proxy_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_proxy_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_proxy_la_LIBADD = $(common_libadd)
 mod_ssi_la_SOURCES = mod_ssi_exprparser.c mod_ssi_expr.c mod_ssi.c
-mod_ssi_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_ssi_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_ssi_la_LIBADD = $(common_libadd) $(PCRE_LIB)
 mod_secdownload_la_SOURCES = mod_secure_download.c
-mod_secdownload_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_secdownload_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_secdownload_la_LIBADD = $(common_libadd)
 mod_expire_la_SOURCES = mod_expire.c
-mod_expire_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_expire_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_expire_la_LIBADD = $(common_libadd)
 mod_evhost_la_SOURCES = mod_evhost.c
-mod_evhost_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_evhost_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_evhost_la_LIBADD = $(common_libadd)
 mod_simple_vhost_la_SOURCES = mod_simple_vhost.c
-mod_simple_vhost_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_simple_vhost_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_simple_vhost_la_LIBADD = $(common_libadd)
 mod_fastcgi_la_SOURCES = mod_fastcgi.c
-mod_fastcgi_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_fastcgi_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_fastcgi_la_LIBADD = $(common_libadd)
 mod_extforward_la_SOURCES = mod_extforward.c
-mod_extforward_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_extforward_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_extforward_la_LIBADD = $(common_libadd)
 mod_access_la_SOURCES = mod_access.c
-mod_access_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_access_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_access_la_LIBADD = $(common_libadd)
 mod_compress_la_SOURCES = mod_compress.c
-mod_compress_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_compress_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_compress_la_LIBADD = $(Z_LIB) $(BZ_LIB) $(common_libadd)
 mod_auth_la_SOURCES = mod_auth.c http_auth.c
-mod_auth_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
-mod_auth_la_LIBADD = $(CRYPT_LIB) $(LDAP_LIB) $(LBER_LIB) $(common_libadd)
+mod_auth_la_LDFLAGS = -module -export-dynamic -avoid-version
+mod_auth_la_LIBADD = $(CRYPT_LIB) $(SSL_LIB) $(LDAP_LIB) $(LBER_LIB) $(common_libadd)
 mod_rewrite_la_SOURCES = mod_rewrite.c
-mod_rewrite_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_rewrite_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_rewrite_la_LIBADD = $(PCRE_LIB) $(common_libadd)
 mod_redirect_la_SOURCES = mod_redirect.c
-mod_redirect_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_redirect_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_redirect_la_LIBADD = $(PCRE_LIB) $(common_libadd)
 mod_status_la_SOURCES = mod_status.c
-mod_status_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_status_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_status_la_LIBADD = $(common_libadd)
 mod_accesslog_la_SOURCES = mod_accesslog.c
-mod_accesslog_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_accesslog_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_accesslog_la_LIBADD = $(common_libadd)
 hdr = server.h buffer.h network.h log.h keyvalue.h \
-      response.h request.h fastcgi.h chunk.h \
-      settings.h http_chunk.h \
-      md5.h http_auth.h stream.h \
-      fdevent.h connections.h base.h stat_cache.h \
-      plugin.h mod_auth.h \
-      etag.h joblist.h array.h crc32.h \
-      network_backends.h configfile.h bitset.h \
-      mod_ssi.h mod_ssi_expr.h inet_ntop_cache.h \
-      configparser.h mod_ssi_exprparser.h \
-      sys-mmap.h sys-socket.h mod_cml.h mod_cml_funcs.h \
-      splaytree.h proc_open.h status_counter.h \
-      mod_magnet_cache.h \
-      version.h
+	response.h request.h fastcgi.h chunk.h \
+	settings.h http_chunk.h \
+	md5.h http_auth.h stream.h \
+	fdevent.h connections.h base.h stat_cache.h \
+	plugin.h mod_auth.h \
+	etag.h joblist.h array.h crc32.h \
+	network_backends.h configfile.h \
+	mod_ssi.h mod_ssi_expr.h inet_ntop_cache.h \
+	configparser.h mod_ssi_exprparser.h \
+	sys-mmap.h sys-socket.h mod_cml.h mod_cml_funcs.h \
+	splaytree.h proc_open.h status_counter.h \
+	mod_magnet_cache.h \
+	version.h
 
 lighttpd_SOURCES = $(src)
-lighttpd_LDADD = $(PCRE_LIB) $(DL_LIB) $(SENDFILE_LIB) $(ATTR_LIB) $(common_libadd) $(SSL_LIB) $(FAM_LIBS) $(LIBEV_LIBS)
+lighttpd_LDADD = $(PCRE_LIB) $(DL_LIB) $(SENDFILE_LIB) $(ATTR_LIB) $(common_libadd) $(SSL_LIB) $(FAM_LIBS) $(LIBEV_LIBS) $(LIBUNWIND_LIBS)
 lighttpd_LDFLAGS = -export-dynamic
 lighttpd_CCPFLAGS = $(FAM_CFLAGS) $(LIBEV_CFLAGS)
 proc_open_SOURCES = proc_open.c buffer.c
+proc_open_LDADD = $(LIBUNWIND_LIBS)
 proc_open_CPPFLAGS = -DDEBUG_PROC_OPEN
 
 #gen_license_SOURCES = license.c md5.c buffer.c gen_license.c
@@ -846,7 +904,14 @@
 #bench_SOURCES = buffer.c bench.c
 #ajp_SOURCES = ajp.c
 noinst_HEADERS = $(hdr)
-EXTRA_DIST = mod_skeleton.c configparser.y mod_ssi_exprparser.y lempar.c SConscript
+EXTRA_DIST = \
+	mod_skeleton.c \
+	configparser.y \
+	mod_ssi_exprparser.y \
+	lempar.c \
+	SConscript \
+	CMakeLists.txt config.h.cmake
+
 all: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) all-am
 
@@ -882,6 +947,7 @@
 $(ACLOCAL_M4):  $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(am__aclocal_m4_deps):
+
 install-libLTLIBRARIES: $(lib_LTLIBRARIES)
 	@$(NORMAL_INSTALL)
 	@list='$(lib_LTLIBRARIES)'; test -n "$(libdir)" || list=; \
@@ -908,76 +974,111 @@
 
 clean-libLTLIBRARIES:
 	-test -z "$(lib_LTLIBRARIES)" || rm -f $(lib_LTLIBRARIES)
-	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
-	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
-	  test "$$dir" != "$$p" || dir=.; \
-	  echo "rm -f \"$${dir}/so_locations\""; \
-	  rm -f "$${dir}/so_locations"; \
-	done
+	@list='$(lib_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
+
 liblightcomp.la: $(liblightcomp_la_OBJECTS) $(liblightcomp_la_DEPENDENCIES) $(EXTRA_liblightcomp_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(liblightcomp_la_LINK) $(am_liblightcomp_la_rpath) $(liblightcomp_la_OBJECTS) $(liblightcomp_la_LIBADD) $(LIBS)
+
 mod_access.la: $(mod_access_la_OBJECTS) $(mod_access_la_DEPENDENCIES) $(EXTRA_mod_access_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_access_la_LINK) -rpath $(libdir) $(mod_access_la_OBJECTS) $(mod_access_la_LIBADD) $(LIBS)
+
 mod_accesslog.la: $(mod_accesslog_la_OBJECTS) $(mod_accesslog_la_DEPENDENCIES) $(EXTRA_mod_accesslog_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_accesslog_la_LINK) -rpath $(libdir) $(mod_accesslog_la_OBJECTS) $(mod_accesslog_la_LIBADD) $(LIBS)
+
 mod_alias.la: $(mod_alias_la_OBJECTS) $(mod_alias_la_DEPENDENCIES) $(EXTRA_mod_alias_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_alias_la_LINK) -rpath $(libdir) $(mod_alias_la_OBJECTS) $(mod_alias_la_LIBADD) $(LIBS)
+
 mod_auth.la: $(mod_auth_la_OBJECTS) $(mod_auth_la_DEPENDENCIES) $(EXTRA_mod_auth_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_auth_la_LINK) -rpath $(libdir) $(mod_auth_la_OBJECTS) $(mod_auth_la_LIBADD) $(LIBS)
+
 mod_cgi.la: $(mod_cgi_la_OBJECTS) $(mod_cgi_la_DEPENDENCIES) $(EXTRA_mod_cgi_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_cgi_la_LINK) -rpath $(libdir) $(mod_cgi_la_OBJECTS) $(mod_cgi_la_LIBADD) $(LIBS)
+
 mod_cml.la: $(mod_cml_la_OBJECTS) $(mod_cml_la_DEPENDENCIES) $(EXTRA_mod_cml_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_cml_la_LINK) -rpath $(libdir) $(mod_cml_la_OBJECTS) $(mod_cml_la_LIBADD) $(LIBS)
+
 mod_compress.la: $(mod_compress_la_OBJECTS) $(mod_compress_la_DEPENDENCIES) $(EXTRA_mod_compress_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_compress_la_LINK) -rpath $(libdir) $(mod_compress_la_OBJECTS) $(mod_compress_la_LIBADD) $(LIBS)
+
 mod_dirlisting.la: $(mod_dirlisting_la_OBJECTS) $(mod_dirlisting_la_DEPENDENCIES) $(EXTRA_mod_dirlisting_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_dirlisting_la_LINK) -rpath $(libdir) $(mod_dirlisting_la_OBJECTS) $(mod_dirlisting_la_LIBADD) $(LIBS)
+
 mod_evasive.la: $(mod_evasive_la_OBJECTS) $(mod_evasive_la_DEPENDENCIES) $(EXTRA_mod_evasive_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_evasive_la_LINK) -rpath $(libdir) $(mod_evasive_la_OBJECTS) $(mod_evasive_la_LIBADD) $(LIBS)
+
 mod_evhost.la: $(mod_evhost_la_OBJECTS) $(mod_evhost_la_DEPENDENCIES) $(EXTRA_mod_evhost_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_evhost_la_LINK) -rpath $(libdir) $(mod_evhost_la_OBJECTS) $(mod_evhost_la_LIBADD) $(LIBS)
+
 mod_expire.la: $(mod_expire_la_OBJECTS) $(mod_expire_la_DEPENDENCIES) $(EXTRA_mod_expire_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_expire_la_LINK) -rpath $(libdir) $(mod_expire_la_OBJECTS) $(mod_expire_la_LIBADD) $(LIBS)
+
 mod_extforward.la: $(mod_extforward_la_OBJECTS) $(mod_extforward_la_DEPENDENCIES) $(EXTRA_mod_extforward_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_extforward_la_LINK) -rpath $(libdir) $(mod_extforward_la_OBJECTS) $(mod_extforward_la_LIBADD) $(LIBS)
+
 mod_fastcgi.la: $(mod_fastcgi_la_OBJECTS) $(mod_fastcgi_la_DEPENDENCIES) $(EXTRA_mod_fastcgi_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_fastcgi_la_LINK) -rpath $(libdir) $(mod_fastcgi_la_OBJECTS) $(mod_fastcgi_la_LIBADD) $(LIBS)
+
 mod_flv_streaming.la: $(mod_flv_streaming_la_OBJECTS) $(mod_flv_streaming_la_DEPENDENCIES) $(EXTRA_mod_flv_streaming_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_flv_streaming_la_LINK) -rpath $(libdir) $(mod_flv_streaming_la_OBJECTS) $(mod_flv_streaming_la_LIBADD) $(LIBS)
+
 mod_indexfile.la: $(mod_indexfile_la_OBJECTS) $(mod_indexfile_la_DEPENDENCIES) $(EXTRA_mod_indexfile_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_indexfile_la_LINK) -rpath $(libdir) $(mod_indexfile_la_OBJECTS) $(mod_indexfile_la_LIBADD) $(LIBS)
+
 mod_magnet.la: $(mod_magnet_la_OBJECTS) $(mod_magnet_la_DEPENDENCIES) $(EXTRA_mod_magnet_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_magnet_la_LINK) -rpath $(libdir) $(mod_magnet_la_OBJECTS) $(mod_magnet_la_LIBADD) $(LIBS)
+
 mod_mysql_vhost.la: $(mod_mysql_vhost_la_OBJECTS) $(mod_mysql_vhost_la_DEPENDENCIES) $(EXTRA_mod_mysql_vhost_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_mysql_vhost_la_LINK) -rpath $(libdir) $(mod_mysql_vhost_la_OBJECTS) $(mod_mysql_vhost_la_LIBADD) $(LIBS)
+
 mod_proxy.la: $(mod_proxy_la_OBJECTS) $(mod_proxy_la_DEPENDENCIES) $(EXTRA_mod_proxy_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_proxy_la_LINK) -rpath $(libdir) $(mod_proxy_la_OBJECTS) $(mod_proxy_la_LIBADD) $(LIBS)
+
 mod_redirect.la: $(mod_redirect_la_OBJECTS) $(mod_redirect_la_DEPENDENCIES) $(EXTRA_mod_redirect_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_redirect_la_LINK) -rpath $(libdir) $(mod_redirect_la_OBJECTS) $(mod_redirect_la_LIBADD) $(LIBS)
+
 mod_rewrite.la: $(mod_rewrite_la_OBJECTS) $(mod_rewrite_la_DEPENDENCIES) $(EXTRA_mod_rewrite_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_rewrite_la_LINK) -rpath $(libdir) $(mod_rewrite_la_OBJECTS) $(mod_rewrite_la_LIBADD) $(LIBS)
+
 mod_rrdtool.la: $(mod_rrdtool_la_OBJECTS) $(mod_rrdtool_la_DEPENDENCIES) $(EXTRA_mod_rrdtool_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_rrdtool_la_LINK) -rpath $(libdir) $(mod_rrdtool_la_OBJECTS) $(mod_rrdtool_la_LIBADD) $(LIBS)
+
 mod_scgi.la: $(mod_scgi_la_OBJECTS) $(mod_scgi_la_DEPENDENCIES) $(EXTRA_mod_scgi_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_scgi_la_LINK) -rpath $(libdir) $(mod_scgi_la_OBJECTS) $(mod_scgi_la_LIBADD) $(LIBS)
+
 mod_secdownload.la: $(mod_secdownload_la_OBJECTS) $(mod_secdownload_la_DEPENDENCIES) $(EXTRA_mod_secdownload_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_secdownload_la_LINK) -rpath $(libdir) $(mod_secdownload_la_OBJECTS) $(mod_secdownload_la_LIBADD) $(LIBS)
+
 mod_setenv.la: $(mod_setenv_la_OBJECTS) $(mod_setenv_la_DEPENDENCIES) $(EXTRA_mod_setenv_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_setenv_la_LINK) -rpath $(libdir) $(mod_setenv_la_OBJECTS) $(mod_setenv_la_LIBADD) $(LIBS)
+
 mod_simple_vhost.la: $(mod_simple_vhost_la_OBJECTS) $(mod_simple_vhost_la_DEPENDENCIES) $(EXTRA_mod_simple_vhost_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_simple_vhost_la_LINK) -rpath $(libdir) $(mod_simple_vhost_la_OBJECTS) $(mod_simple_vhost_la_LIBADD) $(LIBS)
+
 mod_ssi.la: $(mod_ssi_la_OBJECTS) $(mod_ssi_la_DEPENDENCIES) $(EXTRA_mod_ssi_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_ssi_la_LINK) -rpath $(libdir) $(mod_ssi_la_OBJECTS) $(mod_ssi_la_LIBADD) $(LIBS)
+
 mod_staticfile.la: $(mod_staticfile_la_OBJECTS) $(mod_staticfile_la_DEPENDENCIES) $(EXTRA_mod_staticfile_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_staticfile_la_LINK) -rpath $(libdir) $(mod_staticfile_la_OBJECTS) $(mod_staticfile_la_LIBADD) $(LIBS)
+
 mod_status.la: $(mod_status_la_OBJECTS) $(mod_status_la_DEPENDENCIES) $(EXTRA_mod_status_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_status_la_LINK) -rpath $(libdir) $(mod_status_la_OBJECTS) $(mod_status_la_LIBADD) $(LIBS)
+
 mod_trigger_b4_dl.la: $(mod_trigger_b4_dl_la_OBJECTS) $(mod_trigger_b4_dl_la_DEPENDENCIES) $(EXTRA_mod_trigger_b4_dl_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_trigger_b4_dl_la_LINK) -rpath $(libdir) $(mod_trigger_b4_dl_la_OBJECTS) $(mod_trigger_b4_dl_la_LIBADD) $(LIBS)
+
 mod_userdir.la: $(mod_userdir_la_OBJECTS) $(mod_userdir_la_DEPENDENCIES) $(EXTRA_mod_userdir_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_userdir_la_LINK) -rpath $(libdir) $(mod_userdir_la_OBJECTS) $(mod_userdir_la_LIBADD) $(LIBS)
+
 mod_usertrack.la: $(mod_usertrack_la_OBJECTS) $(mod_usertrack_la_DEPENDENCIES) $(EXTRA_mod_usertrack_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_usertrack_la_LINK) -rpath $(libdir) $(mod_usertrack_la_OBJECTS) $(mod_usertrack_la_LIBADD) $(LIBS)
+
 mod_webdav.la: $(mod_webdav_la_OBJECTS) $(mod_webdav_la_DEPENDENCIES) $(EXTRA_mod_webdav_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_webdav_la_LINK) -rpath $(libdir) $(mod_webdav_la_OBJECTS) $(mod_webdav_la_LIBADD) $(LIBS)
 
@@ -998,10 +1099,12 @@
 	fi; \
 	for p in $$list; do echo "$$p $$p"; done | \
 	sed 's/$(EXEEXT)$$//' | \
-	while read p p1; do if test -f $$p || test -f $$p1; \
-	  then echo "$$p"; echo "$$p"; else :; fi; \
+	while read p p1; do if test -f $$p \
+	 || test -f $$p1 \
+	  ; then echo "$$p"; echo "$$p"; else :; fi; \
 	done | \
-	sed -e 'p;s,.*/,,;n;h' -e 's|.*|.|' \
+	sed -e 'p;s,.*/,,;n;h' \
+	    -e 's|.*|.|' \
 	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
 	sed 'N;N;N;s,\n, ,g' | \
 	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \
@@ -1022,7 +1125,8 @@
 	@list='$(sbin_PROGRAMS)'; test -n "$(sbindir)" || list=; \
 	files=`for p in $$list; do echo "$$p"; done | \
 	  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \
-	      -e 's/$$/$(EXEEXT)/' `; \
+	      -e 's/$$/$(EXEEXT)/' \
+	`; \
 	test -n "$$list" || exit 0; \
 	echo " ( cd '$(DESTDIR)$(sbindir)' && rm -f" $$files ")"; \
 	cd "$(DESTDIR)$(sbindir)" && rm -f $$files
@@ -1035,15 +1139,19 @@
 	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
 	echo " rm -f" $$list; \
 	rm -f $$list
+
 lemon$(EXEEXT): $(lemon_OBJECTS) $(lemon_DEPENDENCIES) $(EXTRA_lemon_DEPENDENCIES) 
 	@rm -f lemon$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(lemon_OBJECTS) $(lemon_LDADD) $(LIBS)
+
 lighttpd$(EXEEXT): $(lighttpd_OBJECTS) $(lighttpd_DEPENDENCIES) $(EXTRA_lighttpd_DEPENDENCIES) 
 	@rm -f lighttpd$(EXEEXT)
 	$(AM_V_CCLD)$(lighttpd_LINK) $(lighttpd_OBJECTS) $(lighttpd_LDADD) $(LIBS)
+
 lighttpd-angel$(EXEEXT): $(lighttpd_angel_OBJECTS) $(lighttpd_angel_DEPENDENCIES) $(EXTRA_lighttpd_angel_DEPENDENCIES) 
 	@rm -f lighttpd-angel$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(lighttpd_angel_OBJECTS) $(lighttpd_angel_LDADD) $(LIBS)
+
 proc_open$(EXEEXT): $(proc_open_OBJECTS) $(proc_open_DEPENDENCIES) $(EXTRA_proc_open_DEPENDENCIES) 
 	@rm -f proc_open$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(proc_open_OBJECTS) $(proc_open_LDADD) $(LIBS)
@@ -1055,7 +1163,6 @@
 	-rm -f *.tab.c
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/array.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bitset.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/buffer.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/chunk.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/configfile-glue.Po@am__quote@
@@ -1087,7 +1194,6 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/keyvalue.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lemon.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liblightcomp_la-array.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liblightcomp_la-bitset.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liblightcomp_la-buffer.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liblightcomp_la-chunk.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liblightcomp_la-configfile-glue.Plo@am__quote@
@@ -1190,14 +1296,14 @@
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c $<
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
 
 .c.obj:
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c `$(CYGPATH_W) '$<'`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
 .c.lo:
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
@@ -1388,13 +1494,6 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(liblightcomp_la_CFLAGS) $(CFLAGS) -c -o liblightcomp_la-data_config.lo `test -f 'data_config.c' || echo '$(srcdir)/'`data_config.c
 
-liblightcomp_la-bitset.lo: bitset.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(liblightcomp_la_CFLAGS) $(CFLAGS) -MT liblightcomp_la-bitset.lo -MD -MP -MF $(DEPDIR)/liblightcomp_la-bitset.Tpo -c -o liblightcomp_la-bitset.lo `test -f 'bitset.c' || echo '$(srcdir)/'`bitset.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/liblightcomp_la-bitset.Tpo $(DEPDIR)/liblightcomp_la-bitset.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='bitset.c' object='liblightcomp_la-bitset.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(liblightcomp_la_CFLAGS) $(CFLAGS) -c -o liblightcomp_la-bitset.lo `test -f 'bitset.c' || echo '$(srcdir)/'`bitset.c
-
 liblightcomp_la-inet_ntop_cache.lo: inet_ntop_cache.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(liblightcomp_la_CFLAGS) $(CFLAGS) -MT liblightcomp_la-inet_ntop_cache.lo -MD -MP -MF $(DEPDIR)/liblightcomp_la-inet_ntop_cache.Tpo -c -o liblightcomp_la-inet_ntop_cache.lo `test -f 'inet_ntop_cache.c' || echo '$(srcdir)/'`inet_ntop_cache.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/liblightcomp_la-inet_ntop_cache.Tpo $(DEPDIR)/liblightcomp_la-inet_ntop_cache.Plo
@@ -1569,26 +1668,15 @@
 clean-libtool:
 	-rm -rf .libs _libs
 
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
 
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -1600,15 +1688,11 @@
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -1617,6 +1701,21 @@
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
@@ -1766,20 +1865,20 @@
 
 .MAKE: all check install install-am install-strip
 
-.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
 	clean-libLTLIBRARIES clean-libtool clean-noinstPROGRAMS \
-	clean-sbinPROGRAMS ctags distclean distclean-compile \
-	distclean-generic distclean-libtool distclean-tags distdir dvi \
-	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-dvi install-dvi-am \
-	install-exec install-exec-am install-html install-html-am \
-	install-info install-info-am install-libLTLIBRARIES \
-	install-man install-pdf install-pdf-am install-ps \
-	install-ps-am install-sbinPROGRAMS install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
+	clean-sbinPROGRAMS cscopelist-am ctags ctags-am distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am \
+	install-libLTLIBRARIES install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-sbinPROGRAMS install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
 	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-libLTLIBRARIES \
+	tags tags-am uninstall uninstall-am uninstall-libLTLIBRARIES \
 	uninstall-sbinPROGRAMS
 
 
diff -u lighttpd-1.4.32/src/mod_access.c lighttpd-1.4.36/src/mod_access.c
--- lighttpd-1.4.32/src/mod_access.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/mod_access.c	2015-07-26 05:36:36.000000000 -0500
@@ -40,6 +40,8 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
+			if (NULL == s) continue;
+
 			array_free(s->access_deny);
 
 			free(s);
@@ -61,7 +63,7 @@
 		{ NULL,                          NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
 	};
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -125,25 +127,25 @@
 	int s_len;
 	size_t k;
 
-	if (con->uri.path->used == 0) return HANDLER_GO_ON;
+	if (buffer_is_empty(con->uri.path)) return HANDLER_GO_ON;
 
 	mod_access_patch_connection(srv, con, p);
 
-	s_len = con->uri.path->used - 1;
+	s_len = buffer_string_length(con->uri.path);
 
 	if (con->conf.log_request_handling) {
- 		log_error_write(srv, __FILE__, __LINE__, "s", 
+		log_error_write(srv, __FILE__, __LINE__, "s",
 				"-- mod_access_uri_handler called");
 	}
 
 	for (k = 0; k < p->conf.access_deny->used; k++) {
 		data_string *ds = (data_string *)p->conf.access_deny->data[k];
-		int ct_len = ds->value->used - 1;
+		int ct_len = buffer_string_length(ds->value);
 		int denied = 0;
 
 
 		if (ct_len > s_len) continue;
-		if (ds->value->used == 0) continue;
+		if (buffer_is_empty(ds->value)) continue;
 
 		/* if we have a case-insensitive FS we have to lower-case the URI here too */
 
diff -u lighttpd-1.4.32/src/mod_accesslog.c lighttpd-1.4.36/src/mod_accesslog.c
--- lighttpd-1.4.32/src/mod_accesslog.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.36/src/mod_accesslog.c	2015-07-26 05:36:36.000000000 -0500
@@ -124,16 +124,17 @@
 
 typedef struct {
 	buffer *access_logfile;
-	buffer *format;
-	unsigned short use_syslog;
+	int    log_access_fd;
+	buffer *access_logbuffer; /* each logfile has a separate buffer */
 
+	unsigned short use_syslog; /* syslog has global buffer */
+	unsigned short syslog_level;
+
+	buffer *format;
 
-	int    log_access_fd;
 	time_t last_generated_accesslog_ts;
 	time_t *last_generated_accesslog_ts_ptr;
 
-
-	buffer *access_logbuffer;
 	buffer *ts_accesslog_str;
 	buffer *ts_accesslog_fmt_str;
 	unsigned short append_tz_offset;
@@ -146,12 +147,15 @@
 
 	plugin_config **config_storage;
 	plugin_config conf;
+
+	buffer *syslog_logbuffer; /* syslog has global buffer. no caching, always written directly */
 } plugin_data;
 
 INIT_FUNC(mod_accesslog_init) {
 	plugin_data *p;
 
 	p = calloc(1, sizeof(*p));
+	p->syslog_logbuffer = buffer_init();
 
 	return p;
 }
@@ -161,11 +165,11 @@
 
 	/* replaces non-printable chars with \xHH where HH is the hex representation of the byte */
 	/* exceptions: " => \", \ => \\, whitespace chars => \n \t etc. */
-	if (str->used == 0) return;
-	buffer_prepare_append(dest, str->used - 1);
+	if (buffer_string_is_empty(str)) return;
+	buffer_string_prepare_append(dest, buffer_string_length(str));
 
-	for (ptr = start = str->ptr, end = str->ptr + str->used - 1; ptr < end; ptr++) {
-		char const c = *ptr;
+	for (ptr = start = str->ptr, end = str->ptr + buffer_string_length(str); ptr < end; ptr++) {
+		unsigned char const c = (unsigned char) *ptr;
 		if (c >= ' ' && c <= '~' && c != '"' && c != '\\') {
 			/* nothing to change, add later as one block */
 		} else {
@@ -219,9 +223,9 @@
 static int accesslog_parse_format(server *srv, format_fields *fields, buffer *format) {
 	size_t i, j, k = 0, start = 0;
 
-	if (format->used == 0) return -1;
+	if (buffer_is_empty(format)) return -1;
 
-	for (i = 0; i < format->used - 1; i++) {
+	for (i = 0; i < buffer_string_length(format); i++) {
 		switch(format->ptr[i]) {
 		case '%':
 			if (i > 0 && start != i) {
@@ -293,11 +297,11 @@
 			case '{':
 				/* go forward to } */
 
-				for (k = i+2; k < format->used - 1; k++) {
+				for (k = i+2; k < buffer_string_length(format); k++) {
 					if (format->ptr[k] == '}') break;
 				}
 
-				if (k == format->used - 1) {
+				if (k == buffer_string_length(format)) {
 					log_error_write(srv, __FILE__, __LINE__, "s", "%{ has to be terminated by a }");
 					return -1;
 				}
@@ -410,17 +414,11 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
-			if (!s) continue;
+			if (NULL == s) continue;
 
-			if (s->access_logbuffer->used) {
-				if (s->use_syslog) {
-# ifdef HAVE_SYSLOG_H
-					if (s->access_logbuffer->used > 2) {
-						syslog(LOG_INFO, "%*s", (int) s->access_logbuffer->used - 2, s->access_logbuffer->ptr);
-					}
-# endif
-				} else if (s->log_access_fd != -1) {
-					write(s->log_access_fd, s->access_logbuffer->ptr, s->access_logbuffer->used - 1);
+			if (!buffer_string_is_empty(s->access_logbuffer)) {
+				if (s->log_access_fd != -1) {
+					write(s->log_access_fd, CONST_BUF_LEN(s->access_logbuffer));
 				}
 			}
 
@@ -448,6 +446,7 @@
 		free(p->config_storage);
 	}
 
+	if (p->syslog_logbuffer) buffer_free(p->syslog_logbuffer);
 	free(p);
 
 	return HANDLER_GO_ON;
@@ -461,12 +460,13 @@
 		{ "accesslog.filename",             NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },
 		{ "accesslog.use-syslog",           NULL, T_CONFIG_BOOLEAN, T_CONFIG_SCOPE_CONNECTION },
 		{ "accesslog.format",               NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },
+		{ "accesslog.syslog-level",         NULL, T_CONFIG_SHORT, T_CONFIG_SCOPE_CONNECTION },
 		{ NULL,                             NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
 	};
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -480,11 +480,13 @@
 		s->log_access_fd = -1;
 		s->last_generated_accesslog_ts = 0;
 		s->last_generated_accesslog_ts_ptr = &(s->last_generated_accesslog_ts);
+		s->syslog_level = LOG_INFO;
 
 
 		cv[0].destination = s->access_logfile;
 		cv[1].destination = &(s->use_syslog);
 		cv[2].destination = s->format;
+		cv[3].destination = &(s->syslog_level);
 
 		p->config_storage[i] = s;
 
@@ -492,7 +494,7 @@
 			return HANDLER_ERROR;
 		}
 
-		if (i == 0 && buffer_is_empty(s->format)) {
+		if (i == 0 && buffer_string_is_empty(s->format)) {
 			/* set a default logfile string */
 
 			buffer_copy_string_len(s->format, CONST_STR_LEN("%h %V %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\""));
@@ -500,7 +502,7 @@
 
 		/* parse */
 
-		if (s->format->used) {
+		if (!buffer_is_empty(s->format)) {
 			size_t j, count;
 
 			s->parsed_format = calloc(1, sizeof(*(s->parsed_format)));
@@ -521,7 +523,7 @@
 			for (j = 0; j < s->parsed_format->used; j++) {
 				if (FIELD_FORMAT == s->parsed_format->ptr[j]->type) {
 					if (FORMAT_TIMESTAMP == s->parsed_format->ptr[j]->field) {
-						if (!buffer_is_empty(s->parsed_format->ptr[j]->string)) {
+						if (!buffer_string_is_empty(s->parsed_format->ptr[j]->string)) {
 							buffer_copy_string(s->ts_accesslog_fmt_str, s->parsed_format->ptr[j]->string->ptr);
 						}
 
@@ -556,7 +558,7 @@
 		}
 
 		s->append_tz_offset = 0;
-		if (buffer_is_empty(s->ts_accesslog_fmt_str)) {
+		if (buffer_string_is_empty(s->ts_accesslog_fmt_str)) {
 #if defined(HAVE_STRUCT_TM_GMTOFF)
 			BUFFER_COPY_STRING_CONST(s->ts_accesslog_fmt_str, "[%d/%b/%Y:%H:%M:%S ");
 			s->append_tz_offset = 1;
@@ -570,7 +572,7 @@
 			continue;
 		}
 
-		if (s->access_logfile->used < 2) continue;
+		if (buffer_string_is_empty(s->access_logfile)) continue;
 
 		if (-1 == (s->log_access_fd = open_logfile_or_pipe(srv, s->access_logfile->ptr)))
 			return HANDLER_ERROR;
@@ -589,26 +591,19 @@
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s = p->config_storage[i];
 
-		if (s->access_logbuffer->used) {
-			if (s->use_syslog) {
-#ifdef HAVE_SYSLOG_H
-				if (s->access_logbuffer->used > 2) {
-					/* syslog appends a \n on its own */
-					syslog(LOG_INFO, "%*s", (int) s->access_logbuffer->used - 2, s->access_logbuffer->ptr);
-				}
-#endif
-			} else if (s->log_access_fd != -1) {
-				write(s->log_access_fd, s->access_logbuffer->ptr, s->access_logbuffer->used - 1);
+		if (!buffer_string_is_empty(s->access_logbuffer)) {
+			if (s->log_access_fd != -1) {
+				write(s->log_access_fd, CONST_BUF_LEN(s->access_logbuffer));
 			}
 
 			buffer_reset(s->access_logbuffer);
 		}
 
-		if (s->use_syslog == 0 &&
-		    s->access_logfile->used > 1 &&
-		    s->access_logfile->ptr[0] != '|') {
+		if (s->use_syslog == 0
+			&& !buffer_string_is_empty(s->access_logfile)
+			&& s->access_logfile->ptr[0] != '|') {
 
-			close(s->log_access_fd);
+			if (-1 != s->log_access_fd) close(s->log_access_fd);
 
 			if (-1 == (s->log_access_fd =
 				   open(s->access_logfile->ptr, O_APPEND | O_WRONLY | O_CREAT | O_LARGEFILE, 0644))) {
@@ -617,9 +612,7 @@
 
 				return HANDLER_ERROR;
 			}
-#ifdef FD_CLOEXEC
-			fcntl(s->log_access_fd, F_SETFD, FD_CLOEXEC);
-#endif
+			fd_close_on_exec(s->log_access_fd);
 		}
 	}
 
@@ -642,6 +635,7 @@
 	PATCH(append_tz_offset);
 	PATCH(parsed_format);
 	PATCH(use_syslog);
+	PATCH(syslog_level);
 
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -668,7 +662,8 @@
 				PATCH(append_tz_offset);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("accesslog.use-syslog"))) {
 				PATCH(use_syslog);
-				PATCH(access_logbuffer);
+			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("accesslog.syslog-level"))) {
+				PATCH(syslog_level);
 			}
 		}
 	}
@@ -690,9 +685,14 @@
 	/* No output device, nothing to do */
 	if (!p->conf.use_syslog && p->conf.log_access_fd == -1) return HANDLER_GO_ON;
 
-	b = p->conf.access_logbuffer;
-	if (b->used == 0) {
-		buffer_copy_string_len(b, CONST_STR_LEN(""));
+	if (p->conf.use_syslog) {
+		b = p->syslog_logbuffer;
+	} else {
+		b = p->conf.access_logbuffer;
+	}
+
+	if (buffer_is_empty(b)) {
+		buffer_string_set_length(b, 0);
 	}
 
 	for (j = 0; j < p->conf.parsed_format->used; j++) {
@@ -711,15 +711,14 @@
 					long scd, hrs, min;
 #endif
 
-					buffer_prepare_copy(p->conf.ts_accesslog_str, 255);
+					buffer_string_prepare_copy(p->conf.ts_accesslog_str, 255);
 #if defined(HAVE_STRUCT_TM_GMTOFF)
 # ifdef HAVE_LOCALTIME_R
 					localtime_r(&(srv->cur_ts), &tm);
-					strftime(p->conf.ts_accesslog_str->ptr, p->conf.ts_accesslog_str->size - 1, p->conf.ts_accesslog_fmt_str->ptr, &tm);
+					buffer_append_strftime(p->conf.ts_accesslog_str, p->conf.ts_accesslog_fmt_str->ptr, &tm);
 # else /* HAVE_LOCALTIME_R */
-					strftime(p->conf.ts_accesslog_str->ptr, p->conf.ts_accesslog_str->size - 1, p->conf.ts_accesslog_fmt_str->ptr, localtime_r(&(srv->cur_ts)));
+					buffer_append_strftime(p->conf.ts_accesslog_str, p->conf.ts_accesslog_fmt_str->ptr, localtime(&(srv->cur_ts)));
 # endif /* HAVE_LOCALTIME_R */
-					p->conf.ts_accesslog_str->used = strlen(p->conf.ts_accesslog_str->ptr) + 1;
 
 					if (p->conf.append_tz_offset) {
 						buffer_append_string_len(p->conf.ts_accesslog_str, tm.tm_gmtoff >= 0 ? "+" : "-", 1);
@@ -730,20 +729,19 @@
 
 						/* hours */
 						if (hrs < 10) buffer_append_string_len(p->conf.ts_accesslog_str, CONST_STR_LEN("0"));
-						buffer_append_long(p->conf.ts_accesslog_str, hrs);
+						buffer_append_int(p->conf.ts_accesslog_str, hrs);
 
 						if (min < 10) buffer_append_string_len(p->conf.ts_accesslog_str, CONST_STR_LEN("0"));
-						buffer_append_long(p->conf.ts_accesslog_str, min);
+						buffer_append_int(p->conf.ts_accesslog_str, min);
 						buffer_append_string_len(p->conf.ts_accesslog_str, CONST_STR_LEN("]"));
 					}
 #else /* HAVE_STRUCT_TM_GMTOFF */
 # ifdef HAVE_GMTIME_R
 					gmtime_r(&(srv->cur_ts), &tm);
-					strftime(p->conf.ts_accesslog_str->ptr, p->conf.ts_accesslog_str->size - 1, p->conf.ts_accesslog_fmt_str->ptr, &tm);
+					buffer_append_strftime(p->conf.ts_accesslog_str, p->conf.ts_accesslog_fmt_str->ptr, &tm);
 # else /* HAVE_GMTIME_R */
-					strftime(p->conf.ts_accesslog_str->ptr, p->conf.ts_accesslog_str->size - 1, p->conf.ts_accesslog_fmt_str->ptr, gmtime(&(srv->cur_ts)));
+					buffer_append_strftime(p->conf.ts_accesslog_str, p->conf.ts_accesslog_fmt_str->ptr, gmtime(&(srv->cur_ts)));
 # endif /* HAVE_GMTIME_R */
-					p->conf.ts_accesslog_str->used = strlen(p->conf.ts_accesslog_str->ptr) + 1;
 #endif /* HAVE_STRUCT_TM_GMTOFF */
 
 					*(p->conf.last_generated_accesslog_ts_ptr) = srv->cur_ts;
@@ -765,24 +763,24 @@
 				buffer_append_string_len(b, CONST_STR_LEN("-"));
 				break;
 			case FORMAT_REMOTE_USER:
-				if (con->authed_user->used > 1) {
-					buffer_append_string_buffer(b, con->authed_user);
+				if (NULL != (ds = (data_string *)array_get_element(con->environment, "REMOTE_USER")) && !buffer_string_is_empty(ds->value)) {
+					accesslog_append_escaped(b, ds->value);
 				} else {
 					buffer_append_string_len(b, CONST_STR_LEN("-"));
 				}
 				break;
 			case FORMAT_REQUEST_LINE:
-				if (con->request.request_line->used) {
+				if (!buffer_string_is_empty(con->request.request_line)) {
 					accesslog_append_escaped(b, con->request.request_line);
 				}
 				break;
 			case FORMAT_STATUS:
-				buffer_append_long(b, con->http_status);
+				buffer_append_int(b, con->http_status);
 				break;
 
 			case FORMAT_BYTES_OUT_NO_HEADER:
 				if (con->bytes_written > 0) {
-					buffer_append_off_t(b,
+					buffer_append_int(b,
 							    con->bytes_written - con->bytes_header <= 0 ? 0 : con->bytes_written - con->bytes_header);
 				} else {
 					buffer_append_string_len(b, CONST_STR_LEN("-"));
@@ -810,7 +808,7 @@
 				}
 				break;
 			case FORMAT_FILENAME:
-				if (con->physical.path->used > 1) {
+				if (!buffer_string_is_empty(con->physical.path)) {
 					buffer_append_string_buffer(b, con->physical.path);
 				} else {
 					buffer_append_string_len(b, CONST_STR_LEN("-"));
@@ -818,30 +816,30 @@
 				break;
 			case FORMAT_BYTES_OUT:
 				if (con->bytes_written > 0) {
-					buffer_append_off_t(b, con->bytes_written);
+					buffer_append_int(b, con->bytes_written);
 				} else {
 					buffer_append_string_len(b, CONST_STR_LEN("-"));
 				}
 				break;
 			case FORMAT_BYTES_IN:
 				if (con->bytes_read > 0) {
-					buffer_append_off_t(b, con->bytes_read);
+					buffer_append_int(b, con->bytes_read);
 				} else {
 					buffer_append_string_len(b, CONST_STR_LEN("-"));
 				}
 				break;
 			case FORMAT_TIME_USED:
-				buffer_append_long(b, srv->cur_ts - con->request_start);
+				buffer_append_int(b, srv->cur_ts - con->request_start);
 				break;
 			case FORMAT_SERVER_NAME:
-				if (con->server_name->used > 1) {
+				if (!buffer_string_is_empty(con->server_name)) {
 					buffer_append_string_buffer(b, con->server_name);
 				} else {
 					buffer_append_string_len(b, CONST_STR_LEN("-"));
 				}
 				break;
 			case FORMAT_HTTP_HOST:
-				if (con->uri.authority->used > 1) {
+				if (!buffer_string_is_empty(con->uri.authority)) {
 					accesslog_append_escaped(b, con->uri.authority);
 				} else {
 					buffer_append_string_len(b, CONST_STR_LEN("-"));
@@ -849,7 +847,7 @@
 				break;
 			case FORMAT_REQUEST_PROTOCOL:
 				buffer_append_string_len(b,
-						     con->request.http_version == HTTP_VERSION_1_1 ? "HTTP/1.1" : "HTTP/1.0", 8);
+					con->request.http_version == HTTP_VERSION_1_1 ? "HTTP/1.1" : "HTTP/1.0", 8);
 				break;
 			case FORMAT_REQUEST_METHOD:
 				buffer_append_string(b, get_http_method_name(con->request.http_method));
@@ -869,7 +867,7 @@
 					if (colon) {
 						buffer_append_string(b, colon+1);
 					} else {
-						buffer_append_long(b, srv->srvconf.port);
+						buffer_append_int(b, srv->srvconf.port);
 					}
 				}
 				break;
@@ -904,18 +902,19 @@
 	buffer_append_string_len(b, CONST_STR_LEN("\n"));
 
 	if (p->conf.use_syslog ||  /* syslog doesn't cache */
-	    (p->conf.access_logfile->used && p->conf.access_logfile->ptr[0] == '|') || /* pipes don't cache */
+	    (!buffer_string_is_empty(p->conf.access_logfile) && p->conf.access_logfile->ptr[0] == '|') || /* pipes don't cache */
 	    newts ||
-	    b->used > BUFFER_MAX_REUSE_SIZE) {
+	    buffer_string_length(b) >= BUFFER_MAX_REUSE_SIZE) {
 		if (p->conf.use_syslog) {
 #ifdef HAVE_SYSLOG_H
-			if (b->used > 2) {
+			if (!buffer_string_is_empty(b)) {
 				/* syslog appends a \n on its own */
-				syslog(LOG_INFO, "%*s", (int) b->used - 2, b->ptr);
+				buffer_string_set_length(b, buffer_string_length(b) - 1);
+				syslog(p->conf.syslog_level, "%s", b->ptr);
 			}
 #endif
 		} else if (p->conf.log_access_fd != -1) {
-			write(p->conf.log_access_fd, b->ptr, b->used - 1);
+			write(p->conf.log_access_fd, CONST_BUF_LEN(b));
 		}
 		buffer_reset(b);
 	}
diff -u lighttpd-1.4.32/src/mod_alias.c lighttpd-1.4.36/src/mod_alias.c
--- lighttpd-1.4.32/src/mod_alias.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/mod_alias.c	2015-07-26 05:36:36.000000000 -0500
@@ -45,7 +45,7 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
-			if(!s) continue;
+			if (NULL == s) continue;
 
 			array_free(s->alias);
 
@@ -72,7 +72,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -95,10 +95,10 @@
 				for (k = j + 1; k < a->used; k ++) {
 					const buffer *key = a->data[a->sorted[k]]->key;
 
-					if (key->used < prefix->used) {
+					if (buffer_string_length(key) < buffer_string_length(prefix)) {
 						break;
 					}
-					if (memcmp(key->ptr, prefix->ptr, prefix->used - 1) != 0) {
+					if (memcmp(key->ptr, prefix->ptr, buffer_string_length(prefix)) != 0) {
 						break;
 					}
 					/* ok, they have same prefix. check position */
@@ -151,31 +151,32 @@
 	char *uri_ptr;
 	size_t k;
 
-	if (con->physical.path->used == 0) return HANDLER_GO_ON;
+	if (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;
 
 	mod_alias_patch_connection(srv, con, p);
 
 	/* not to include the tailing slash */
-	basedir_len = (con->physical.basedir->used - 1) - 1;
-	uri_len = con->physical.path->used - 1 - basedir_len;
+	basedir_len = buffer_string_length(con->physical.basedir);
+	if ('/' == con->physical.basedir->ptr[basedir_len-1]) --basedir_len;
+	uri_len = buffer_string_length(con->physical.path) - basedir_len;
 	uri_ptr = con->physical.path->ptr + basedir_len;
 
 	for (k = 0; k < p->conf.alias->used; k++) {
 		data_string *ds = (data_string *)p->conf.alias->data[k];
-		int alias_len = ds->key->used - 1;
+		int alias_len = buffer_string_length(ds->key);
 
 		if (alias_len > uri_len) continue;
-		if (ds->key->used == 0) continue;
+		if (buffer_is_empty(ds->key)) continue;
 
 		if (0 == (con->conf.force_lowercase_filenames ?
 					strncasecmp(uri_ptr, ds->key->ptr, alias_len) :
 					strncmp(uri_ptr, ds->key->ptr, alias_len))) {
 			/* matched */
 
-			buffer_copy_string_buffer(con->physical.basedir, ds->value);
-			buffer_copy_string_buffer(srv->tmp_buf, ds->value);
+			buffer_copy_buffer(con->physical.basedir, ds->value);
+			buffer_copy_buffer(srv->tmp_buf, ds->value);
 			buffer_append_string(srv->tmp_buf, uri_ptr + alias_len);
-			buffer_copy_string_buffer(con->physical.path, srv->tmp_buf);
+			buffer_copy_buffer(con->physical.path, srv->tmp_buf);
 
 			return HANDLER_GO_ON;
 		}
diff -u lighttpd-1.4.32/src/mod_auth.c lighttpd-1.4.36/src/mod_auth.c
--- lighttpd-1.4.32/src/mod_auth.c	2012-04-19 07:05:52.000000000 -0500
+++ lighttpd-1.4.36/src/mod_auth.c	2015-07-26 05:36:36.000000000 -0500
@@ -60,7 +60,7 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			mod_auth_plugin_config *s = p->config_storage[i];
 
-			if (!s) continue;
+			if (NULL == s) continue;
 
 			array_free(s->auth_require);
 			buffer_free(s->auth_plain_groupfile);
@@ -185,6 +185,7 @@
 	data_string *ds;
 	mod_auth_plugin_data *p = p_d;
 	array *req;
+	data_string *req_method;
 
 	/* select the right config */
 	mod_auth_patch_connection(srv, con, p);
@@ -205,18 +206,18 @@
 	for (k = 0; k < p->conf.auth_require->used; k++) {
 		buffer *require = p->conf.auth_require->data[k]->key;
 
-		if (require->used == 0) continue;
-		if (con->uri.path->used < require->used) continue;
+		if (buffer_is_empty(require)) continue;
+		if (buffer_string_length(con->uri.path) < buffer_string_length(require)) continue;
 
 		/* if we have a case-insensitive FS we have to lower-case the URI here too */
 
 		if (con->conf.force_lowercase_filenames) {
-			if (0 == strncasecmp(con->uri.path->ptr, require->ptr, require->used - 1)) {
+			if (0 == strncasecmp(con->uri.path->ptr, require->ptr, buffer_string_length(require))) {
 				auth_required = 1;
 				break;
 			}
 		} else {
-			if (0 == strncmp(con->uri.path->ptr, require->ptr, require->used - 1)) {
+			if (0 == strncmp(con->uri.path->ptr, require->ptr, buffer_string_length(require))) {
 				auth_required = 1;
 				break;
 			}
@@ -227,18 +228,30 @@
 	if (auth_required == 0) return HANDLER_GO_ON;
 
 	req = ((data_array *)(p->conf.auth_require->data[k]))->value;
+	req_method = (data_string *)array_get_element(req, "method");
 
-	/* try to get Authorization-header */
-
-	if (NULL != (ds = (data_string *)array_get_element(con->request.headers, "Authorization"))) {
-		http_authorization = ds->value->ptr;
+	if (0 == strcmp(req_method->value->ptr, "extern")) {
+		/* require REMOTE_USER to be already set */
+		if (NULL == (ds = (data_string *)array_get_element(con->environment, "REMOTE_USER"))) {
+			con->http_status = 401;
+			con->mode = DIRECT;
+			return HANDLER_FINISHED;
+		} else if (http_auth_match_rules(srv, req, ds->value->ptr, NULL, NULL)) {
+			log_error_write(srv, __FILE__, __LINE__, "s", "rules didn't match");
+			con->http_status = 401;
+			con->mode = DIRECT;
+			return HANDLER_FINISHED;
+		} else {
+			return HANDLER_GO_ON;
+		}
 	}
 
-	if (ds && ds->value && ds->value->used) {
+	/* try to get Authorization-header */
+
+	if (NULL != (ds = (data_string *)array_get_element(con->request.headers, "Authorization")) && !buffer_is_empty(ds->value)) {
 		char *auth_realm;
-		data_string *method;
 
-		method = (data_string *)array_get_element(req, "method");
+		http_authorization = ds->value->ptr;
 
 		/* parse auth-header */
 		if (NULL != (auth_realm = strchr(http_authorization, ' '))) {
@@ -248,14 +261,14 @@
 			    (0 == strncasecmp(http_authorization, "Basic", auth_type_len))) {
 				auth_type = "Basic";
 
-				if (0 == strcmp(method->value->ptr, "basic")) {
-					auth_satisfied = http_auth_basic_check(srv, con, p, req, con->uri.path, auth_realm+1);
+				if (0 == strcmp(req_method->value->ptr, "basic")) {
+					auth_satisfied = http_auth_basic_check(srv, con, p, req, auth_realm+1);
 				}
 			} else if ((auth_type_len == 6) &&
 				   (0 == strncasecmp(http_authorization, "Digest", auth_type_len))) {
 				auth_type = "Digest";
-				if (0 == strcmp(method->value->ptr, "digest")) {
-					if (-1 == (auth_satisfied = http_auth_digest_check(srv, con, p, req, con->uri.path, auth_realm+1))) {
+				if (0 == strcmp(req_method->value->ptr, "digest")) {
+					if (-1 == (auth_satisfied = http_auth_digest_check(srv, con, p, req, auth_realm+1))) {
 						con->http_status = 400;
 						con->mode = DIRECT;
 
@@ -266,7 +279,7 @@
 				}
 			} else {
 				log_error_write(srv, __FILE__, __LINE__, "ss",
-						"unknown authentification type:",
+						"unknown authentication type:",
 						http_authorization);
 			}
 		}
@@ -304,18 +317,25 @@
 	} else {
 		/* the REMOTE_USER header */
 
-		buffer_copy_string_buffer(con->authed_user, p->auth_user);
+		if (NULL == (ds = (data_string *)array_get_element(con->environment, "REMOTE_USER"))) {
+			if (NULL == (ds = (data_string *)array_get_unused_element(con->environment, TYPE_STRING))) {
+				ds = data_string_init();
+			}
+			buffer_copy_string(ds->key, "REMOTE_USER");
+			array_insert_unique(con->environment, (data_unset *)ds);
+		}
+		buffer_copy_buffer(ds->value, p->auth_user);
 
 		/* AUTH_TYPE environment */
 
-		if (NULL == (ds = (data_string *)array_get_unused_element(con->environment, TYPE_STRING))) {
-			ds = data_string_init();
+		if (NULL == (ds = (data_string *)array_get_element(con->environment, "AUTH_TYPE"))) {
+			if (NULL == (ds = (data_string *)array_get_unused_element(con->environment, TYPE_STRING))) {
+				ds = data_string_init();
+			}
+			buffer_copy_string(ds->key, "AUTH_TYPE");
+			array_insert_unique(con->environment, (data_unset *)ds);
 		}
-
-		buffer_copy_string(ds->key, "AUTH_TYPE");
 		buffer_copy_string(ds->value, auth_type);
-
-		array_insert_unique(con->environment, (data_unset *)ds);
 	}
 
 	return HANDLER_GO_ON;
@@ -344,7 +364,7 @@
 		{ NULL,                             NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
 	};
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(mod_auth_plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		mod_auth_plugin_config *s;
@@ -399,7 +419,7 @@
 			return HANDLER_ERROR;
 		}
 
-		if (s->auth_backend_conf->used) {
+		if (!buffer_string_is_empty(s->auth_backend_conf)) {
 			if (0 == strcmp(s->auth_backend_conf->ptr, "htpasswd")) {
 				s->auth_backend = AUTH_BACKEND_HTPASSWD;
 			} else if (0 == strcmp(s->auth_backend_conf->ptr, "htdigest")) {
@@ -416,7 +436,7 @@
 		}
 
 #ifdef USE_LDAP
-		if (s->auth_ldap_filter->used) {
+		if (!buffer_string_is_empty(s->auth_ldap_filter)) {
 			char *dollar;
 
 			/* parse filter */
@@ -487,9 +507,10 @@
 				return HANDLER_ERROR;
 			} else {
 				if (0 != strcmp(method, "basic") &&
-				    0 != strcmp(method, "digest")) {
+				    0 != strcmp(method, "digest") &&
+				    0 != strcmp(method, "extern")) {
 					log_error_write(srv, __FILE__, __LINE__, "ss",
-							"method has to be either \"basic\" or \"digest\" in",
+							"method has to be either \"basic\", \"digest\" or \"extern\" in",
 							"auth.require = ( \"...\" => ( ..., \"method\" => \"...\") )");
 					return HANDLER_ERROR;
 				}
@@ -514,7 +535,7 @@
 				data_array *a;
 
 				a = data_array_init();
-				buffer_copy_string_buffer(a->key, da_file->key);
+				buffer_copy_buffer(a->key, da_file->key);
 
 				ds = data_string_init();
 
@@ -541,7 +562,7 @@
 			}
 		}
 
-		switch(s->auth_ldap_hostname->used) {
+		switch(s->auth_backend) {
 		case AUTH_BACKEND_LDAP: {
 			handler_t ret = auth_ldap_init(srv, s);
 			if (ret == HANDLER_ERROR)
@@ -567,7 +588,7 @@
 	}
 #endif
 
-	if (s->auth_ldap_hostname->used) {
+	if (!buffer_string_is_empty(s->auth_ldap_hostname)) {
 		/* free old context */
 		if (NULL != s->ldap) ldap_unbind_s(s->ldap);
 
@@ -587,7 +608,7 @@
 		if (s->auth_ldap_starttls) {
 			/* if no CA file is given, it is ok, as we will use encryption
 				* if the server requires a CAfile it will tell us */
-			if (!buffer_is_empty(s->auth_ldap_cafile)) {
+			if (!buffer_string_is_empty(s->auth_ldap_cafile)) {
 				if (LDAP_OPT_SUCCESS != (ret = ldap_set_option(NULL, LDAP_OPT_X_TLS_CACERTFILE,
 								s->auth_ldap_cafile->ptr))) {
 					log_error_write(srv, __FILE__, __LINE__, "ss",
@@ -606,7 +627,7 @@
 
 
 		/* 1. */
-		if (s->auth_ldap_binddn->used) {
+		if (!buffer_string_is_empty(s->auth_ldap_binddn)) {
 			if (LDAP_SUCCESS != (ret = ldap_simple_bind_s(s->ldap, s->auth_ldap_binddn->ptr, s->auth_ldap_bindpw->ptr))) {
 				log_error_write(srv, __FILE__, __LINE__, "ss", "ldap:", ldap_err2string(ret));
 
diff -u lighttpd-1.4.32/src/mod_cgi.c lighttpd-1.4.36/src/mod_cgi.c
--- lighttpd-1.4.32/src/mod_cgi.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.36/src/mod_cgi.c	2015-07-26 05:36:36.000000000 -0500
@@ -85,7 +85,7 @@
 static handler_ctx * cgi_handler_ctx_init(void) {
 	handler_ctx *hctx = calloc(1, sizeof(*hctx));
 
-	assert(hctx);
+	force_assert(hctx);
 
 	hctx->response = buffer_init();
 	hctx->response_header = buffer_init();
@@ -107,7 +107,7 @@
 
 	p = calloc(1, sizeof(*p));
 
-	assert(p);
+	force_assert(p);
 
 	p->tmp_buf = buffer_init();
 	p->parse_response = buffer_init();
@@ -127,6 +127,8 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
+			if (NULL == s) continue;
+
 			array_free(s->cgi);
 
 			free(s);
@@ -157,13 +159,13 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
 
 		s = calloc(1, sizeof(plugin_config));
-		assert(s);
+		force_assert(s);
 
 		s->cgi    = array_init();
 		s->execute_x_only = 0;
@@ -235,7 +237,7 @@
 
 	UNUSED(srv);
 
-	buffer_copy_string_buffer(p->parse_response, in);
+	buffer_copy_buffer(p->parse_response, in);
 
 	for (s = p->parse_response->ptr;
 	     NULL != (ns = strchr(s, '\n'));
@@ -344,13 +346,13 @@
 		int toread;
 
 #if defined(__WIN32)
-		buffer_prepare_copy(hctx->response, 4 * 1024);
+		buffer_string_prepare_copy(hctx->response, 4 * 1024);
 #else
 		if (ioctl(con->fd, FIONREAD, &toread) || toread == 0 || toread <= 4*1024) {
-			buffer_prepare_copy(hctx->response, 4 * 1024);
+			buffer_string_prepare_copy(hctx->response, 4 * 1024);
 		} else {
 			if (toread > MAX_READ_LIMIT) toread = MAX_READ_LIMIT;
-			buffer_prepare_copy(hctx->response, toread + 1);
+			buffer_string_prepare_copy(hctx->response, toread);
 		}
 #endif
 
@@ -370,14 +372,13 @@
 			con->file_finished = 1;
 
 			/* send final chunk */
-			http_chunk_append_mem(srv, con, NULL, 0);
+			http_chunk_close(srv, con);
 			joblist_append(srv, con);
 
 			return FDEVENT_HANDLED_FINISHED;
 		}
 
-		hctx->response->ptr[n] = '\0';
-		hctx->response->used = n+1;
+		buffer_commit(hctx->response, n);
 
 		/* split header from body */
 
@@ -385,7 +386,7 @@
 			int is_header = 0;
 			int is_header_end = 0;
 			size_t last_eol = 0;
-			size_t i;
+			size_t i, header_len;
 
 			buffer_append_string_buffer(hctx->response_header, hctx->response);
 
@@ -412,8 +413,9 @@
 			
 			/* nph (non-parsed headers) */
 			if (0 == strncmp(hctx->response_header->ptr, "HTTP/1.", 7)) is_header = 1;
-				
-			for (i = 0; !is_header_end && i < hctx->response_header->used - 1; i++) {
+
+			header_len = buffer_string_length(hctx->response_header);
+			for (i = 0; !is_header_end && i < header_len; i++) {
 				char c = hctx->response_header->ptr[i];
 
 				switch (c) {
@@ -458,31 +460,30 @@
 						con->response.transfer_encoding = HTTP_TRANSFER_ENCODING_CHUNKED;
 					}
 
-					http_chunk_append_mem(srv, con, hctx->response_header->ptr, hctx->response_header->used);
+					http_chunk_append_buffer(srv, con, hctx->response_header);
 					joblist_append(srv, con);
 				} else {
 					const char *bstart;
 					size_t blen;
-					
+
+					/* the body starts after the EOL */
+					bstart = hctx->response_header->ptr + i;
+					blen = header_len - i;
+
 					/**
 					 * i still points to the char after the terminating EOL EOL
 					 *
 					 * put it on the last \n again
 					 */
 					i--;
-					
-					/* the body starts after the EOL */
-					bstart = hctx->response_header->ptr + (i + 1);
-					blen = (hctx->response_header->used - 1) - (i + 1);
-					
+
 					/* string the last \r?\n */
 					if (i > 0 && (hctx->response_header->ptr[i - 1] == '\r')) {
 						i--;
 					}
 
-					hctx->response_header->ptr[i] = '\0';
-					hctx->response_header->used = i + 1; /* the string + \0 */
-					
+					buffer_string_set_length(hctx->response_header, i);
+
 					/* parse the response header */
 					cgi_response_parse(srv, con, p, hctx->response_header);
 
@@ -493,7 +494,7 @@
 					}
 
 					if (blen > 0) {
-						http_chunk_append_mem(srv, con, bstart, blen + 1);
+						http_chunk_append_mem(srv, con, bstart, blen);
 						joblist_append(srv, con);
 					}
 				}
@@ -501,7 +502,7 @@
 				con->file_started = 1;
 			}
 		} else {
-			http_chunk_append_mem(srv, con, hctx->response->ptr, hctx->response->used);
+			http_chunk_append_buffer(srv, con, hctx->response);
 			joblist_append(srv, con);
 		}
 
@@ -668,27 +669,17 @@
 	/* perhaps this issue is already handled */
 	if (revents & FDEVENT_HUP) {
 		/* check if we still have a unfinished header package which is a body in reality */
-		if (con->file_started == 0 &&
-		    hctx->response_header->used) {
+		if (con->file_started == 0 && !buffer_string_is_empty(hctx->response_header)) {
 			con->file_started = 1;
-			http_chunk_append_mem(srv, con, hctx->response_header->ptr, hctx->response_header->used);
-			joblist_append(srv, con);
+			http_chunk_append_buffer(srv, con, hctx->response_header);
 		}
 
 		if (con->file_finished == 0) {
-			http_chunk_append_mem(srv, con, NULL, 0);
-			joblist_append(srv, con);
+			http_chunk_close(srv, con);
 		}
-
 		con->file_finished = 1;
 
-		if (chunkqueue_is_empty(con->write_queue)) {
-			/* there is nothing left to write */
-			connection_set_state(srv, con, CON_STATE_RESPONSE_END);
-		} else {
-			/* used the write-handler to finish the request on demand */
-
-		}
+		joblist_append(srv, con);
 
 # if 0
 		log_error_write(srv, __FILE__, __LINE__, "sddd", "got HUP from cgi", con->fd, hctx->fd, revents);
@@ -748,7 +739,7 @@
 
 #ifndef __WIN32
 
-	if (cgi_handler->used > 1) {
+	if (!buffer_string_is_empty(cgi_handler)) {
 		/* stat the exec file */
 		if (-1 == (stat(cgi_handler->ptr, &st))) {
 			log_error_write(srv, __FILE__, __LINE__, "sbss",
@@ -777,7 +768,7 @@
 		char **args;
 		int argc;
 		int i = 0;
-		char buf[32];
+		char buf[LI_ITOSTRING_LENGTH];
 		size_t n;
 		char_array env;
 		char *c;
@@ -809,8 +800,8 @@
 			cgi_env_add(&env, CONST_STR_LEN("SERVER_SOFTWARE"), CONST_BUF_LEN(con->conf.server_tag));
 		}
 
-		if (!buffer_is_empty(con->server_name)) {
-			size_t len = con->server_name->used - 1;
+		if (!buffer_string_is_empty(con->server_name)) {
+			size_t len = buffer_string_length(con->server_name);
 
 			if (con->server_name->ptr[0] == '[') {
 				const char *colon = strstr(con->server_name->ptr, "]:");
@@ -839,7 +830,7 @@
 
 		cgi_env_add(&env, CONST_STR_LEN("SERVER_PROTOCOL"), s, strlen(s));
 
-		LI_ltostr(buf,
+		li_utostr(buf,
 #ifdef HAVE_IPV6
 			ntohs(srv_sock->addr.plain.sa_family == AF_INET6 ? srv_sock->addr.ipv6.sin6_port : srv_sock->addr.ipv4.sin_port)
 #else
@@ -874,14 +865,14 @@
 		s = get_http_method_name(con->request.http_method);
 		cgi_env_add(&env, CONST_STR_LEN("REQUEST_METHOD"), s, strlen(s));
 
-		if (!buffer_is_empty(con->request.pathinfo)) {
+		if (!buffer_string_is_empty(con->request.pathinfo)) {
 			cgi_env_add(&env, CONST_STR_LEN("PATH_INFO"), CONST_BUF_LEN(con->request.pathinfo));
 		}
 		cgi_env_add(&env, CONST_STR_LEN("REDIRECT_STATUS"), CONST_STR_LEN("200"));
-		if (!buffer_is_empty(con->uri.query)) {
+		if (!buffer_string_is_empty(con->uri.query)) {
 			cgi_env_add(&env, CONST_STR_LEN("QUERY_STRING"), CONST_BUF_LEN(con->uri.query));
 		}
-		if (!buffer_is_empty(con->request.orig_uri)) {
+		if (!buffer_string_is_empty(con->request.orig_uri)) {
 			cgi_env_add(&env, CONST_STR_LEN("REQUEST_URI"), CONST_BUF_LEN(con->request.orig_uri));
 		}
 
@@ -909,7 +900,7 @@
 		}
 		cgi_env_add(&env, CONST_STR_LEN("REMOTE_ADDR"), s, strlen(s));
 
-		LI_ltostr(buf,
+		li_utostr(buf,
 #ifdef HAVE_IPV6
 			ntohs(con->dst_addr.plain.sa_family == AF_INET6 ? con->dst_addr.ipv6.sin6_port : con->dst_addr.ipv4.sin_port)
 #else
@@ -918,19 +909,11 @@
 			);
 		cgi_env_add(&env, CONST_STR_LEN("REMOTE_PORT"), buf, strlen(buf));
 
-		if (!buffer_is_empty(con->authed_user)) {
-			cgi_env_add(&env, CONST_STR_LEN("REMOTE_USER"),
-				    CONST_BUF_LEN(con->authed_user));
+		if (buffer_is_equal_caseless_string(con->uri.scheme, CONST_STR_LEN("https"))) {
+			cgi_env_add(&env, CONST_STR_LEN("HTTPS"), CONST_STR_LEN("on"));
 		}
 
-#ifdef USE_OPENSSL
-	if (srv_sock->is_ssl) {
-		cgi_env_add(&env, CONST_STR_LEN("HTTPS"), CONST_STR_LEN("on"));
-	}
-#endif
-
-		/* request.content_length < SSIZE_MAX, see request.c */
-		LI_ltostr(buf, con->request.content_length);
+		li_itostr(buf, con->request.content_length);
 		cgi_env_add(&env, CONST_STR_LEN("CONTENT_LENGTH"), buf, strlen(buf));
 		cgi_env_add(&env, CONST_STR_LEN("SCRIPT_FILENAME"), CONST_BUF_LEN(con->physical.path));
 		cgi_env_add(&env, CONST_STR_LEN("SCRIPT_NAME"), CONST_BUF_LEN(con->uri.path));
@@ -956,30 +939,8 @@
 
 			ds = (data_string *)con->request.headers->data[n];
 
-			if (ds->value->used && ds->key->used) {
-				size_t j;
-
-				buffer_reset(p->tmp_buf);
-
-				if (0 != strcasecmp(ds->key->ptr, "CONTENT-TYPE")) {
-					buffer_copy_string_len(p->tmp_buf, CONST_STR_LEN("HTTP_"));
-					p->tmp_buf->used--; /* strip \0 after HTTP_ */
-				}
-
-				buffer_prepare_append(p->tmp_buf, ds->key->used + 2);
-
-				for (j = 0; j < ds->key->used - 1; j++) {
-					char cr = '_';
-					if (light_isalpha(ds->key->ptr[j])) {
-						/* upper-case */
-						cr = ds->key->ptr[j] & ~32;
-					} else if (light_isdigit(ds->key->ptr[j])) {
-						/* copy */
-						cr = ds->key->ptr[j];
-					}
-					p->tmp_buf->ptr[p->tmp_buf->used++] = cr;
-				}
-				p->tmp_buf->ptr[p->tmp_buf->used++] = '\0';
+			if (!buffer_is_empty(ds->value) && !buffer_is_empty(ds->key)) {
+				buffer_copy_string_encoded_cgi_varnames(p->tmp_buf, CONST_BUF_LEN(ds->key), 1);
 
 				cgi_env_add(&env, CONST_BUF_LEN(p->tmp_buf), CONST_BUF_LEN(ds->value));
 			}
@@ -990,25 +951,8 @@
 
 			ds = (data_string *)con->environment->data[n];
 
-			if (ds->value->used && ds->key->used) {
-				size_t j;
-
-				buffer_reset(p->tmp_buf);
-
-				buffer_prepare_append(p->tmp_buf, ds->key->used + 2);
-
-				for (j = 0; j < ds->key->used - 1; j++) {
-					char cr = '_';
-					if (light_isalpha(ds->key->ptr[j])) {
-						/* upper-case */
-						cr = ds->key->ptr[j] & ~32;
-					} else if (light_isdigit(ds->key->ptr[j])) {
-						/* copy */
-						cr = ds->key->ptr[j];
-					}
-					p->tmp_buf->ptr[p->tmp_buf->used++] = cr;
-				}
-				p->tmp_buf->ptr[p->tmp_buf->used++] = '\0';
+			if (!buffer_is_empty(ds->value) && !buffer_is_empty(ds->key)) {
+				buffer_copy_string_encoded_cgi_varnames(p->tmp_buf, CONST_BUF_LEN(ds->key), 0);
 
 				cgi_env_add(&env, CONST_BUF_LEN(p->tmp_buf), CONST_BUF_LEN(ds->value));
 			}
@@ -1026,7 +970,7 @@
 		args = malloc(sizeof(*args) * argc);
 		i = 0;
 
-		if (cgi_handler->used > 1) {
+		if (!buffer_string_is_empty(cgi_handler)) {
 			args[i++] = cgi_handler->ptr;
 		}
 		args[i++] = con->physical.path->ptr;
@@ -1128,7 +1072,7 @@
 					}
 					break;
 				case MEM_CHUNK:
-					if ((r = write(to_cgi_fds[1], c->mem->ptr + c->offset, c->mem->used - c->offset - 1)) < 0) {
+					if ((r = write(to_cgi_fds[1], c->mem->ptr + c->offset, buffer_string_length(c->mem) - c->offset)) < 0) {
 						switch(errno) {
 						case ENOSPC:
 							con->http_status = 507;
@@ -1141,8 +1085,6 @@
 						}
 					}
 					break;
-				case UNUSED_CHUNK:
-					break;
 				}
 
 				if (r > 0) {
@@ -1244,7 +1186,7 @@
 
 	if (con->mode != DIRECT) return HANDLER_GO_ON;
 
-	if (fn->used == 0) return HANDLER_GO_ON;
+	if (buffer_is_empty(fn)) return HANDLER_GO_ON;
 
 	mod_cgi_patch_connection(srv, con, p);
 
@@ -1252,13 +1194,13 @@
 	if (!S_ISREG(sce->st.st_mode)) return HANDLER_GO_ON;
 	if (p->conf.execute_x_only == 1 && (sce->st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)) == 0) return HANDLER_GO_ON;
 
-	s_len = fn->used - 1;
+	s_len = buffer_string_length(fn);
 
 	for (k = 0; k < p->conf.cgi->used; k++) {
 		data_string *ds = (data_string *)p->conf.cgi->data[k];
-		size_t ct_len = ds->key->used - 1;
+		size_t ct_len = buffer_string_length(ds->key);
 
-		if (ds->key->used == 0) continue;
+		if (buffer_is_empty(ds->key)) continue;
 		if (s_len < ct_len) continue;
 
 		if (0 == strncmp(fn->ptr + s_len - ct_len, ds->key->ptr, ct_len)) {
diff -u lighttpd-1.4.32/src/mod_cml.c lighttpd-1.4.36/src/mod_cml.c
--- lighttpd-1.4.32/src/mod_cml.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/mod_cml.c	2015-07-26 05:36:36.000000000 -0500
@@ -43,6 +43,8 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
+			if (NULL == s) continue;
+
 			buffer_free(s->ext);
 
 			buffer_free(s->mc_namespace);
@@ -83,7 +85,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = malloc(srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -184,21 +186,19 @@
 
 	/* cleanup basedir */
 	b = p->baseurl;
-	buffer_copy_string_buffer(b, con->uri.path);
-	for (c = b->ptr + b->used - 1; c > b->ptr && *c != '/'; c--);
+	buffer_copy_buffer(b, con->uri.path);
+	for (c = b->ptr + buffer_string_length(b); c > b->ptr && *c != '/'; c--);
 
 	if (*c == '/') {
-		b->used = c - b->ptr + 2;
-		*(c+1) = '\0';
+		buffer_string_set_length(b, c - b->ptr + 1);
 	}
 
 	b = p->basedir;
-	buffer_copy_string_buffer(b, con->physical.path);
-	for (c = b->ptr + b->used - 1; c > b->ptr && *c != '/'; c--);
+	buffer_copy_buffer(b, con->physical.path);
+	for (c = b->ptr + buffer_string_length(b); c > b->ptr && *c != '/'; c--);
 
 	if (*c == '/') {
-		b->used = c - b->ptr + 2;
-		*(c+1) = '\0';
+		buffer_string_set_length(b, c - b->ptr + 1);
 	}
 
 
@@ -218,7 +218,7 @@
 	buffer_reset(p->baseurl);
 	buffer_reset(p->trigger_handler);
 
-	if (buffer_is_empty(p->conf.power_magnet)) return HANDLER_GO_ON;
+	if (buffer_string_is_empty(p->conf.power_magnet)) return HANDLER_GO_ON;
 
 	/*
 	 * power-magnet:
@@ -264,7 +264,7 @@
 URIHANDLER_FUNC(mod_cml_is_handled) {
 	plugin_data *p = p_d;
 
-	if (buffer_is_empty(con->physical.path)) return HANDLER_ERROR;
+	if (buffer_string_is_empty(con->physical.path)) return HANDLER_ERROR;
 
 	mod_cml_patch_connection(srv, con, p);
 
@@ -272,9 +272,9 @@
 	buffer_reset(p->baseurl);
 	buffer_reset(p->trigger_handler);
 
-	if (buffer_is_empty(p->conf.ext)) return HANDLER_GO_ON;
+	if (buffer_string_is_empty(p->conf.ext)) return HANDLER_GO_ON;
 
-	if (!buffer_is_equal_right_len(con->physical.path, p->conf.ext, p->conf.ext->used - 1)) {
+	if (!buffer_is_equal_right_len(con->physical.path, p->conf.ext, buffer_string_length(p->conf.ext))) {
 		return HANDLER_GO_ON;
 	}
 
diff -u lighttpd-1.4.32/src/mod_cml_funcs.c lighttpd-1.4.36/src/mod_cml_funcs.c
--- lighttpd-1.4.32/src/mod_cml_funcs.c	2011-07-30 03:53:53.000000000 -0500
+++ lighttpd-1.4.36/src/mod_cml_funcs.c	2015-07-26 05:36:36.000000000 -0500
@@ -35,14 +35,9 @@
 int f_crypto_md5(lua_State *L) {
 	li_MD5_CTX Md5Ctx;
 	HASH HA1;
-	buffer b;
 	char hex[33];
 	int n = lua_gettop(L);
 
-	b.ptr = hex;
-	b.used = 0;
-	b.size = sizeof(hex);
-
 	if (n != 1) {
 		lua_pushstring(L, "md5: expected one argument");
 		lua_error(L);
@@ -57,9 +52,9 @@
 	li_MD5_Update(&Md5Ctx, (unsigned char *)lua_tostring(L, 1), lua_strlen(L, 1));
 	li_MD5_Final(HA1, &Md5Ctx);
 
-	buffer_copy_string_hex(&b, (char *)HA1, 16);
+	li_tohex(hex, (const char*) HA1, 16);
 
-	lua_pushstring(L, b.ptr);
+	lua_pushstring(L, hex);
 
 	return 1;
 }
diff -u lighttpd-1.4.32/src/mod_cml_lua.c lighttpd-1.4.36/src/mod_cml_lua.c
--- lighttpd-1.4.32/src/mod_cml_lua.c	2012-11-17 11:32:01.000000000 -0600
+++ lighttpd-1.4.36/src/mod_cml_lua.c	2015-07-26 05:36:36.000000000 -0500
@@ -64,7 +64,7 @@
 
 	lua_pop(L, 1);
 
-	assert(curelem - 1 == lua_gettop(L));
+	force_assert(curelem - 1 == lua_gettop(L));
 
 	return 0;
 }
@@ -86,7 +86,7 @@
 
 	lua_settop(L, curelem - 1);
 
-	assert(curelem - 1 == lua_gettop(L));
+	force_assert(curelem - 1 == lua_gettop(L));
 
 	return 1;
 }
@@ -102,13 +102,14 @@
 
 static int cache_export_get_params(lua_State *L, int tbl, buffer *qrystr) {
 	size_t is_key = 1;
-	size_t i;
+	size_t i, len;
 	char *key = NULL, *val = NULL;
 
 	key = qrystr->ptr;
 
 	/* we need the \0 */
-	for (i = 0; i < qrystr->used; i++) {
+	len = buffer_string_length(qrystr);
+	for (i = 0; i <= len; i++) {
 		switch(qrystr->ptr[i]) {
 		case '=':
 			if (is_key) {
@@ -129,8 +130,8 @@
 				qrystr->ptr[i] = '\0';
 
 				c_to_lua_push(L, tbl,
-					      key, strlen(key),
-					      val, strlen(val));
+					key, strlen(key),
+					val, strlen(val));
 			}
 
 			key = qrystr->ptr + i + 1;
@@ -209,12 +210,17 @@
 	lua_State *L;
 	readme rm;
 	int ret = -1;
-	buffer *b = buffer_init();
+	buffer *b;
 	int header_tbl = 0;
 
 	rm.done = 0;
-	stream_open(&rm.st, fn);
+	if (-1 == stream_open(&rm.st, fn)) {
+		log_error_write(srv, __FILE__, __LINE__, "sbss",
+				"opening lua cml file ", fn, "failed:", strerror(errno));
+		return -1;
+	}
 
+	b = buffer_init();
 	/* push the lua file to the interpreter and see what happends */
 	L = luaL_newstate();
 	luaL_openlibs(L);
@@ -255,7 +261,7 @@
 	c_to_lua_push(L, header_tbl, CONST_STR_LEN("SCRIPT_NAME"), CONST_BUF_LEN(con->uri.path));
 	c_to_lua_push(L, header_tbl, CONST_STR_LEN("SCRIPT_FILENAME"), CONST_BUF_LEN(con->physical.path));
 	c_to_lua_push(L, header_tbl, CONST_STR_LEN("DOCUMENT_ROOT"), CONST_BUF_LEN(con->physical.doc_root));
-	if (!buffer_is_empty(con->request.pathinfo)) {
+	if (!buffer_string_is_empty(con->request.pathinfo)) {
 		c_to_lua_push(L, header_tbl, CONST_STR_LEN("PATH_INFO"), CONST_BUF_LEN(con->request.pathinfo));
 	}
 
@@ -271,7 +277,7 @@
 	header_tbl = lua_gettop(L);
 	lua_gettable(L, LUA_GLOBALSINDEX);
 
-	buffer_copy_string_buffer(b, con->uri.query);
+	buffer_copy_buffer(b, con->uri.query);
 	cache_export_get_params(L, header_tbl, b);
 	buffer_reset(b);
 
@@ -341,7 +347,7 @@
 
 				/* the file is relative, make it absolute */
 				if (s[0] != '/') {
-					buffer_copy_string_buffer(b, p->basedir);
+					buffer_copy_buffer(b, p->basedir);
 					buffer_append_string(b, lua_tostring(L, -1));
 				} else {
 					buffer_copy_string(b, lua_tostring(L, -1));
@@ -353,7 +359,7 @@
 					switch(errno) {
 					case ENOENT:
 						/* a file is missing, call the handler to generate it */
-						if (!buffer_is_empty(p->trigger_handler)) {
+						if (!buffer_string_is_empty(p->trigger_handler)) {
 							ret = 1; /* cache-miss */
 
 							log_error_write(srv, __FILE__, __LINE__, "s",
@@ -393,34 +399,23 @@
 		if (ret == 0) {
 			data_string *ds;
 			char timebuf[sizeof("Sat, 23 Jul 2005 21:20:01 GMT")];
-			buffer tbuf;
 
 			con->file_finished = 1;
 
 			ds = (data_string *)array_get_element(con->response.headers, "Last-Modified");
+			if (0 == mtime) mtime = time(NULL); /* default last-modified to now */
 
 			/* no Last-Modified specified */
-			if ((mtime) && (NULL == ds)) {
+			if (NULL == ds) {
 
 				strftime(timebuf, sizeof(timebuf), "%a, %d %b %Y %H:%M:%S GMT", gmtime(&mtime));
 
 				response_header_overwrite(srv, con, CONST_STR_LEN("Last-Modified"), timebuf, sizeof(timebuf) - 1);
-
-
-				tbuf.ptr = timebuf;
-				tbuf.used = sizeof(timebuf);
-				tbuf.size = sizeof(timebuf);
-			} else if (ds) {
-				tbuf.ptr = ds->value->ptr;
-				tbuf.used = ds->value->used;
-				tbuf.size = ds->value->size;
-			} else {
-				tbuf.size = 0;
-				tbuf.used = 0;
-				tbuf.ptr = NULL;
+				ds = (data_string *)array_get_element(con->response.headers, "Last-Modified");
+				force_assert(NULL != ds);
 			}
 
-			if (HANDLER_FINISHED == http_response_handle_cachable(srv, con, &tbuf)) {
+			if (HANDLER_FINISHED == http_response_handle_cachable(srv, con, ds->value)) {
 				/* ok, the client already has our content,
 				 * no need to send it again */
 
@@ -432,12 +427,12 @@
 		}
 	}
 
-	if (ret == 1 && !buffer_is_empty(p->trigger_handler)) {
+	if (ret == 1 && !buffer_string_is_empty(p->trigger_handler)) {
 		/* cache-miss */
-		buffer_copy_string_buffer(con->uri.path, p->baseurl);
+		buffer_copy_buffer(con->uri.path, p->baseurl);
 		buffer_append_string_buffer(con->uri.path, p->trigger_handler);
 
-		buffer_copy_string_buffer(con->physical.path, p->basedir);
+		buffer_copy_buffer(con->physical.path, p->basedir);
 		buffer_append_string_buffer(con->physical.path, p->trigger_handler);
 
 		chunkqueue_reset(con->write_queue);
diff -u lighttpd-1.4.32/src/mod_compress.c lighttpd-1.4.36/src/mod_compress.c
--- lighttpd-1.4.32/src/mod_compress.c	2012-11-17 11:32:01.000000000 -0600
+++ lighttpd-1.4.36/src/mod_compress.c	2015-07-26 05:36:36.000000000 -0500
@@ -12,6 +12,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
+#include <assert.h>
 #include <fcntl.h>
 #include <unistd.h>
 #include <ctype.h>
@@ -89,7 +90,7 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
-			if (!s) continue;
+			if (NULL == s) continue;
 
 			array_free(s->compress);
 			buffer_free(s->compress_cache_dir);
@@ -161,7 +162,7 @@
 		{ NULL,                             NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
 	};
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -221,7 +222,7 @@
 
 		array_free(encodings_arr);
 
-		if (!buffer_is_empty(s->compress_cache_dir)) {
+		if (!buffer_string_is_empty(s->compress_cache_dir)) {
 			struct stat st;
 			mkdir_recursive(s->compress_cache_dir->ptr);
 
@@ -243,6 +244,7 @@
 	unsigned char *c;
 	unsigned long crc;
 	z_stream z;
+	size_t outlen;
 
 	UNUSED(srv);
 	UNUSED(con);
@@ -265,7 +267,7 @@
 	z.total_in = 0;
 
 
-	buffer_prepare_copy(p->b, (z.avail_in * 1.1) + 12 + 18);
+	buffer_string_prepare_copy(p->b, (z.avail_in * 1.1) + 12 + 18);
 
 	/* write gzip header */
 
@@ -281,9 +283,9 @@
 	c[8] = 0x00; /* extra flags */
 	c[9] = 0x03; /* UNIX */
 
-	p->b->used = 10;
-	z.next_out = (unsigned char *)p->b->ptr + p->b->used;
-	z.avail_out = p->b->size - p->b->used - 8;
+	outlen = 10;
+	z.next_out = (unsigned char *)p->b->ptr + outlen;
+	z.avail_out = p->b->size - outlen - 9;
 	z.total_out = 0;
 
 	if (Z_STREAM_END != deflate(&z, Z_FINISH)) {
@@ -292,11 +294,11 @@
 	}
 
 	/* trailer */
-	p->b->used += z.total_out;
+	outlen += z.total_out;
 
 	crc = generate_crc32c(start, st_size);
 
-	c = (unsigned char *)p->b->ptr + p->b->used;
+	c = (unsigned char *)p->b->ptr + outlen;
 
 	c[0] = (crc >>  0) & 0xff;
 	c[1] = (crc >>  8) & 0xff;
@@ -306,7 +308,8 @@
 	c[5] = (z.total_in >>  8) & 0xff;
 	c[6] = (z.total_in >> 16) & 0xff;
 	c[7] = (z.total_in >> 24) & 0xff;
-	p->b->used += 8;
+	outlen += 8;
+	buffer_commit(p->b, outlen);
 
 	if (Z_OK != deflateEnd(&z)) {
 		return -1;
@@ -338,10 +341,10 @@
 	z.avail_in = st_size;
 	z.total_in = 0;
 
-	buffer_prepare_copy(p->b, (z.avail_in * 1.1) + 12);
+	buffer_string_prepare_copy(p->b, (z.avail_in * 1.1) + 12);
 
 	z.next_out = (unsigned char *)p->b->ptr;
-	z.avail_out = p->b->size;
+	z.avail_out = p->b->size - 1;
 	z.total_out = 0;
 
 	if (Z_STREAM_END != deflate(&z, Z_FINISH)) {
@@ -349,13 +352,13 @@
 		return -1;
 	}
 
-	/* trailer */
-	p->b->used += z.total_out;
-
 	if (Z_OK != deflateEnd(&z)) {
 		return -1;
 	}
 
+	/* trailer */
+	buffer_commit(p->b, z.total_out);
+
 	return 0;
 }
 
@@ -384,10 +387,10 @@
 	bz.total_in_lo32 = 0;
 	bz.total_in_hi32 = 0;
 
-	buffer_prepare_copy(p->b, (bz.avail_in * 1.1) + 12);
+	buffer_string_prepare_copy(p->b, (bz.avail_in * 1.1) + 12);
 
 	bz.next_out = p->b->ptr;
-	bz.avail_out = p->b->size;
+	bz.avail_out = p->b->size - 1;
 	bz.total_out_lo32 = 0;
 	bz.total_out_hi32 = 0;
 
@@ -396,15 +399,15 @@
 		return -1;
 	}
 
+	if (BZ_OK != BZ2_bzCompressEnd(&bz)) {
+		return -1;
+	}
+
 	/* file is too large for now */
 	if (bz.total_out_hi32) return -1;
 
 	/* trailer */
-	p->b->used = bz.total_out_lo32;
-
-	if (BZ_OK != BZ2_bzCompressEnd(&bz)) {
-		return -1;
-	}
+	buffer_commit(p->b, bz.total_out_lo32);
 
 	return 0;
 }
@@ -412,7 +415,7 @@
 
 static int deflate_file_to_file(server *srv, connection *con, plugin_data *p, buffer *fn, stat_cache_entry *sce, int type) {
 	int ifd, ofd;
-	int ret = -1;
+	int ret;
 	void *start;
 	const char *filename = fn->ptr;
 	ssize_t r;
@@ -428,12 +431,11 @@
 	if (sce->st.st_size > 128 * 1024 * 1024) return -1;
 
 	buffer_reset(p->ofn);
-	buffer_copy_string_buffer(p->ofn, p->conf.compress_cache_dir);
-	BUFFER_APPEND_SLASH(p->ofn);
+	buffer_copy_buffer(p->ofn, p->conf.compress_cache_dir);
+	buffer_append_slash(p->ofn);
 
-	if (0 == strncmp(con->physical.path->ptr, con->physical.doc_root->ptr, con->physical.doc_root->used-1)) {
-		buffer_append_string(p->ofn, con->physical.path->ptr + con->physical.doc_root->used - 1);
-		buffer_copy_string_buffer(p->b, p->ofn);
+	if (0 == strncmp(con->physical.path->ptr, con->physical.doc_root->ptr, buffer_string_length(con->physical.doc_root))) {
+		buffer_append_string(p->ofn, con->physical.path->ptr + buffer_string_length(con->physical.doc_root));
 	} else {
 		buffer_append_string_buffer(p->ofn, con->uri.path);
 	}
@@ -468,7 +470,7 @@
 #if 0
 			log_error_write(srv, __FILE__, __LINE__, "bs", p->ofn, "compress-cache hit");
 #endif
-			buffer_copy_string_buffer(con->physical.path, p->ofn);
+			buffer_copy_buffer(con->physical.path, p->ofn);
 
 			return 0;
 		}
@@ -525,6 +527,7 @@
 	}
 #endif
 
+	ret = -1;
 	switch(type) {
 #ifdef USE_ZLIB
 	case HTTP_ACCEPT_ENCODING_GZIP:
@@ -541,17 +544,14 @@
 		ret = deflate_file_to_buffer_bzip2(srv, con, p, start, sce->st.st_size);
 		break;
 #endif
-	default:
-		ret = -1;
-		break;
 	}
 
 	if (ret == 0) {
-		r = write(ofd, p->b->ptr, p->b->used);
+		r = write(ofd, CONST_BUF_LEN(p->b));
 		if (-1 == r) {
 			log_error_write(srv, __FILE__, __LINE__, "sbss", "writing cachefile", p->ofn, "failed:", strerror(errno));
 			ret = -1;
-		} else if ((size_t)r != p->b->used) {
+		} else if ((size_t)r != buffer_string_length(p->b)) {
 			log_error_write(srv, __FILE__, __LINE__, "sbs", "writing cachefile", p->ofn, "failed: not enough bytes written");
 			ret = -1;
 		}
@@ -575,7 +575,7 @@
 		return -1;
 	}
 
-	buffer_copy_string_buffer(con->physical.path, p->ofn);
+	buffer_copy_buffer(con->physical.path, p->ofn);
 
 	return 0;
 }
@@ -584,7 +584,6 @@
 	int ifd;
 	int ret = -1;
 	void *start;
-	buffer *b;
 
 	/* overflow */
 	if ((off_t)(sce->st.st_size * 1.1) < sce->st.st_size) return -1;
@@ -652,8 +651,7 @@
 	if (ret != 0) return -1;
 
 	chunkqueue_reset(con->write_queue);
-	b = chunkqueue_get_append_buffer(con->write_queue);
-	buffer_copy_memory(b, p->b->ptr, p->b->used + 1);
+	chunkqueue_append_buffer(con->write_queue, p->b);
 
 	buffer_reset(con->physical.path);
 
@@ -733,7 +731,7 @@
 		return HANDLER_GO_ON;
 	}
 
-	if (buffer_is_empty(con->physical.path)) {
+	if (buffer_string_is_empty(con->physical.path)) {
 		return HANDLER_GO_ON;
 	}
 
@@ -860,14 +858,15 @@
 					} else if (matched_encodings & HTTP_ACCEPT_ENCODING_X_GZIP) {
 						compression_type = HTTP_ACCEPT_ENCODING_X_GZIP;
 						compression_name = dflt_x_gzip;
-					} else if (matched_encodings & HTTP_ACCEPT_ENCODING_DEFLATE) {
+					} else {
+						force_assert(matched_encodings & HTTP_ACCEPT_ENCODING_DEFLATE);
 						compression_type = HTTP_ACCEPT_ENCODING_DEFLATE;
 						compression_name = dflt_deflate;
 					}
 
 					if (use_etag) {
 						/* try matching etag of compressed version */
-						buffer_copy_string_buffer(srv->tmp_buf, sce->etag);
+						buffer_copy_buffer(srv->tmp_buf, sce->etag);
 						buffer_append_string_len(srv->tmp_buf, CONST_STR_LEN("-"));
 						buffer_append_string(srv->tmp_buf, compression_name);
 						etag_mutate(con->physical.etag, srv->tmp_buf);
@@ -884,7 +883,7 @@
 					}
 
 					/* deflate it */
-					if (use_etag && p->conf.compress_cache_dir->used) {
+					if (use_etag && !buffer_string_is_empty(p->conf.compress_cache_dir)) {
 						if (0 != deflate_file_to_file(srv, con, p, con->physical.path, sce, compression_type))
 							return HANDLER_GO_ON;
 					} else {
@@ -898,7 +897,7 @@
 					}
 					response_header_overwrite(srv, con, CONST_STR_LEN("Content-Type"), CONST_BUF_LEN(sce->content_type));
 					/* let mod_staticfile handle the cached compressed files, physical path was modified */
-					return (use_etag && p->conf.compress_cache_dir->used) ? HANDLER_GO_ON : HANDLER_FINISHED;
+					return (use_etag && !buffer_string_is_empty(p->conf.compress_cache_dir)) ? HANDLER_GO_ON : HANDLER_FINISHED;
 				}
 			}
 		}
diff -u lighttpd-1.4.32/src/mod_dirlisting.c lighttpd-1.4.36/src/mod_dirlisting.c
--- lighttpd-1.4.32/src/mod_dirlisting.c	2011-07-19 06:22:48.000000000 -0500
+++ lighttpd-1.4.36/src/mod_dirlisting.c	2015-07-26 05:36:36.000000000 -0500
@@ -31,6 +31,10 @@
 #include <attr/attributes.h>
 #endif
 
+#ifdef HAVE_SYS_EXTATTR_H
+#include <sys/extattr.h>
+#endif
+
 #include "version.h"
 
 /* plugin config for all request/connections */
@@ -120,7 +124,7 @@
 	}
 
 	exb->ptr[exb->used]->string = buffer_init();
-	buffer_copy_string_buffer(exb->ptr[exb->used]->string, string);
+	buffer_copy_buffer(exb->ptr[exb->used]->string, string);
 
 	exb->used++;
 
@@ -194,47 +198,6 @@
 	return HANDLER_GO_ON;
 }
 
-static int parse_config_entry(server *srv, plugin_config *s, array *ca, const char *option) {
-	data_unset *du;
-
-	if (NULL != (du = array_get_element(ca, option))) {
-		data_array *da;
-		size_t j;
-
-		if (du->type != TYPE_ARRAY) {
-			log_error_write(srv, __FILE__, __LINE__, "sss",
-				"unexpected type for key: ", option, "array of strings");
-
-			return HANDLER_ERROR;
-		}
-
-		da = (data_array *)du;
-
-		for (j = 0; j < da->value->used; j++) {
-			if (da->value->data[j]->type != TYPE_STRING) {
-				log_error_write(srv, __FILE__, __LINE__, "sssbs",
-					"unexpected type for key: ", option, "[",
-					da->value->data[j]->key, "](string)");
-
-				return HANDLER_ERROR;
-			}
-
-			if (0 != excludes_buffer_append(s->excludes,
-				    ((data_string *)(da->value->data[j]))->value)) {
-#ifdef HAVE_PCRE_H
-				log_error_write(srv, __FILE__, __LINE__, "sb",
-						"pcre-compile failed for", ((data_string *)(da->value->data[j]))->value);
-#else
-				log_error_write(srv, __FILE__, __LINE__, "s",
-						"pcre support is missing, please install libpcre and the headers");
-#endif
-			}
-		}
-	}
-
-	return 0;
-}
-
 /* handle plugin config and check values */
 
 #define CONFIG_EXCLUDE          "dir-listing.exclude"
@@ -278,11 +241,12 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
 		array *ca;
+		data_unset *du_excludes;
 
 		s = calloc(1, sizeof(plugin_config));
 		s->excludes = excludes_buffer_init();
@@ -322,7 +286,43 @@
 			return HANDLER_ERROR;
 		}
 
-		parse_config_entry(srv, s, ca, CONFIG_EXCLUDE);
+		if (NULL != (du_excludes = array_get_element(ca, CONFIG_EXCLUDE))) {
+			array *excludes_list;
+			size_t j;
+
+			if (du_excludes->type != TYPE_ARRAY) {
+				log_error_write(srv, __FILE__, __LINE__, "sss",
+					"unexpected type for key: ", CONFIG_EXCLUDE, "array of strings");
+				return HANDLER_ERROR;
+			}
+
+			excludes_list = ((data_array*)du_excludes)->value;
+
+#ifndef HAVE_PCRE_H
+			if (excludes_list->used > 0) {
+				log_error_write(srv, __FILE__, __LINE__, "sss",
+					"pcre support is missing for: ", CONFIG_EXCLUDE, ", please install libpcre and the headers");
+				return HANDLER_ERROR;
+			}
+#else
+			for (j = 0; j < excludes_list->used; j++) {
+				data_unset *du_exclude = excludes_list->data[j];
+
+				if (du_exclude->type != TYPE_STRING) {
+					log_error_write(srv, __FILE__, __LINE__, "sssbs",
+						"unexpected type for key: ", CONFIG_EXCLUDE, "[",
+						du_exclude->key, "](string)");
+					return HANDLER_ERROR;
+				}
+
+				if (0 != excludes_buffer_append(s->excludes, ((data_string*)(du_exclude))->value)) {
+					log_error_write(srv, __FILE__, __LINE__, "sb",
+						"pcre-compile failed for", ((data_string*)(du_exclude))->value);
+					return HANDLER_ERROR;
+				}
+			}
+#endif
+		}
 	}
 
 	return HANDLER_GO_ON;
@@ -469,7 +469,8 @@
 		u++;
 	}
 
-	out   += LI_ltostr(out, size);
+	li_itostr(out, size);
+	out += strlen(out);
 	out[0] = '.';
 	out[1] = remain + '0';
 	out[2] = *u;
@@ -491,7 +492,7 @@
 		buffer_append_string_encoded(out, CONST_BUF_LEN(con->uri.path), ENCODING_MINIMAL_XML);
 		buffer_append_string_len(out, CONST_STR_LEN("</title>\n"));
 
-		if (p->conf.external_css->used > 1) {
+		if (!buffer_string_is_empty(p->conf.external_css)) {
 			buffer_append_string_len(out, CONST_STR_LEN("<link rel=\"stylesheet\" type=\"text/css\" href=\""));
 			buffer_append_string_buffer(out, p->conf.external_css);
 			buffer_append_string_len(out, CONST_STR_LEN("\" />\n"));
@@ -539,8 +540,8 @@
 		stream s;
 		/* if we have a HEADER file, display it in <pre class="header"></pre> */
 
-		buffer_copy_string_buffer(p->tmp_buf, con->physical.path);
-		BUFFER_APPEND_SLASH(p->tmp_buf);
+		buffer_copy_buffer(p->tmp_buf, con->physical.path);
+		buffer_append_slash(p->tmp_buf);
 		buffer_append_string_len(p->tmp_buf, CONST_STR_LEN("HEADER.txt"));
 
 		if (-1 != stream_open(&s, p->tmp_buf)) {
@@ -592,8 +593,8 @@
 		stream s;
 		/* if we have a README file, display it in <pre class="readme"></pre> */
 
-		buffer_copy_string_buffer(p->tmp_buf,  con->physical.path);
-		BUFFER_APPEND_SLASH(p->tmp_buf);
+		buffer_copy_buffer(p->tmp_buf,  con->physical.path);
+		buffer_append_slash(p->tmp_buf);
 		buffer_append_string_len(p->tmp_buf, CONST_STR_LEN("README.txt"));
 
 		if (-1 != stream_open(&s, p->tmp_buf)) {
@@ -613,7 +614,7 @@
 			"<div class=\"foot\">"
 		));
 
-		if (p->conf.set_footer->used > 1) {
+		if (buffer_string_is_empty(p->conf.set_footer)) {
 			buffer_append_string_buffer(out, p->conf.set_footer);
 		} else if (buffer_is_empty(con->conf.server_tag)) {
 			buffer_append_string_len(out, CONST_STR_LEN(PACKAGE_DESC));
@@ -644,7 +645,7 @@
 	size_t k;
 	const char *content_type;
 	long name_max;
-#ifdef HAVE_XATTR
+#if defined(HAVE_XATTR) || defined(HAVE_EXTATTR)
 	char attrval[128];
 	int attrlen;
 #endif
@@ -652,9 +653,9 @@
 	struct tm tm;
 #endif
 
-	if (dir->used == 0) return -1;
+	if (buffer_string_is_empty(dir)) return -1;
 
-	i = dir->used - 1;
+	i = buffer_string_length(dir);
 
 #ifdef HAVE_PATHCONF
 	if (0 >= (name_max = pathconf(dir->ptr, _PC_NAME_MAX))) {
@@ -671,8 +672,8 @@
 	name_max = NAME_MAX;
 #endif
 
-	path = malloc(dir->used + name_max);
-	assert(path);
+	path = malloc(buffer_string_length(dir) + name_max + 1);
+	force_assert(NULL != path);
 	strcpy(path, dir->ptr);
 	path_file = path + i;
 
@@ -685,11 +686,11 @@
 	}
 
 	dirs.ent   = (dirls_entry_t**) malloc(sizeof(dirls_entry_t*) * DIRLIST_BLOB_SIZE);
-	assert(dirs.ent);
+	force_assert(dirs.ent);
 	dirs.size  = DIRLIST_BLOB_SIZE;
 	dirs.used  = 0;
 	files.ent  = (dirls_entry_t**) malloc(sizeof(dirls_entry_t*) * DIRLIST_BLOB_SIZE);
-	assert(files.ent);
+	force_assert(files.ent);
 	files.size = DIRLIST_BLOB_SIZE;
 	files.used = 0;
 
@@ -730,7 +731,11 @@
 					log_error_write(srv, __FILE__, __LINE__, "sd",
 						"execution error while matching:", n);
 
-					return -1;
+					/* aborting would require a lot of manual cleanup here.
+					 * skip instead (to not leak names that break pcre matching)
+					 */
+					exclude_match = 1;
+					break;
 				}
 			}
 			else {
@@ -762,7 +767,7 @@
 		if (list->used == list->size) {
 			list->size += DIRLIST_BLOB_SIZE;
 			list->ent   = (dirls_entry_t**) realloc(list->ent, sizeof(dirls_entry_t*) * list->size);
-			assert(list->ent);
+			force_assert(list->ent);
 		}
 
 		tmp = (dirls_entry_t*) malloc(sizeof(dirls_entry_t) + 1 + i);
@@ -779,9 +784,9 @@
 
 	if (files.used) http_dirls_sort(files.ent, files.used);
 
-	out = chunkqueue_get_append_buffer(con->write_queue);
+	out = buffer_init();
 	buffer_copy_string_len(out, CONST_STR_LEN("<?xml version=\"1.0\" encoding=\""));
-	if (buffer_is_empty(p->conf.encoding)) {
+	if (buffer_string_is_empty(p->conf.encoding)) {
 		buffer_append_string_len(out, CONST_STR_LEN("iso-8859-1"));
 	} else {
 		buffer_append_string_buffer(out, p->conf.encoding);
@@ -816,8 +821,7 @@
 		tmp = files.ent[i];
 
 		content_type = NULL;
-#ifdef HAVE_XATTR
-
+#if defined(HAVE_XATTR)
 		if (con->conf.use_xattr) {
 			memcpy(path_file, DIRLIST_ENT_NAME(tmp), tmp->namelen + 1);
 			attrlen = sizeof(attrval) - 1;
@@ -826,6 +830,14 @@
 				content_type = attrval;
 			}
 		}
+#elif defined(HAVE_EXTATTR)
+		if (con->conf.use_xattr) {
+			memcpy(path_file, DIRLIST_ENT_NAME(tmp), tmp->namelen + 1);
+			if(-1 != (attrlen = extattr_get_file(path, EXTATTR_NAMESPACE_USER, "Content-Type", attrval, sizeof(attrval)-1))) {
+				attrval[attrlen] = '\0';
+				content_type = attrval;
+			}
+		}
 #endif
 
 		if (content_type == NULL) {
@@ -834,10 +846,10 @@
 				data_string *ds = (data_string *)con->conf.mimetypes->data[k];
 				size_t ct_len;
 
-				if (ds->key->used == 0)
+				if (buffer_is_empty(ds->key))
 					continue;
 
-				ct_len = ds->key->used - 1;
+				ct_len = buffer_string_length(ds->key);
 				if (tmp->namelen < ct_len)
 					continue;
 
@@ -878,7 +890,7 @@
 	http_list_directory_footer(srv, con, p, out);
 
 	/* Insert possible charset to Content-Type */
-	if (buffer_is_empty(p->conf.encoding)) {
+	if (buffer_string_is_empty(p->conf.encoding)) {
 		response_header_overwrite(srv, con, CONST_STR_LEN("Content-Type"), CONST_STR_LEN("text/html"));
 	} else {
 		buffer_copy_string_len(p->content_charset, CONST_STR_LEN("text/html; charset="));
@@ -887,6 +899,8 @@
 	}
 
 	con->file_finished = 1;
+	chunkqueue_append_buffer(con->write_queue, out);
+	buffer_free(out);
 
 	return 0;
 }
@@ -911,9 +925,9 @@
 
 	if (con->mode != DIRECT) return HANDLER_GO_ON;
 
-	if (con->physical.path->used == 0) return HANDLER_GO_ON;
-	if (con->uri.path->used == 0) return HANDLER_GO_ON;
-	if (con->uri.path->ptr[con->uri.path->used - 2] != '/') return HANDLER_GO_ON;
+	if (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;
+	if (buffer_is_empty(con->uri.path)) return HANDLER_GO_ON;
+	if (con->uri.path->ptr[buffer_string_length(con->uri.path) - 1] != '/') return HANDLER_GO_ON;
 
 	mod_dirlisting_patch_connection(srv, con, p);
 
diff -u lighttpd-1.4.32/src/mod_evasive.c lighttpd-1.4.36/src/mod_evasive.c
--- lighttpd-1.4.32/src/mod_evasive.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/mod_evasive.c	2015-07-26 05:36:36.000000000 -0500
@@ -58,6 +58,8 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
+			if (NULL == s) continue;
+
 			free(s);
 		}
 		free(p->config_storage);
@@ -78,7 +80,7 @@
 		{ NULL,                          NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
 	};
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -138,7 +140,7 @@
 	size_t conns_by_ip = 0;
 	size_t j;
 
-	if (con->uri.path->used == 0) return HANDLER_GO_ON;
+	if (buffer_is_empty(con->uri.path)) return HANDLER_GO_ON;
 
 	mod_evasive_patch_connection(srv, con, p);
 
diff -u lighttpd-1.4.32/src/mod_evhost.c lighttpd-1.4.36/src/mod_evhost.c
--- lighttpd-1.4.32/src/mod_evhost.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/mod_evhost.c	2015-07-26 05:36:36.000000000 -0500
@@ -46,7 +46,7 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
-			if (!s) continue;
+			if (NULL == s) continue;
 
 			if(s->path_pieces) {
 				size_t j;
@@ -128,7 +128,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -146,7 +146,7 @@
 			return HANDLER_ERROR;
 		}
 
-		if (s->path_pieces_raw->used != 0) {
+		if (!buffer_string_is_empty(s->path_pieces_raw)) {
 			mod_evhost_parse_pattern(s);
 		}
 	}
@@ -164,8 +164,7 @@
  */
 
 static int mod_evhost_parse_host(connection *con,array *host) {
-	/* con->uri.authority->used is always > 0 if we come here */
-	register char *ptr = con->uri.authority->ptr + con->uri.authority->used - 1;
+	register char *ptr = con->uri.authority->ptr + buffer_string_length(con->uri.authority);
 	char *colon = ptr; /* needed to filter out the colon (if exists) */
 	int first = 1;
 	data_string *ds;
@@ -200,7 +199,7 @@
 					/* is something between the dots */
 					ds = data_string_init();
 					buffer_copy_string_len(ds->key,CONST_STR_LEN("%"));
-					buffer_append_long(ds->key, i++);
+					buffer_append_int(ds->key, i++);
 					buffer_copy_string_len(ds->value,ptr+1,colon-ptr-1);
 
 					array_insert_unique(host,(data_unset *)ds);
@@ -213,7 +212,7 @@
 		if (colon != ptr) {
 			ds = data_string_init();
 			buffer_copy_string_len(ds->key,CONST_STR_LEN("%"));
-			buffer_append_long(ds->key, i /* ++ */);
+			buffer_append_int(ds->key, i /* ++ */);
 			buffer_copy_string_len(ds->value,ptr,colon-ptr);
 
 			array_insert_unique(host,(data_unset *)ds);
@@ -265,7 +264,7 @@
 	stat_cache_entry *sce = NULL;
 
 	/* not authority set */
-	if (con->uri.authority->used == 0) return HANDLER_GO_ON;
+	if (buffer_string_is_empty(con->uri.authority)) return HANDLER_GO_ON;
 
 	mod_evhost_patch_connection(srv, con, p);
 
@@ -300,9 +299,7 @@
 					buffer_append_string_len(p->tmp_buf, con->uri.authority->ptr, colon - con->uri.authority->ptr); /* adds fqdn */
 				}
 			} else if (NULL != (ds = (data_string *)array_get_element(parsed_host,p->conf.path_pieces[i]->ptr))) {
-				if (ds->value->used) {
-					buffer_append_string_buffer(p->tmp_buf,ds->value);
-				}
+				buffer_append_string_buffer(p->tmp_buf,ds->value);
 			} else {
 				/* unhandled %-sequence */
 			}
@@ -311,7 +308,7 @@
 		}
 	}
 
-	BUFFER_APPEND_SLASH(p->tmp_buf);
+	buffer_append_slash(p->tmp_buf);
 
 	array_free(parsed_host);
 
@@ -324,7 +321,7 @@
 	}
 
 	if (!not_good) {
-		buffer_copy_string_buffer(con->physical.doc_root, p->tmp_buf);
+		buffer_copy_buffer(con->physical.doc_root, p->tmp_buf);
 	}
 
 	return HANDLER_GO_ON;
diff -u lighttpd-1.4.32/src/mod_expire.c lighttpd-1.4.36/src/mod_expire.c
--- lighttpd-1.4.32/src/mod_expire.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/mod_expire.c	2015-07-26 05:36:36.000000000 -0500
@@ -43,7 +43,7 @@
 
 	p->expire_tstmp = buffer_init();
 
-	buffer_prepare_copy(p->expire_tstmp, 255);
+	buffer_string_prepare_copy(p->expire_tstmp, 255);
 
 	return p;
 }
@@ -62,7 +62,8 @@
 		size_t i;
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
-			if (!s) continue;
+
+			if (NULL == s) continue;
 
 			array_free(s->expire_url);
 			free(s);
@@ -90,7 +91,7 @@
 	 * e.g. 'access 1 years'
 	 */
 
-	if (expire->used == 0) {
+	if (buffer_string_is_empty(expire)) {
 		log_error_write(srv, __FILE__, __LINE__, "s",
 				"empty:");
 		return -1;
@@ -221,7 +222,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -288,25 +289,25 @@
 	int s_len;
 	size_t k;
 
-	if (con->uri.path->used == 0) return HANDLER_GO_ON;
+	if (buffer_is_empty(con->uri.path)) return HANDLER_GO_ON;
 
 	mod_expire_patch_connection(srv, con, p);
 
-	s_len = con->uri.path->used - 1;
+	s_len = buffer_string_length(con->uri.path);
 
 	for (k = 0; k < p->conf.expire_url->used; k++) {
 		data_string *ds = (data_string *)p->conf.expire_url->data[k];
-		int ct_len = ds->key->used - 1;
+		int ct_len = buffer_string_length(ds->key);
 
 		if (ct_len > s_len) continue;
-		if (ds->key->used == 0) continue;
+		if (buffer_is_empty(ds->key)) continue;
 
 		if (0 == strncmp(con->uri.path->ptr, ds->key->ptr, ct_len)) {
 			time_t ts, expires;
-			size_t len;
 			stat_cache_entry *sce = NULL;
 
-			stat_cache_get_entry(srv, con, con->physical.path, &sce);
+			/* if stat fails => sce == NULL, ignore return value */
+			(void) stat_cache_get_entry(srv, con, con->physical.path, &sce);
 
 			switch(mod_expire_get_offset(srv, p, ds->value, &ts)) {
 			case 0:
@@ -316,31 +317,30 @@
 			case 1:
 				/* modification */
 
+				/* can't set modification based expire header if
+				 * mtime is not available
+				 */
+				if (NULL == sce) return HANDLER_GO_ON;
+
 				expires = (ts + sce->st.st_mtime);
 				break;
 			default:
 				/* -1 is handled at parse-time */
-				break;
+				return HANDLER_ERROR;
 			}
 
 			/* expires should be at least srv->cur_ts */
 			if (expires < srv->cur_ts) expires = srv->cur_ts;
 
-			if (0 == (len = strftime(p->expire_tstmp->ptr, p->expire_tstmp->size - 1,
-					   "%a, %d %b %Y %H:%M:%S GMT", gmtime(&(expires))))) {
-				/* could not set expire header, out of mem */
-
-				return HANDLER_GO_ON;
-			}
-
-			p->expire_tstmp->used = len + 1;
+			buffer_string_prepare_copy(p->expire_tstmp, 255);
+			buffer_append_strftime(p->expire_tstmp, "%a, %d %b %Y %H:%M:%S GMT", gmtime(&(expires)));
 
 			/* HTTP/1.0 */
 			response_header_overwrite(srv, con, CONST_STR_LEN("Expires"), CONST_BUF_LEN(p->expire_tstmp));
 
 			/* HTTP/1.1 */
 			buffer_copy_string_len(p->expire_tstmp, CONST_STR_LEN("max-age="));
-			buffer_append_long(p->expire_tstmp, expires - srv->cur_ts); /* as expires >= srv->cur_ts the difference is >= 0 */
+			buffer_append_int(p->expire_tstmp, expires - srv->cur_ts); /* as expires >= srv->cur_ts the difference is >= 0 */
 
 			response_header_append(srv, con, CONST_STR_LEN("Cache-Control"), CONST_BUF_LEN(p->expire_tstmp));
 
diff -u lighttpd-1.4.32/src/mod_extforward.c lighttpd-1.4.36/src/mod_extforward.c
--- lighttpd-1.4.32/src/mod_extforward.c	2012-11-15 02:32:52.000000000 -0600
+++ lighttpd-1.4.36/src/mod_extforward.c	2015-07-26 05:36:36.000000000 -0500
@@ -11,6 +11,7 @@
 #include "config.h"
 #endif
 
+#include <assert.h>
 #include <ctype.h>
 #include <stdlib.h>
 #include <string.h>
@@ -134,7 +135,7 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
-			if (!s) continue;
+			if (NULL == s) continue;
 
 			array_free(s->forwarder);
 			array_free(s->headers);
@@ -164,7 +165,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -235,7 +236,7 @@
 static array *extract_forward_array(buffer *pbuffer)
 {
 	array *result = array_init();
-	if (pbuffer->used > 0) {
+	if (!buffer_string_is_empty(pbuffer)) {
 		char *base, *curr;
 		/* state variable, 0 means not in string, 1 means in string */
 		int in_str = 0;
@@ -303,11 +304,14 @@
 	return NULL;
 }
 
-static struct addrinfo *ipstr_to_sockaddr(server *srv, const char *host) {
-	struct addrinfo hints, *res0;
+#ifdef HAVE_IPV6
+static void ipstr_to_sockaddr(server *srv, const char *host, sock_addr *sock) {
+	struct addrinfo hints, *addrlist = NULL;
 	int result;
 
 	memset(&hints, 0, sizeof(hints));
+	sock->plain.sa_family = AF_UNSPEC;
+
 #ifndef AI_NUMERICSERV
 	/**
 	  * quoting $ man getaddrinfo
@@ -321,22 +325,31 @@
 	hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV;
 
 	errno = 0;
-	result = getaddrinfo(host, NULL, &hints, &res0);
+	result = getaddrinfo(host, NULL, &hints, &addrlist);
 
 	if (result != 0) {
 		log_error_write(srv, __FILE__, __LINE__, "SSSs(S)",
-			"could not resolve hostname ", host, " because ", gai_strerror(result), strerror(errno));
-
-		return NULL;
-	} else if (res0 == NULL) {
+			"could not parse ip address ", host, " because ", gai_strerror(result), strerror(errno));
+	} else if (addrlist == NULL) {
+		log_error_write(srv, __FILE__, __LINE__, "SSS",
+			"Problem in parsing ip address ", host, ": succeeded, but no information returned");
+	} else switch (addrlist->ai_family) {
+	case AF_INET:
+		memcpy(&sock->ipv4, addrlist->ai_addr, sizeof(sock->ipv4));
+		force_assert(AF_INET == sock->plain.sa_family);
+		break;
+	case AF_INET6:
+		memcpy(&sock->ipv6, addrlist->ai_addr, sizeof(sock->ipv6));
+		force_assert(AF_INET6 == sock->plain.sa_family);
+		break;
+	default:
 		log_error_write(srv, __FILE__, __LINE__, "SSS",
-			"Problem in resolving hostname ", host, ": succeeded, but no information returned");
+			"Problem in parsing ip address ", host, ": succeeded, but unknown family");
 	}
 
-	return res0;
+	freeaddrinfo(addrlist);
 }
-
-
+#endif
 
 static void clean_cond_cache(server *srv, connection *con) {
 	config_cond_cache_reset_item(srv, con, COMP_HTTP_REMOTE_IP);
@@ -347,7 +360,6 @@
 	data_string *forwarded = NULL;
 #ifdef HAVE_IPV6
 	char b2[INET6_ADDRSTRLEN + 1];
-	struct addrinfo *addrlist = NULL;
 #endif
 	const char *dst_addr_str = NULL;
 	array *forward_array = NULL;
@@ -411,42 +423,32 @@
 
 	if (real_remote_addr != NULL) { /* parsed */
 		sock_addr sock;
-		struct addrinfo *addrs_left;
-		server_socket *srv_sock = con->srv_socket;
 		data_string *forwarded_proto = (data_string *)array_get_element(con->request.headers, "X-Forwarded-Proto");
 
-		if (forwarded_proto && !strcmp(forwarded_proto->value->ptr, "https")) {
-			srv_sock->is_proxy_ssl = 1;
-		} else {
-			srv_sock->is_proxy_ssl = 0;
+		if (NULL != forwarded_proto) {
+			if (buffer_is_equal_caseless_string(forwarded_proto->value, CONST_STR_LEN("https"))) {
+				buffer_copy_string_len(con->uri.scheme, CONST_STR_LEN("https"));
+			} else if (buffer_is_equal_caseless_string(forwarded_proto->value, CONST_STR_LEN("http"))) {
+				buffer_copy_string_len(con->uri.scheme, CONST_STR_LEN("http"));
+			}
 		}
 
 		if (con->conf.log_request_handling) {
- 			log_error_write(srv, __FILE__, __LINE__, "ss", "using address:", real_remote_addr);
+			log_error_write(srv, __FILE__, __LINE__, "ss", "using address:", real_remote_addr);
 		}
 #ifdef HAVE_IPV6
-		addrlist = ipstr_to_sockaddr(srv, real_remote_addr);
-		sock.plain.sa_family = AF_UNSPEC;
-		for (addrs_left = addrlist; addrs_left != NULL; addrs_left = addrs_left -> ai_next) {
-			sock.plain.sa_family = addrs_left->ai_family;
-			if (sock.plain.sa_family == AF_INET) {
-				sock.ipv4.sin_addr = ((struct sockaddr_in*)addrs_left->ai_addr)->sin_addr;
-				break;
-			} else if (sock.plain.sa_family == AF_INET6) {
-				sock.ipv6.sin6_addr = ((struct sockaddr_in6*)addrs_left->ai_addr)->sin6_addr;
-				break;
-			}
-		}
+		ipstr_to_sockaddr(srv, real_remote_addr, &sock);
 #else
-		UNUSED(addrs_left);
 		sock.ipv4.sin_addr.s_addr = inet_addr(real_remote_addr);
 		sock.plain.sa_family = (sock.ipv4.sin_addr.s_addr == 0xFFFFFFFF) ? AF_UNSPEC : AF_INET;
 #endif
 		if (sock.plain.sa_family != AF_UNSPEC) {
 			/* we found the remote address, modify current connection and save the old address */
 			if (con->plugin_ctx[p->id]) {
-				log_error_write(srv, __FILE__, __LINE__, "s", 
-						"patching an already patched connection!");
+				if (con->conf.log_request_handling) {
+					log_error_write(srv, __FILE__, __LINE__, "s",
+						"-- mod_extforward_uri_handler already patched this connection, resetting state");
+				}
 				handler_ctx_free(con->plugin_ctx[p->id]);
 				con->plugin_ctx[p->id] = NULL;
 			}
@@ -456,7 +458,7 @@
 			con->dst_addr = sock;
 			con->dst_addr_buf = buffer_init();
 			buffer_copy_string(con->dst_addr_buf, real_remote_addr);
-		
+
 			if (con->conf.log_request_handling) {
 				log_error_write(srv, __FILE__, __LINE__, "ss",
 						"patching con->dst_addr_buf for the accesslog:", real_remote_addr);
@@ -464,9 +466,6 @@
 			/* Now, clean the conf_cond cache, because we may have changed the results of tests */
 			clean_cond_cache(srv, con);
 		}
-#ifdef HAVE_IPV6
-		if (addrlist != NULL ) freeaddrinfo(addrlist);
-#endif
 	}
 	array_free(forward_array);
 
diff -u lighttpd-1.4.32/src/mod_fastcgi.c lighttpd-1.4.36/src/mod_fastcgi.c
--- lighttpd-1.4.32/src/mod_fastcgi.c	2012-11-17 11:32:14.000000000 -0600
+++ lighttpd-1.4.36/src/mod_fastcgi.c	2015-07-26 05:36:36.000000000 -0500
@@ -52,13 +52,6 @@
 
 #include "version.h"
 
-#define FCGI_ENV_ADD_CHECK(ret, con) \
-	if (ret == -1) { \
-		con->http_status = 400; \
-		con->file_finished = 1; \
-		return -1; \
-	};
-
 /*
  *
  * TODO:
@@ -318,7 +311,6 @@
 	buffer *fcgi_env;
 
 	buffer *path;
-	buffer *parse_response;
 
 	buffer *statuskey;
 
@@ -391,7 +383,7 @@
 	buffer_append_string_buffer(b, host->id);
 	if (proc) {
 		buffer_append_string_len(b, CONST_STR_LEN("."));
-		buffer_append_long(b, proc->id);
+		buffer_append_int(b, proc->id);
 	}
 }
 
@@ -487,7 +479,7 @@
 	handler_ctx * hctx;
 
 	hctx = calloc(1, sizeof(*hctx));
-	assert(hctx);
+	force_assert(hctx);
 
 	hctx->fde_ndx = -1;
 
@@ -634,21 +626,21 @@
 	if (i == ext->used) {
 		/* filextension is new */
 		fe = calloc(1, sizeof(*fe));
-		assert(fe);
+		force_assert(fe);
 		fe->key = buffer_init();
 		fe->last_used_ndx = -1;
-		buffer_copy_string_buffer(fe->key, key);
+		buffer_copy_buffer(fe->key, key);
 
 		/* */
 
 		if (ext->size == 0) {
 			ext->size = 8;
 			ext->exts = malloc(ext->size * sizeof(*(ext->exts)));
-			assert(ext->exts);
+			force_assert(ext->exts);
 		} else if (ext->used == ext->size) {
 			ext->size += 8;
 			ext->exts = realloc(ext->exts, ext->size * sizeof(*(ext->exts)));
-			assert(ext->exts);
+			force_assert(ext->exts);
 		}
 		ext->exts[ext->used++] = fe;
 	} else {
@@ -658,11 +650,11 @@
 	if (fe->size == 0) {
 		fe->size = 4;
 		fe->hosts = malloc(fe->size * sizeof(*(fe->hosts)));
-		assert(fe->hosts);
+		force_assert(fe->hosts);
 	} else if (fe->size == fe->used) {
 		fe->size += 4;
 		fe->hosts = realloc(fe->hosts, fe->size * sizeof(*(fe->hosts)));
-		assert(fe->hosts);
+		force_assert(fe->hosts);
 	}
 
 	fe->hosts[fe->used++] = fh;
@@ -679,7 +671,6 @@
 	p->fcgi_env = buffer_init();
 
 	p->path = buffer_init();
-	p->parse_response = buffer_init();
 
 	p->statuskey = buffer_init();
 
@@ -694,7 +685,6 @@
 
 	buffer_free(p->fcgi_env);
 	buffer_free(p->path);
-	buffer_free(p->parse_response);
 	buffer_free(p->statuskey);
 
 	if (p->config_storage) {
@@ -703,7 +693,7 @@
 			plugin_config *s = p->config_storage[i];
 			fcgi_exts *exts;
 
-			if (!s) continue;
+			if (NULL == s) continue;
 
 			exts = s->exts;
 
@@ -724,7 +714,7 @@
 						}
 
 						if (proc->is_local &&
-						    !buffer_is_empty(proc->unixsocket)) {
+						    !buffer_string_is_empty(proc->unixsocket)) {
 							unlink(proc->unixsocket->ptr);
 						}
 					}
@@ -734,7 +724,7 @@
 							kill(proc->pid, host->kill_signal);
 						}
 						if (proc->is_local &&
-						    !buffer_is_empty(proc->unixsocket)) {
+						    !buffer_string_is_empty(proc->unixsocket)) {
 							unlink(proc->unixsocket->ptr);
 						}
 					}
@@ -794,7 +784,7 @@
 	/* search for spaces */
 
 	start = b->ptr;
-	for (i = 0; i < b->used - 1; i++) {
+	for (i = 0; i < buffer_string_length(b); i++) {
 		switch(b->ptr[i]) {
 		case ' ':
 		case '\t':
@@ -868,18 +858,24 @@
 				"new proc, socket:", proc->port, proc->unixsocket);
 	}
 
-	if (!buffer_is_empty(proc->unixsocket)) {
+	if (!buffer_string_is_empty(proc->unixsocket)) {
 		memset(&fcgi_addr, 0, sizeof(fcgi_addr));
 
 #ifdef HAVE_SYS_UN_H
 		fcgi_addr_un.sun_family = AF_UNIX;
-		strcpy(fcgi_addr_un.sun_path, proc->unixsocket->ptr);
+		if (buffer_string_length(proc->unixsocket) + 1 > sizeof(fcgi_addr_un.sun_path)) {
+			log_error_write(srv, __FILE__, __LINE__, "sB",
+					"ERROR: Unix Domain socket filename too long:",
+					proc->unixsocket);
+			return -1;
+		}
+		memcpy(fcgi_addr_un.sun_path, proc->unixsocket->ptr, buffer_string_length(proc->unixsocket) + 1);
 
 #ifdef SUN_LEN
 		servlen = SUN_LEN(&fcgi_addr_un);
 #else
 		/* stevens says: */
-		servlen = proc->unixsocket->used + sizeof(fcgi_addr_un.sun_family);
+		servlen = buffer_string_length(proc->unixsocket) + 1 + sizeof(fcgi_addr_un.sun_family);
 #endif
 		socket_type = AF_UNIX;
 		fcgi_addr = (struct sockaddr *) &fcgi_addr_un;
@@ -895,7 +891,7 @@
 	} else {
 		fcgi_addr_in.sin_family = AF_INET;
 
-		if (buffer_is_empty(host->host)) {
+		if (buffer_string_is_empty(host->host)) {
 			fcgi_addr_in.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 		} else {
 			struct hostent *he;
@@ -931,13 +927,13 @@
 		fcgi_addr = (struct sockaddr *) &fcgi_addr_in;
 
 		buffer_copy_string_len(proc->connection_name, CONST_STR_LEN("tcp:"));
-		if (!buffer_is_empty(host->host)) {
+		if (!buffer_string_is_empty(host->host)) {
 			buffer_append_string_buffer(proc->connection_name, host->host);
 		} else {
 			buffer_append_string_len(proc->connection_name, CONST_STR_LEN("localhost"));
 		}
 		buffer_append_string_len(proc->connection_name, CONST_STR_LEN(":"));
-		buffer_append_long(proc->connection_name, proc->port);
+		buffer_append_int(proc->connection_name, proc->port);
 	}
 
 	if (-1 == (fcgi_fd = socket(socket_type, SOCK_STREAM, 0))) {
@@ -952,7 +948,7 @@
 		int val;
 
 		if (errno != ENOENT &&
-		    !buffer_is_empty(proc->unixsocket)) {
+		    !buffer_string_is_empty(proc->unixsocket)) {
 			unlink(proc->unixsocket->ptr);
 		}
 
@@ -969,6 +965,7 @@
 		if (setsockopt(fcgi_fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val)) < 0) {
 			log_error_write(srv, __FILE__, __LINE__, "ss",
 					"socketsockopt failed:", strerror(errno));
+			close(fcgi_fd);
 			return -1;
 		}
 
@@ -978,12 +975,14 @@
 				"bind failed for:",
 				proc->connection_name,
 				strerror(errno));
+			close(fcgi_fd);
 			return -1;
 		}
 
 		if (-1 == listen(fcgi_fd, 1024)) {
 			log_error_write(srv, __FILE__, __LINE__, "ss",
 				"listen failed:", strerror(errno));
+			close(fcgi_fd);
 			return -1;
 		}
 
@@ -1161,6 +1160,7 @@
 	data_unset *du;
 	size_t i = 0;
 	buffer *fcgi_mode = buffer_init();
+	fcgi_extension_host *host = NULL;
 
 	config_values_t cv[] = {
 		{ "fastcgi.server",              NULL, T_CONFIG_LOCAL, T_CONFIG_SCOPE_CONNECTION },       /* 0 */
@@ -1169,7 +1169,7 @@
 		{ NULL,                          NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
 	};
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -1188,7 +1188,7 @@
 		ca = ((data_config *)srv->config_context->data[i])->value;
 
 		if (0 != config_insert_values_global(srv, ca, cv)) {
-			return HANDLER_ERROR;
+			goto error;
 		}
 
 		/*
@@ -1203,7 +1203,7 @@
 				log_error_write(srv, __FILE__, __LINE__, "sss",
 						"unexpected type for key: ", "fastcgi.server", "array of strings");
 
-				return HANDLER_ERROR;
+				goto error;
 			}
 
 
@@ -1221,7 +1221,7 @@
 							"unexpected type for key: ", "fastcgi.server",
 							"[", da->value->data[j]->key, "](string)");
 
-					return HANDLER_ERROR;
+					goto error;
 				}
 
 				/*
@@ -1239,8 +1239,6 @@
 				for (n = 0; n < da_ext->value->used; n++) {
 					data_array *da_host = (data_array *)da_ext->value->data[n];
 
-					fcgi_extension_host *host;
-
 					config_values_t fcv[] = {
 						{ "host",              NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },       /* 0 */
 						{ "docroot",           NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },       /* 1 */
@@ -1271,12 +1269,13 @@
 								"fastcgi.server",
 								"[", da_host->key, "](string)");
 
-						return HANDLER_ERROR;
+						goto error;
 					}
 
 					host = fastcgi_host_init();
+					buffer_reset(fcgi_mode);
 
-					buffer_copy_string_buffer(host->id, da_host->key);
+					buffer_copy_buffer(host->id, da_host->key);
 
 					host->check_local  = 1;
 					host->max_procs    = 4;
@@ -1307,45 +1306,45 @@
 					fcv[15].destination = &(host->fix_root_path_name);
 
 					if (0 != config_insert_values_internal(srv, da_host->value, fcv)) {
-						return HANDLER_ERROR;
+						goto error;
 					}
 
-					if ((!buffer_is_empty(host->host) || host->port) &&
-					    !buffer_is_empty(host->unixsocket)) {
+					if ((!buffer_string_is_empty(host->host) || host->port) &&
+					    !buffer_string_is_empty(host->unixsocket)) {
 						log_error_write(srv, __FILE__, __LINE__, "sbsbsbs",
 								"either host/port or socket have to be set in:",
 								da->key, "= (",
 								da_ext->key, " => (",
 								da_host->key, " ( ...");
 
-						return HANDLER_ERROR;
+						goto error;
 					}
 
-					if (!buffer_is_empty(host->unixsocket)) {
+					if (!buffer_string_is_empty(host->unixsocket)) {
 						/* unix domain socket */
 						struct sockaddr_un un;
 
-						if (host->unixsocket->used > sizeof(un.sun_path) - 2) {
+						if (buffer_string_length(host->unixsocket) + 1 > sizeof(un.sun_path) - 2) {
 							log_error_write(srv, __FILE__, __LINE__, "sbsbsbs",
 									"unixsocket is too long in:",
 									da->key, "= (",
 									da_ext->key, " => (",
 									da_host->key, " ( ...");
 
-							return HANDLER_ERROR;
+							goto error;
 						}
 					} else {
 						/* tcp/ip */
 
-						if (buffer_is_empty(host->host) &&
-						    buffer_is_empty(host->bin_path)) {
+						if (buffer_string_is_empty(host->host) &&
+						    buffer_string_is_empty(host->bin_path)) {
 							log_error_write(srv, __FILE__, __LINE__, "sbsbsbs",
 									"host or binpath have to be set in:",
 									da->key, "= (",
 									da_ext->key, " => (",
 									da_host->key, " ( ...");
 
-							return HANDLER_ERROR;
+							goto error;
 						} else if (host->port == 0) {
 							log_error_write(srv, __FILE__, __LINE__, "sbsbsbs",
 									"port has to be set in:",
@@ -1353,11 +1352,11 @@
 									da_ext->key, " => (",
 									da_host->key, " ( ...");
 
-							return HANDLER_ERROR;
+							goto error;
 						}
 					}
 
-					if (!buffer_is_empty(host->bin_path)) {
+					if (!buffer_string_is_empty(host->bin_path)) {
 						/* a local socket + self spawning */
 						size_t pno;
 
@@ -1377,12 +1376,12 @@
 							proc->id = host->num_procs++;
 							host->max_id++;
 
-							if (buffer_is_empty(host->unixsocket)) {
+							if (buffer_string_is_empty(host->unixsocket)) {
 								proc->port = host->port + pno;
 							} else {
-								buffer_copy_string_buffer(proc->unixsocket, host->unixsocket);
+								buffer_copy_buffer(proc->unixsocket, host->unixsocket);
 								buffer_append_string_len(proc->unixsocket, CONST_STR_LEN("-"));
-								buffer_append_long(proc->unixsocket, pno);
+								buffer_append_int(proc->unixsocket, pno);
 							}
 
 							if (s->debug) {
@@ -1396,13 +1395,14 @@
 							if (fcgi_spawn_connection(srv, p, host, proc)) {
 								log_error_write(srv, __FILE__, __LINE__, "s",
 										"[ERROR]: spawning fcgi failed.");
-								return HANDLER_ERROR;
+								fastcgi_process_free(proc);
+								goto error;
 							}
 
 							fastcgi_status_init(srv, p->statuskey, host, proc);
 
 							proc->next = host->first;
-							if (host->first) 	host->first->prev = proc;
+							if (host->first) host->first->prev = proc;
 
 							host->first = proc;
 						}
@@ -1415,10 +1415,10 @@
 						host->active_procs++;
 						proc->state = PROC_STATE_RUNNING;
 
-						if (buffer_is_empty(host->unixsocket)) {
+						if (buffer_string_is_empty(host->unixsocket)) {
 							proc->port = host->port;
 						} else {
-							buffer_copy_string_buffer(proc->unixsocket, host->unixsocket);
+							buffer_copy_buffer(proc->unixsocket, host->unixsocket);
 						}
 
 						fastcgi_status_init(srv, p->statuskey, host, proc);
@@ -1428,15 +1428,15 @@
 						host->max_procs = 1;
 					}
 
-					if (!buffer_is_empty(fcgi_mode)) {
+					if (!buffer_string_is_empty(fcgi_mode)) {
 						if (strcmp(fcgi_mode->ptr, "responder") == 0) {
 							host->mode = FCGI_RESPONDER;
 						} else if (strcmp(fcgi_mode->ptr, "authorizer") == 0) {
 							host->mode = FCGI_AUTHORIZER;
-							if (buffer_is_empty(host->docroot)) {
+							if (buffer_string_is_empty(host->docroot)) {
 								log_error_write(srv, __FILE__, __LINE__, "s",
 										"ERROR: docroot is required for authorizer mode.");
-								return HANDLER_ERROR;
+								goto error;
 							}
 						} else {
 							log_error_write(srv, __FILE__, __LINE__, "sbs",
@@ -1447,14 +1447,19 @@
 
 					/* if extension already exists, take it */
 					fastcgi_extension_insert(s->exts, da_ext->key, host);
+					host = NULL;
 				}
 			}
 		}
 	}
 
 	buffer_free(fcgi_mode);
-
 	return HANDLER_GO_ON;
+
+error:
+	if (NULL != host) fastcgi_host_free(host);
+	buffer_free(fcgi_mode);
+	return HANDLER_ERROR;
 }
 
 static int fcgi_set_state(server *srv, handler_ctx *hctx, fcgi_connection_state_t state) {
@@ -1570,6 +1575,8 @@
 
 static int fcgi_env_add(buffer *env, const char *key, size_t key_len, const char *val, size_t val_len) {
 	size_t len;
+	char len_enc[8];
+	size_t len_enc_len = 0;
 
 	if (!key || !val) return -1;
 
@@ -1578,7 +1585,7 @@
 	len += key_len > 127 ? 4 : 1;
 	len += val_len > 127 ? 4 : 1;
 
-	if (env->used + len >= FCGI_MAX_LENGTH) {
+	if (buffer_string_length(env) + len >= FCGI_MAX_LENGTH) {
 		/**
 		 * we can't append more headers, ignore it
 		 */
@@ -1590,39 +1597,38 @@
 	 *
 	 * HINT: this can't happen as FCGI_MAX_LENGTH is only 16bit
 	 */
-	if (key_len > 0x7fffffff) key_len = 0x7fffffff;
-	if (val_len > 0x7fffffff) val_len = 0x7fffffff;
+	force_assert(key_len < 0x7fffffffu);
+	force_assert(val_len < 0x7fffffffu);
 
-	buffer_prepare_append(env, len);
+	buffer_string_prepare_append(env, len);
 
 	if (key_len > 127) {
-		env->ptr[env->used++] = ((key_len >> 24) & 0xff) | 0x80;
-		env->ptr[env->used++] = (key_len >> 16) & 0xff;
-		env->ptr[env->used++] = (key_len >> 8) & 0xff;
-		env->ptr[env->used++] = (key_len >> 0) & 0xff;
+		len_enc[len_enc_len++] = ((key_len >> 24) & 0xff) | 0x80;
+		len_enc[len_enc_len++] = (key_len >> 16) & 0xff;
+		len_enc[len_enc_len++] = (key_len >> 8) & 0xff;
+		len_enc[len_enc_len++] = (key_len >> 0) & 0xff;
 	} else {
-		env->ptr[env->used++] = (key_len >> 0) & 0xff;
+		len_enc[len_enc_len++] = (key_len >> 0) & 0xff;
 	}
 
 	if (val_len > 127) {
-		env->ptr[env->used++] = ((val_len >> 24) & 0xff) | 0x80;
-		env->ptr[env->used++] = (val_len >> 16) & 0xff;
-		env->ptr[env->used++] = (val_len >> 8) & 0xff;
-		env->ptr[env->used++] = (val_len >> 0) & 0xff;
+		len_enc[len_enc_len++] = ((val_len >> 24) & 0xff) | 0x80;
+		len_enc[len_enc_len++] = (val_len >> 16) & 0xff;
+		len_enc[len_enc_len++] = (val_len >> 8) & 0xff;
+		len_enc[len_enc_len++] = (val_len >> 0) & 0xff;
 	} else {
-		env->ptr[env->used++] = (val_len >> 0) & 0xff;
+		len_enc[len_enc_len++] = (val_len >> 0) & 0xff;
 	}
 
-	memcpy(env->ptr + env->used, key, key_len);
-	env->used += key_len;
-	memcpy(env->ptr + env->used, val, val_len);
-	env->used += val_len;
+	buffer_append_string_len(env, len_enc, len_enc_len);
+	buffer_append_string_len(env, key, key_len);
+	buffer_append_string_len(env, val, val_len);
 
 	return 0;
 }
 
 static int fcgi_header(FCGI_Header * header, unsigned char type, size_t request_id, int contentLength, unsigned char paddingLength) {
-	assert(contentLength <= FCGI_MAX_LENGTH);
+	force_assert(contentLength <= FCGI_MAX_LENGTH);
 	
 	header->version = FCGI_VERSION_1;
 	header->type = type;
@@ -1657,20 +1663,27 @@
 
 	memset(&fcgi_addr, 0, sizeof(fcgi_addr));
 
-	if (!buffer_is_empty(proc->unixsocket)) {
+	if (!buffer_string_is_empty(proc->unixsocket)) {
 #ifdef HAVE_SYS_UN_H
 		/* use the unix domain socket */
 		fcgi_addr_un.sun_family = AF_UNIX;
-		strcpy(fcgi_addr_un.sun_path, proc->unixsocket->ptr);
+		if (buffer_string_length(proc->unixsocket) + 1 > sizeof(fcgi_addr_un.sun_path)) {
+			log_error_write(srv, __FILE__, __LINE__, "sB",
+					"ERROR: Unix Domain socket filename too long:",
+					proc->unixsocket);
+			return -1;
+		}
+		memcpy(fcgi_addr_un.sun_path, proc->unixsocket->ptr, buffer_string_length(proc->unixsocket) + 1);
+
 #ifdef SUN_LEN
 		servlen = SUN_LEN(&fcgi_addr_un);
 #else
 		/* stevens says: */
-		servlen = proc->unixsocket->used + sizeof(fcgi_addr_un.sun_family);
+		servlen = buffer_string_length(proc->unixsocket) + 1 + sizeof(fcgi_addr_un.sun_family);
 #endif
 		fcgi_addr = (struct sockaddr *) &fcgi_addr_un;
 
-		if (buffer_is_empty(proc->connection_name)) {
+		if (buffer_string_is_empty(proc->connection_name)) {
 			/* on remote spawing we have to set the connection-name now */
 			buffer_copy_string_len(proc->connection_name, CONST_STR_LEN("unix:"));
 			buffer_append_string_buffer(proc->connection_name, proc->unixsocket);
@@ -1680,7 +1693,7 @@
 #endif
 	} else {
 		fcgi_addr_in.sin_family = AF_INET;
-		if (!buffer_is_empty(host->host)) {
+		if (!buffer_string_is_empty(host->host)) {
 			if (0 == inet_aton(host->host->ptr, &(fcgi_addr_in.sin_addr))) {
 				log_error_write(srv, __FILE__, __LINE__, "sbs",
 						"converting IP address failed for", host->host,
@@ -1696,16 +1709,16 @@
 
 		fcgi_addr = (struct sockaddr *) &fcgi_addr_in;
 
-		if (buffer_is_empty(proc->connection_name)) {
+		if (buffer_string_is_empty(proc->connection_name)) {
 			/* on remote spawing we have to set the connection-name now */
 			buffer_copy_string_len(proc->connection_name, CONST_STR_LEN("tcp:"));
-			if (!buffer_is_empty(host->host)) {
+			if (!buffer_string_is_empty(host->host)) {
 				buffer_append_string_buffer(proc->connection_name, host->host);
 			} else {
 				buffer_append_string_len(proc->connection_name, CONST_STR_LEN("localhost"));
 			}
 			buffer_append_string_len(proc->connection_name, CONST_STR_LEN(":"));
-			buffer_append_long(proc->connection_name, proc->port);
+			buffer_append_int(proc->connection_name, proc->port);
 		}
 	}
 
@@ -1747,6 +1760,12 @@
 	return CONNECTION_OK;
 }
 
+#define FCGI_ENV_ADD_CHECK(ret, con) \
+	if (ret == -1) { \
+		con->http_status = 400; \
+		con->file_finished = 1; \
+		return -1; \
+	};
 static int fcgi_env_add_request_headers(server *srv, connection *con, plugin_data *p) {
 	size_t i;
 
@@ -1755,28 +1774,8 @@
 
 		ds = (data_string *)con->request.headers->data[i];
 
-		if (ds->value->used && ds->key->used) {
-			size_t j;
-			buffer_reset(srv->tmp_buf);
-
-			if (0 != strcasecmp(ds->key->ptr, "CONTENT-TYPE")) {
-				buffer_copy_string_len(srv->tmp_buf, CONST_STR_LEN("HTTP_"));
-				srv->tmp_buf->used--;
-			}
-
-			buffer_prepare_append(srv->tmp_buf, ds->key->used + 2);
-			for (j = 0; j < ds->key->used - 1; j++) {
-				char c = '_';
-				if (light_isalpha(ds->key->ptr[j])) {
-					/* upper-case */
-					c = ds->key->ptr[j] & ~32;
-				} else if (light_isdigit(ds->key->ptr[j])) {
-					/* copy */
-					c = ds->key->ptr[j];
-				}
-				srv->tmp_buf->ptr[srv->tmp_buf->used++] = c;
-			}
-			srv->tmp_buf->ptr[srv->tmp_buf->used++] = '\0';
+		if (!buffer_is_empty(ds->value) && !buffer_is_empty(ds->key)) {
+			buffer_copy_string_encoded_cgi_varnames(srv->tmp_buf, CONST_BUF_LEN(ds->key), 1);
 
 			FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_BUF_LEN(srv->tmp_buf), CONST_BUF_LEN(ds->value)),con);
 		}
@@ -1787,23 +1786,8 @@
 
 		ds = (data_string *)con->environment->data[i];
 
-		if (ds->value->used && ds->key->used) {
-			size_t j;
-			buffer_reset(srv->tmp_buf);
-
-			buffer_prepare_append(srv->tmp_buf, ds->key->used + 2);
-			for (j = 0; j < ds->key->used - 1; j++) {
-				char c = '_';
-				if (light_isalpha(ds->key->ptr[j])) {
-					/* upper-case */
-					c = ds->key->ptr[j] & ~32;
-				} else if (light_isdigit(ds->key->ptr[j])) {
-					/* copy */
-					c = ds->key->ptr[j];
-				}
-				srv->tmp_buf->ptr[srv->tmp_buf->used++] = c;
-			}
-			srv->tmp_buf->ptr[srv->tmp_buf->used++] = '\0';
+		if (!buffer_is_empty(ds->value) && !buffer_is_empty(ds->key)) {
+			buffer_copy_string_encoded_cgi_varnames(srv->tmp_buf, CONST_BUF_LEN(ds->key), 0);
 
 			FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_BUF_LEN(srv->tmp_buf), CONST_BUF_LEN(ds->value)), con);
 		}
@@ -1812,13 +1796,11 @@
 	return 0;
 }
 
-
 static int fcgi_create_env(server *srv, handler_ctx *hctx, size_t request_id) {
 	FCGI_BeginRequestRecord beginRecord;
 	FCGI_Header header;
-	buffer *b;
 
-	char buf[32];
+	char buf[LI_ITOSTRING_LENGTH];
 	const char *s;
 #ifdef HAVE_IPV6
 	char b2[INET6_ADDRSTRLEN + 1];
@@ -1841,12 +1823,8 @@
 	beginRecord.body.flags = 0;
 	memset(beginRecord.body.reserved, 0, sizeof(beginRecord.body.reserved));
 
-	b = chunkqueue_get_append_buffer(hctx->wb);
-
-	buffer_copy_memory(b, (const char *)&beginRecord, sizeof(beginRecord));
-
 	/* send FCGI_PARAMS */
-	buffer_prepare_copy(p->fcgi_env, 1024);
+	buffer_string_prepare_copy(p->fcgi_env, 1023);
 
 
 	if (buffer_is_empty(con->conf.server_tag)) {
@@ -1855,8 +1833,8 @@
 		FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("SERVER_SOFTWARE"), CONST_BUF_LEN(con->conf.server_tag)),con)
 	}
 
-	if (con->server_name->used) {
-		size_t len = con->server_name->used - 1;
+	if (!buffer_is_empty(con->server_name)) {
+		size_t len = buffer_string_length(con->server_name);
 
 		if (con->server_name->ptr[0] == '[') {
 			const char *colon = strstr(con->server_name->ptr, "]:");
@@ -1882,7 +1860,7 @@
 
 	FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("GATEWAY_INTERFACE"), CONST_STR_LEN("CGI/1.1")),con)
 
-	LI_ltostr(buf,
+	li_utostr(buf,
 #ifdef HAVE_IPV6
 	       ntohs(srv_sock->addr.plain.sa_family ? srv_sock->addr.ipv6.sin6_port : srv_sock->addr.ipv4.sin_port)
 #else
@@ -1902,7 +1880,7 @@
 	}
 	FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("SERVER_ADDR"), s, strlen(s)),con)
 
-	LI_ltostr(buf,
+	li_utostr(buf,
 #ifdef HAVE_IPV6
 	       ntohs(con->dst_addr.plain.sa_family ? con->dst_addr.ipv6.sin6_port : con->dst_addr.ipv4.sin_port)
 #else
@@ -1915,15 +1893,10 @@
 	s = inet_ntop_cache_get_ip(srv, &(con->dst_addr));
 	FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("REMOTE_ADDR"), s, strlen(s)),con)
 
-	if (!buffer_is_empty(con->authed_user)) {
-		FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("REMOTE_USER"), CONST_BUF_LEN(con->authed_user)),con)
-	}
-
 	if (con->request.content_length > 0 && host->mode != FCGI_AUTHORIZER) {
 		/* CGI-SPEC 6.1.2 and FastCGI spec 6.3 */
 
-		/* request.content_length < SSIZE_MAX, see request.c */
-		LI_ltostr(buf, con->request.content_length);
+		li_itostr(buf, con->request.content_length);
 		FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("CONTENT_LENGTH"), buf, strlen(buf)),con)
 	}
 
@@ -1937,15 +1910,15 @@
 
 		FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("SCRIPT_NAME"), CONST_BUF_LEN(con->uri.path)),con)
 
-		if (!buffer_is_empty(con->request.pathinfo)) {
+		if (!buffer_string_is_empty(con->request.pathinfo)) {
 			FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("PATH_INFO"), CONST_BUF_LEN(con->request.pathinfo)),con)
 
 			/* PATH_TRANSLATED is only defined if PATH_INFO is set */
 
-			if (!buffer_is_empty(host->docroot)) {
-				buffer_copy_string_buffer(p->path, host->docroot);
+			if (!buffer_string_is_empty(host->docroot)) {
+				buffer_copy_buffer(p->path, host->docroot);
 			} else {
-				buffer_copy_string_buffer(p->path, con->physical.basedir);
+				buffer_copy_buffer(p->path, con->physical.basedir);
 			}
 			buffer_append_string_buffer(p->path, con->request.pathinfo);
 			FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("PATH_TRANSLATED"), CONST_BUF_LEN(p->path)),con)
@@ -1962,19 +1935,19 @@
 	 * parameter.
 	 */
 
-	if (!buffer_is_empty(host->docroot)) {
+	if (!buffer_string_is_empty(host->docroot)) {
 		/*
 		 * rewrite SCRIPT_FILENAME
 		 *
 		 */
 
-		buffer_copy_string_buffer(p->path, host->docroot);
+		buffer_copy_buffer(p->path, host->docroot);
 		buffer_append_string_buffer(p->path, con->uri.path);
 
 		FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("SCRIPT_FILENAME"), CONST_BUF_LEN(p->path)),con)
 		FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("DOCUMENT_ROOT"), CONST_BUF_LEN(host->docroot)),con)
 	} else {
-		buffer_copy_string_buffer(p->path, con->physical.path);
+		buffer_copy_buffer(p->path, con->physical.path);
 
 		/* cgi.fix_pathinfo need a broken SCRIPT_FILENAME to find out what PATH_INFO is itself
 		 *
@@ -1988,7 +1961,7 @@
 		FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("DOCUMENT_ROOT"), CONST_BUF_LEN(con->physical.basedir)),con)
 	}
 
-	if (host->strip_request_uri->used > 1) {
+	if (!buffer_string_is_empty(host->strip_request_uri)) {
 		/* we need at least one char to strip off */
 		/**
 		 * /app1/index/list
@@ -1998,18 +1971,18 @@
 		 * /index/list
 		 *
 		 */
-		if ('/' != host->strip_request_uri->ptr[host->strip_request_uri->used - 2]) {
+		if ('/' != host->strip_request_uri->ptr[buffer_string_length(host->strip_request_uri) - 1]) {
 			/* fix the user-input to have / as last char */
 			buffer_append_string_len(host->strip_request_uri, CONST_STR_LEN("/"));
 		}
 
-		if (con->request.orig_uri->used >= host->strip_request_uri->used &&
-		    0 == strncmp(con->request.orig_uri->ptr, host->strip_request_uri->ptr, host->strip_request_uri->used - 1)) {
+		if (buffer_string_length(con->request.orig_uri) >= buffer_string_length(host->strip_request_uri) &&
+		    0 == strncmp(con->request.orig_uri->ptr, host->strip_request_uri->ptr, buffer_string_length(host->strip_request_uri))) {
 			/* the left is the same */
 
-			fcgi_env_add(p->fcgi_env, CONST_STR_LEN("REQUEST_URI"),
-					con->request.orig_uri->ptr + (host->strip_request_uri->used - 2),
-					con->request.orig_uri->used - (host->strip_request_uri->used - 2) - 1);
+			FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("REQUEST_URI"),
+					con->request.orig_uri->ptr + (buffer_string_length(host->strip_request_uri) - 1),
+					buffer_string_length(con->request.orig_uri) - (buffer_string_length(host->strip_request_uri) - 1)), con);
 		} else {
 			FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("REQUEST_URI"), CONST_BUF_LEN(con->request.orig_uri)),con)
 		}
@@ -2019,7 +1992,7 @@
 	if (!buffer_is_equal(con->request.uri, con->request.orig_uri)) {
 		FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("REDIRECT_URI"), CONST_BUF_LEN(con->request.uri)),con)
 	}
-	if (!buffer_is_empty(con->uri.query)) {
+	if (!buffer_string_is_empty(con->uri.query)) {
 		FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("QUERY_STRING"), CONST_BUF_LEN(con->uri.query)),con)
 	} else {
 		FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("QUERY_STRING"), CONST_STR_LEN("")),con)
@@ -2031,142 +2004,58 @@
 	s = get_http_version_name(con->request.http_version);
 	FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("SERVER_PROTOCOL"), s, strlen(s)),con)
 
-    if (srv_sock->is_ssl || srv_sock->is_proxy_ssl) {
+	if (buffer_is_equal_caseless_string(con->uri.scheme, CONST_STR_LEN("https"))) {
 		FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("HTTPS"), CONST_STR_LEN("on")),con)
 	}
 
 	FCGI_ENV_ADD_CHECK(fcgi_env_add_request_headers(srv, con, p), con);
 
-	fcgi_header(&(header), FCGI_PARAMS, request_id, p->fcgi_env->used, 0);
-	buffer_append_memory(b, (const char *)&header, sizeof(header));
-	buffer_append_memory(b, (const char *)p->fcgi_env->ptr, p->fcgi_env->used);
+	{
+		buffer *b = buffer_init();
+
+		buffer_copy_string_len(b, (const char *)&beginRecord, sizeof(beginRecord));
 
-	fcgi_header(&(header), FCGI_PARAMS, request_id, 0, 0);
-	buffer_append_memory(b, (const char *)&header, sizeof(header));
+		fcgi_header(&(header), FCGI_PARAMS, request_id, buffer_string_length(p->fcgi_env), 0);
+		buffer_append_string_len(b, (const char *)&header, sizeof(header));
+		buffer_append_string_buffer(b, p->fcgi_env);
 
-	b->used++; /* add virtual \0 */
-	hctx->wb->bytes_in += b->used - 1;
+		fcgi_header(&(header), FCGI_PARAMS, request_id, 0, 0);
+		buffer_append_string_len(b, (const char *)&header, sizeof(header));
+
+		hctx->wb->bytes_in += buffer_string_length(b);
+		chunkqueue_append_buffer(hctx->wb, b);
+		buffer_free(b);
+	}
 
 	if (con->request.content_length) {
 		chunkqueue *req_cq = con->request_content_queue;
-		chunk *req_c;
 		off_t offset;
 
 		/* something to send ? */
-		for (offset = 0, req_c = req_cq->first; offset != req_cq->bytes_in; ) {
+		for (offset = 0; offset != req_cq->bytes_in; ) {
 			off_t weWant = req_cq->bytes_in - offset > FCGI_MAX_LENGTH ? FCGI_MAX_LENGTH : req_cq->bytes_in - offset;
-			off_t written = 0;
-			off_t weHave = 0;
 
 			/* we announce toWrite octets
 			 * now take all the request_content chunks that we need to fill this request
 			 * */
 
-			b = chunkqueue_get_append_buffer(hctx->wb);
 			fcgi_header(&(header), FCGI_STDIN, request_id, weWant, 0);
-			buffer_copy_memory(b, (const char *)&header, sizeof(header));
+			chunkqueue_append_mem(hctx->wb, (const char *)&header, sizeof(header));
 			hctx->wb->bytes_in += sizeof(header);
 
 			if (p->conf.debug > 10) {
 				log_error_write(srv, __FILE__, __LINE__, "soso", "tosend:", offset, "/", req_cq->bytes_in);
 			}
 
-			for (written = 0; written != weWant; ) {
-				if (p->conf.debug > 10) {
-					log_error_write(srv, __FILE__, __LINE__, "soso", "chunk:", written, "/", weWant);
-				}
-
-				switch (req_c->type) {
-				case FILE_CHUNK:
-					weHave = req_c->file.length - req_c->offset;
-
-					if (weHave > weWant - written) weHave = weWant - written;
-
-					if (p->conf.debug > 10) {
-						log_error_write(srv, __FILE__, __LINE__, "soSosOsb",
-							"sending", weHave, "bytes from (",
-							req_c->offset, "/", req_c->file.length, ")",
-							req_c->file.name);
-					}
-
-					assert(weHave != 0);
-
-					chunkqueue_append_file(hctx->wb, req_c->file.name, req_c->offset, weHave);
+			chunkqueue_steal(hctx->wb, req_cq, weWant);
 
-					req_c->offset += weHave;
-					req_cq->bytes_out += weHave;
-					written += weHave;
-
-					hctx->wb->bytes_in += weHave;
-
-					/* steal the tempfile
-					 *
-					 * This is tricky:
-					 * - we reference the tempfile from the request-content-queue several times
-					 *   if the req_c is larger than FCGI_MAX_LENGTH
-					 * - we can't simply cleanup the request-content-queue as soon as possible
-					 *   as it would remove the tempfiles
-					 * - the idea is to 'steal' the tempfiles and attach the is_temp flag to the last
-					 *   referencing chunk of the fastcgi-write-queue
-					 *
-					 *  */
-
-					if (req_c->offset == req_c->file.length) {
-						chunk *c;
-
-						if (p->conf.debug > 10) {
-							log_error_write(srv, __FILE__, __LINE__, "s", "next chunk");
-						}
-						c = hctx->wb->last;
-
-						assert(c->type == FILE_CHUNK);
-						assert(req_c->file.is_temp == 1);
-
-						c->file.is_temp = 1;
-						req_c->file.is_temp = 0;
-
-						chunkqueue_remove_finished_chunks(req_cq);
-
-						req_c = req_cq->first;
-					}
-
-					break;
-				case MEM_CHUNK:
-					/* append to the buffer */
-					weHave = req_c->mem->used - 1 - req_c->offset;
-
-					if (weHave > weWant - written) weHave = weWant - written;
-
-					buffer_append_memory(b, req_c->mem->ptr + req_c->offset, weHave);
-
-					req_c->offset += weHave;
-					req_cq->bytes_out += weHave;
-					written += weHave;
-
-					hctx->wb->bytes_in += weHave;
-
-					if (req_c->offset == (off_t) req_c->mem->used - 1) {
-						chunkqueue_remove_finished_chunks(req_cq);
-
-						req_c = req_cq->first;
-					}
-
-					break;
-				default:
-					break;
-				}
-			}
-
-			b->used++; /* add virtual \0 */
 			offset += weWant;
 		}
 	}
 
-	b = chunkqueue_get_append_buffer(hctx->wb);
 	/* terminate STDIN */
 	fcgi_header(&(header), FCGI_STDIN, request_id, 0, 0);
-	buffer_copy_memory(b, (const char *)&header, sizeof(header));
-	b->used++; /* add virtual \0 */
+	chunkqueue_append_mem(hctx->wb, (const char *)&header, sizeof(header));
 
 	hctx->wb->bytes_in += sizeof(header);
 
@@ -2183,17 +2072,15 @@
 
 	UNUSED(srv);
 
-	buffer_copy_string_buffer(p->parse_response, in);
-
 	/* search for \n */
-	for (s = p->parse_response->ptr; NULL != (ns = strchr(s, '\n')); s = ns + 1) {
+	for (s = in->ptr; NULL != (ns = strchr(s, '\n')); s = ns + 1) {
 		char *key, *value;
 		int key_len;
 		data_string *ds = NULL;
 
 		/* a good day. Someone has read the specs and is sending a \r\n to us */
 
-		if (ns > p->parse_response->ptr &&
+		if (ns > in->ptr &&
 		    *(ns-1) == '\r') {
 			*(ns-1) = '\0';
 		}
@@ -2363,7 +2250,7 @@
 		}
 
 		buffer_copy_string_len(dcls->key, "Content-Length", sizeof("Content-Length")-1);
-		buffer_copy_off_t(dcls->value, sendfile2_content_length);
+		buffer_copy_int(dcls->value, sendfile2_content_length);
 		dcls = (data_string*) array_replace(con->response.headers, (data_unset *)dcls);
 		if (dcls) dcls->free((data_unset*)dcls);
 
@@ -2389,7 +2276,7 @@
 } fastcgi_response_packet;
 
 static int fastcgi_get_packet(server *srv, handler_ctx *hctx, fastcgi_response_packet *packet) {
-	chunk *	c;
+	chunk *c;
 	size_t offset;
 	size_t toread;
 	FCGI_Header *header;
@@ -2405,29 +2292,25 @@
 	offset = 0; toread = 8;
 	/* get at least the FastCGI header */
 	for (c = hctx->rb->first; c; c = c->next) {
-		size_t weHave = c->mem->used - c->offset - 1;
+		size_t weHave = buffer_string_length(c->mem) - c->offset;
 
 		if (weHave > toread) weHave = toread;
 
-		if (packet->b->used == 0) {
-			buffer_copy_string_len(packet->b, c->mem->ptr + c->offset, weHave);
-		} else {
-			buffer_append_string_len(packet->b, c->mem->ptr + c->offset, weHave);
-		}
+		buffer_append_string_len(packet->b, c->mem->ptr + c->offset, weHave);
 		toread -= weHave;
 		offset = weHave; /* skip offset bytes in chunk for "real" data */
 
 		if (0 == toread) break;
 	}
 
-	if ((packet->b->used == 0) ||
-	    (packet->b->used - 1 < sizeof(FCGI_Header))) {
+	if (buffer_string_length(packet->b) < sizeof(FCGI_Header)) {
 		/* no header */
-		buffer_free(packet->b);
-
 		if (hctx->plugin_data->conf.debug) {
-			log_error_write(srv, __FILE__, __LINE__, "sdsds", "FastCGI: header too small:", packet->b->used, "bytes <", sizeof(FCGI_Header), "bytes, waiting for more data");
+			log_error_write(srv, __FILE__, __LINE__, "sdsds", "FastCGI: header too small:", buffer_string_length(packet->b), "bytes <", sizeof(FCGI_Header), "bytes, waiting for more data");
 		}
+
+		buffer_free(packet->b);
+
 		return -1;
 	}
 
@@ -2440,13 +2323,13 @@
 	packet->padding = header->paddingLength;
 
 	/* ->b should only be the content */
-	buffer_copy_string_len(packet->b, CONST_STR_LEN("")); /* used == 1 */
+	buffer_string_set_length(packet->b, 0);
 
 	if (packet->len) {
 		/* copy the content */
-		for (; c && (packet->b->used < packet->len + 1); c = c->next) {
-			size_t weWant = packet->len - (packet->b->used - 1);
-			size_t weHave = c->mem->used - c->offset - offset - 1;
+		for (; c && (buffer_string_length(packet->b) < packet->len); c = c->next) {
+			size_t weWant = packet->len - buffer_string_length(packet->b);
+			size_t weHave = buffer_string_length(c->mem) - c->offset - offset;
 
 			if (weHave > weWant) weHave = weWant;
 
@@ -2456,24 +2339,23 @@
 			offset = 0;
 		}
 
-		if (packet->b->used < packet->len + 1) {
+		if (buffer_string_length(packet->b) < packet->len) {
 			/* we didn't get the full packet */
 
 			buffer_free(packet->b);
 			return -1;
 		}
 
-		packet->b->used -= packet->padding;
-		packet->b->ptr[packet->b->used - 1] = '\0';
+		buffer_string_set_length(packet->b, buffer_string_length(packet->b) - packet->padding);
 	}
 
 	/* tag the chunks as read */
 	toread = packet->len + sizeof(FCGI_Header);
 	for (c = hctx->rb->first; c && toread; c = c->next) {
-		if (c->mem->used - c->offset - 1 <= toread) {
+		if (buffer_string_length(c->mem) - c->offset <= toread) {
 			/* we read this whole buffer, move it to unused */
-			toread -= c->mem->used - c->offset - 1;
-			c->offset = c->mem->used - 1; /* everthing has been written */
+			toread -= buffer_string_length(c->mem) - c->offset;
+			c->offset = buffer_string_length(c->mem); /* everthing has been written */
 		} else {
 			c->offset += toread;
 			toread = 0;
@@ -2507,38 +2389,21 @@
 		return -1;
 	}
 
-	/* init read-buffer */
-
 	if (toread > 0) {
-		buffer *b;
-		chunk *cq_first = hctx->rb->first;
-		chunk *cq_last = hctx->rb->last;
-
-		b = chunkqueue_get_append_buffer(hctx->rb);
-		buffer_prepare_copy(b, toread + 1);
-
-		/* append to read-buffer */
-		if (-1 == (r = read(hctx->fd, b->ptr, toread))) {
-			if (errno == EAGAIN) {
-				/* roll back the last chunk allocation,
-                                   and continue on next iteration        */
-				buffer_free(hctx->rb->last->mem);
-				free(hctx->rb->last);
-				hctx->rb->first = cq_first;
-				hctx->rb->last = cq_last;
-				return 0;
-			}
+		char *mem;
+		size_t mem_len;
+
+		chunkqueue_get_memory(hctx->rb, &mem, &mem_len, 0, toread);
+		r = read(hctx->fd, mem, mem_len);
+		chunkqueue_use_memory(hctx->rb, r > 0 ? r : 0);
+
+		if (-1 == r) {
+			if (errno == EAGAIN) return 0;
 			log_error_write(srv, __FILE__, __LINE__, "sds",
 					"unexpected end-of-file (perhaps the fastcgi process died):",
 					fcgi_fd, strerror(errno));
 			return -1;
 		}
-
-		/* this should be catched by the b > 0 above */
-		assert(r);
-
-		b->used = r + 1; /* one extra for the fake \0 */
-		b->ptr[b->used - 1] = '\0';
 	} else {
 		log_error_write(srv, __FILE__, __LINE__, "ssdsb",
 				"unexpected end-of-file (perhaps the fastcgi process died):",
@@ -2568,7 +2433,6 @@
 			/* is the header already finished */
 			if (0 == con->file_started) {
 				char *c;
-				size_t blen;
 				data_string *ds;
 
 				/* search for header terminator
@@ -2579,20 +2443,18 @@
 				 * search for \n\n
 				 */
 
-				if (hctx->response_header->used == 0) {
-					buffer_copy_string_buffer(hctx->response_header, packet.b);
-				} else {
-					buffer_append_string_buffer(hctx->response_header, packet.b);
-				}
+				buffer_append_string_buffer(hctx->response_header, packet.b);
 
 				if (NULL != (c = buffer_search_string_len(hctx->response_header, CONST_STR_LEN("\r\n\r\n")))) {
-					blen = hctx->response_header->used - (c - hctx->response_header->ptr) - 4;
-					hctx->response_header->used = (c - hctx->response_header->ptr) + 3;
-					c += 4; /* point the the start of the response */
+					char *hend = c + 4; /* header end == body start */
+					size_t hlen = hend - hctx->response_header->ptr;
+					buffer_copy_string_len(packet.b, hend, buffer_string_length(hctx->response_header) - hlen);
+					buffer_string_set_length(hctx->response_header, hlen);
 				} else if (NULL != (c = buffer_search_string_len(hctx->response_header, CONST_STR_LEN("\n\n")))) {
-					blen = hctx->response_header->used - (c - hctx->response_header->ptr) - 2;
-					hctx->response_header->used = c - hctx->response_header->ptr + 2;
-					c += 2; /* point the the start of the response */
+					char *hend = c + 2; /* header end == body start */
+					size_t hlen = hend - hctx->response_header->ptr;
+					buffer_copy_string_len(packet.b, hend, buffer_string_length(hctx->response_header) - hlen);
+					buffer_string_set_length(hctx->response_header, hlen);
 				} else {
 					/* no luck, no header found */
 					break;
@@ -2631,7 +2493,7 @@
 						joblist_append(srv, con);
 
 						buffer_copy_string_len(dcls->key, "Content-Length", sizeof("Content-Length")-1);
-						buffer_copy_off_t(dcls->value, sce->st.st_size);
+						buffer_copy_int(dcls->value, sce->st.st_size);
 						dcls = (data_string*) array_replace(con->response.headers, (data_unset *)dcls);
 						if (dcls) dcls->free((data_unset*)dcls);
 
@@ -2649,32 +2511,32 @@
 				}
 
 
-				if (hctx->send_content_body && blen > 1) {
+				if (hctx->send_content_body && buffer_string_length(packet.b) > 0) {
 					/* enable chunked-transfer-encoding */
 					if (con->request.http_version == HTTP_VERSION_1_1 &&
 					    !(con->parsed_response & HTTP_CONTENT_LENGTH)) {
 						con->response.transfer_encoding = HTTP_TRANSFER_ENCODING_CHUNKED;
 					}
 
-					http_chunk_append_mem(srv, con, c, blen);
+					http_chunk_append_buffer(srv, con, packet.b);
 					joblist_append(srv, con);
 				}
-			} else if (hctx->send_content_body && packet.b->used > 1) {
+			} else if (hctx->send_content_body && !buffer_string_is_empty(packet.b)) {
 				if (con->request.http_version == HTTP_VERSION_1_1 &&
 				    !(con->parsed_response & HTTP_CONTENT_LENGTH)) {
 					/* enable chunked-transfer-encoding */
 					con->response.transfer_encoding = HTTP_TRANSFER_ENCODING_CHUNKED;
 				}
 
-				http_chunk_append_mem(srv, con, packet.b->ptr, packet.b->used);
+				http_chunk_append_buffer(srv, con, packet.b);
 				joblist_append(srv, con);
 			}
 			break;
 		case FCGI_STDERR:
 			if (packet.len == 0) break;
 
-			log_error_write(srv, __FILE__, __LINE__, "sb",
-					"FastCGI-stderr:", packet.b);
+			log_error_write_multiline_buffer(srv, __FILE__, __LINE__, packet.b, "s",
+					"FastCGI-stderr:");
 
 			break;
 		case FCGI_END_REQUEST:
@@ -2684,7 +2546,7 @@
 			    !(con->http_status == 0 ||
 			      con->http_status == 200)) {
 				/* send chunk-end if necessary */
-				http_chunk_append_mem(srv, con, NULL, 0);
+				http_chunk_close(srv, con);
 				joblist_append(srv, con);
 			}
 
@@ -2725,7 +2587,7 @@
 		case PROC_STATE_KILLED:
 		case PROC_STATE_UNSET:
 			/* this should never happen as long as adaptive spawing is disabled */
-			assert(0);
+			force_assert(0);
 
 			break;
 		case PROC_STATE_RUNNING:
@@ -2801,7 +2663,7 @@
 			/* local procs get restarted by us,
 			 * remote ones hopefully by the admin */
 
-			if (!buffer_is_empty(host->bin_path)) {
+			if (!buffer_string_is_empty(host->bin_path)) {
 				/* we still have connections bound to this proc,
 				 * let them terminate first */
 				if (proc->load != 0) break;
@@ -2855,7 +2717,7 @@
 		log_error_write(srv, __FILE__, __LINE__, "s", "fatal error: host = NULL");
 		return HANDLER_ERROR;
 	}
-	if ((!host->port && !host->unixsocket->used)) {
+	if ((!host->port && buffer_string_is_empty(host->unixsocket))) {
 		log_error_write(srv, __FILE__, __LINE__, "s", "fatal error: neither host->port nor host->unixsocket is set");
 		return HANDLER_ERROR;
 	}
@@ -2928,7 +2790,7 @@
 			if (proc->load < hctx->proc->load) hctx->proc = proc;
 		}
 
-		ret = host->unixsocket->used ? AF_UNIX : AF_INET;
+		ret = buffer_string_is_empty(host->unixsocket) ? AF_INET : AF_UNIX;
 
 		if (-1 == (hctx->fd = socket(ret, SOCK_STREAM, 0))) {
 			if (errno == EMFILE ||
@@ -3017,7 +2879,7 @@
 
 			break;
 		}
-
+		/* fallthrough */
 	case FCGI_STATE_PREPARE_WRITE:
 		/* ok, we have the connection */
 
@@ -3047,8 +2909,8 @@
 					"fcgi-request is already in use:", hctx->request_id);
 		}
 
-		/* fall through */
 		if (-1 == fcgi_create_env(srv, hctx, hctx->request_id)) return HANDLER_ERROR;
+
 		fcgi_set_state(srv, hctx, FCGI_STATE_WRITE);
 		/* fall through */
 	case FCGI_STATE_WRITE:
@@ -3177,8 +3039,6 @@
 	/* ok, create the request */
 	switch(fcgi_write_request(srv, hctx)) {
 	case HANDLER_ERROR:
-		host = hctx->host;
-
 		if (hctx->state == FCGI_STATE_INIT ||
 		    hctx->state == FCGI_STATE_CONNECT_DELAYED) {
 			fcgi_restart_dead_procs(srv, p, host);
@@ -3247,10 +3107,10 @@
 				 * now to handle authorized request.
 				 */
 
-				buffer_copy_string_buffer(con->physical.doc_root, host->docroot);
-				buffer_copy_string_buffer(con->physical.basedir, host->docroot);
+				buffer_copy_buffer(con->physical.doc_root, host->docroot);
+				buffer_copy_buffer(con->physical.basedir, host->docroot);
 
-				buffer_copy_string_buffer(con->physical.path, host->docroot);
+				buffer_copy_buffer(con->physical.path, host->docroot);
 				buffer_append_string_buffer(con->physical.path, con->uri.path);
 				fcgi_connection_close(srv, hctx);
 
@@ -3469,9 +3329,9 @@
 
 	fn = uri_path_handler ? con->uri.path : con->physical.path;
 
-	if (buffer_is_empty(fn)) return HANDLER_GO_ON;
+	if (buffer_string_is_empty(fn)) return HANDLER_GO_ON;
 
-	s_len = fn->used - 1;
+	s_len = buffer_string_length(fn);
 
 	fcgi_patch_connection(srv, con, p);
 
@@ -3488,9 +3348,9 @@
 		data_string *ds = (data_string *)p->conf.ext_mapping->data[k];
 		size_t ct_len; /* length of the config entry */
 
-		if (ds->key->used == 0) continue;
+		if (buffer_is_empty(ds->key)) continue;
 
-		ct_len = ds->key->used - 1;
+		ct_len = buffer_string_length(ds->key);
 
 		if (s_len < ct_len) continue;
 
@@ -3516,18 +3376,20 @@
 	}
 
 	if (extension == NULL) {
+		size_t uri_path_len = buffer_string_length(con->uri.path);
+
 		/* check if extension matches */
 		for (k = 0; k < p->conf.exts->used; k++) {
 			size_t ct_len; /* length of the config entry */
 			fcgi_extension *ext = p->conf.exts->exts[k];
 
-			if (ext->key->used == 0) continue;
+			if (buffer_is_empty(ext->key)) continue;
 
-			ct_len = ext->key->used - 1;
+			ct_len = buffer_string_length(ext->key);
 
 			/* check _url_ in the form "/fcgi_pattern" */
 			if (ext->key->ptr[0] == '/') {
-				if ((ct_len <= con->uri.path->used -1) &&
+				if ((ct_len <= uri_path_len) &&
 				    (strncmp(con->uri.path->ptr, ext->key->ptr, ct_len) == 0)) {
 					extension = ext;
 					break;
@@ -3642,17 +3504,14 @@
 				/* the rewrite is only done for /prefix/? matches */
 				if (host->fix_root_path_name && extension->key->ptr[0] == '/' && extension->key->ptr[1] == '\0') {
 					buffer_copy_string(con->request.pathinfo, con->uri.path->ptr);
-					con->uri.path->used = 1;
-					con->uri.path->ptr[con->uri.path->used - 1] = '\0';
+					buffer_string_set_length(con->uri.path, 0);
 				} else if (extension->key->ptr[0] == '/' &&
-					con->uri.path->used > extension->key->used &&
-					NULL != (pathinfo = strchr(con->uri.path->ptr + extension->key->used - 1, '/'))) {
+					buffer_string_length(con->uri.path) > buffer_string_length(extension->key) &&
+					NULL != (pathinfo = strchr(con->uri.path->ptr + buffer_string_length(extension->key), '/'))) {
 					/* rewrite uri.path and pathinfo */
 
 					buffer_copy_string(con->request.pathinfo, pathinfo);
-
-					con->uri.path->used -= con->request.pathinfo->used - 1;
-					con->uri.path->ptr[con->uri.path->used - 1] = '\0';
+					buffer_string_set_length(con->uri.path, buffer_string_length(con->uri.path) - buffer_string_length(con->request.pathinfo));
 				}
 			}
 		}
diff -u lighttpd-1.4.32/src/mod_flv_streaming.c lighttpd-1.4.36/src/mod_flv_streaming.c
--- lighttpd-1.4.32/src/mod_flv_streaming.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/mod_flv_streaming.c	2015-07-26 05:36:36.000000000 -0500
@@ -54,7 +54,7 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
-			if (!s) continue;
+			if (NULL == s) continue;
 
 			array_free(s->extensions);
 
@@ -84,7 +84,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -136,13 +136,14 @@
 
 static int split_get_params(array *get_params, buffer *qrystr) {
 	size_t is_key = 1;
-	size_t i;
+	size_t i, len;
 	char *key = NULL, *val = NULL;
 
 	key = qrystr->ptr;
 
 	/* we need the \0 */
-	for (i = 0; i < qrystr->used; i++) {
+	len = buffer_string_length(qrystr);
+	for (i = 0; i <= len; i++) {
 		switch(qrystr->ptr[i]) {
 		case '=':
 			if (is_key) {
@@ -191,30 +192,29 @@
 
 	if (con->mode != DIRECT) return HANDLER_GO_ON;
 
-	if (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;
+	if (buffer_string_is_empty(con->physical.path)) return HANDLER_GO_ON;
 
 	mod_flv_streaming_patch_connection(srv, con, p);
 
-	s_len = con->physical.path->used - 1;
+	s_len = buffer_string_length(con->physical.path);
 
 	for (k = 0; k < p->conf.extensions->used; k++) {
 		data_string *ds = (data_string *)p->conf.extensions->data[k];
-		int ct_len = ds->value->used - 1;
+		int ct_len = buffer_string_length(ds->value);
 
 		if (ct_len > s_len) continue;
-		if (ds->value->used == 0) continue;
+		if (buffer_is_empty(ds->value)) continue;
 
 		if (0 == strncmp(con->physical.path->ptr + s_len - ct_len, ds->value->ptr, ct_len)) {
 			data_string *get_param;
 			stat_cache_entry *sce = NULL;
-			buffer *b;
 			int start;
 			char *err = NULL;
 			/* if there is a start=[0-9]+ in the header use it as start,
 			 * otherwise send the full file */
 
 			array_reset(p->get_params);
-			buffer_copy_string_buffer(p->query_str, con->uri.query);
+			buffer_copy_buffer(p->query_str, con->uri.query);
 			split_get_params(p->get_params, p->query_str);
 
 			if (NULL == (get_param = (data_string *)array_get_element(p->get_params, "start"))) {
@@ -222,7 +222,7 @@
 			}
 
 			/* too short */
-			if (get_param->value->used < 2) return HANDLER_GO_ON;
+			if (buffer_string_is_empty(get_param->value)) return HANDLER_GO_ON;
 
 			/* check if it is a number */
 			start = strtol(get_param->value->ptr, &err, 10);
@@ -242,10 +242,9 @@
 			}
 
 			/* we are safe now, let's build a flv header */
-			b = chunkqueue_get_append_buffer(con->write_queue);
-			buffer_copy_string_len(b, CONST_STR_LEN("FLV\x1\x1\0\0\0\x9\0\0\0\x9"));
-
+			http_chunk_append_mem(srv, con, CONST_STR_LEN("FLV\x1\x1\0\0\0\x9\0\0\0\x9"));
 			http_chunk_append_file(srv, con, con->physical.path, start, sce->st.st_size - start);
+			http_chunk_close(srv, con);
 
 			response_header_overwrite(srv, con, CONST_STR_LEN("Content-Type"), CONST_STR_LEN("video/x-flv"));
 
diff -u lighttpd-1.4.32/src/mod_indexfile.c lighttpd-1.4.36/src/mod_indexfile.c
--- lighttpd-1.4.32/src/mod_indexfile.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/mod_indexfile.c	2015-07-26 05:36:36.000000000 -0500
@@ -51,7 +51,7 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
-			if (!s) continue;
+			if (NULL == s) continue;
 
 			array_free(s->indexfiles);
 
@@ -81,7 +81,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -141,8 +141,8 @@
 
 	if (con->mode != DIRECT) return HANDLER_GO_ON;
 
-	if (con->uri.path->used == 0) return HANDLER_GO_ON;
-	if (con->uri.path->ptr[con->uri.path->used - 2] != '/') return HANDLER_GO_ON;
+	if (buffer_is_empty(con->uri.path)) return HANDLER_GO_ON;
+	if (con->uri.path->ptr[buffer_string_length(con->uri.path) - 1] != '/') return HANDLER_GO_ON;
 
 	mod_indexfile_patch_connection(srv, con, p);
 
@@ -158,9 +158,9 @@
 		if (ds->value && ds->value->ptr[0] == '/') {
 			/* if the index-file starts with a prefix as use this file as
 			 * index-generator */
-			buffer_copy_string_buffer(p->tmp_buf, con->physical.doc_root);
+			buffer_copy_buffer(p->tmp_buf, con->physical.doc_root);
 		} else {
-			buffer_copy_string_buffer(p->tmp_buf, con->physical.path);
+			buffer_copy_buffer(p->tmp_buf, con->physical.path);
 		}
 		buffer_append_string_buffer(p->tmp_buf, ds->value);
 
@@ -192,7 +192,7 @@
 
 		/* rewrite uri.path to the real path (/ -> /index.php) */
 		buffer_append_string_buffer(con->uri.path, ds->value);
-		buffer_copy_string_buffer(con->physical.path, p->tmp_buf);
+		buffer_copy_buffer(con->physical.path, p->tmp_buf);
 
 		/* fce is already set up a few lines above */
 
diff -u lighttpd-1.4.32/src/mod_magnet.c lighttpd-1.4.36/src/mod_magnet.c
--- lighttpd-1.4.32/src/mod_magnet.c	2011-06-13 06:17:01.000000000 -0500
+++ lighttpd-1.4.36/src/mod_magnet.c	2015-07-26 05:36:36.000000000 -0500
@@ -71,7 +71,7 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
-			if (!s) continue;
+			if (NULL == s) continue;
 
 			array_free(s->url_raw);
 			array_free(s->physical_path);
@@ -103,7 +103,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -189,17 +189,12 @@
 
 	if (pos >= a->used) return 0;
 	if (NULL != (du = a->data[pos])) {
-		if (du->key->used) {
-			lua_pushlstring(L, du->key->ptr, du->key->used - 1);
-		}
-		else {
-			lua_pushlstring(L, "", 0);
-		}
+		lua_pushlstring(L, CONST_BUF_LEN(du->key));
 		switch (du->type) {
 			case TYPE_STRING:
 				ds = (data_string *)du;
-				if (ds->value && ds->value->used) {
-					lua_pushlstring(L, ds->value->ptr, ds->value->used - 1);
+				if (!buffer_is_empty(ds->value)) {
+					lua_pushlstring(L, CONST_BUF_LEN(ds->value));
 				} else {
 					lua_pushnil(L);
 				}
@@ -252,8 +247,9 @@
 	const char *s = luaL_checkstring(L, 1);
 	server *srv;
 	connection *con;
-	buffer sb;
+	buffer *sb;
 	stat_cache_entry *sce = NULL;
+	handler_t res;
 
 	lua_pushstring(L, "lighty.srv");
 	lua_gettable(L, LUA_REGISTRYINDEX);
@@ -265,12 +261,12 @@
 	con = lua_touserdata(L, -1);
 	lua_pop(L, 1);
 
-	sb.ptr = (char *)s;
-	sb.used = sb.size = strlen(s) + 1;
-	
-	if (HANDLER_GO_ON != stat_cache_get_entry(srv, con, &sb, &sce)) {
-		lua_pushnil(L);
+	sb = buffer_init_string(s);
+	res = stat_cache_get_entry(srv, con, sb, &sce);
+	buffer_free(sb);
 
+	if (HANDLER_GO_ON != res) {
+		lua_pushnil(L);
 		return 1;
 	}
 
@@ -319,20 +315,20 @@
 	lua_setfield(L, -2, "st_ino");
 
 
-	if (!buffer_is_empty(sce->etag)) {
+	if (!buffer_string_is_empty(sce->etag)) {
 		/* we have to mutate the etag */
 		buffer *b = buffer_init();
 		etag_mutate(b, sce->etag);
 
-		lua_pushlstring(L, b->ptr, b->used - 1);
+		lua_pushlstring(L, CONST_BUF_LEN(b));
 		buffer_free(b);
 	} else {
 		lua_pushnil(L);
 	}
 	lua_setfield(L, -2, "etag");
 
-	if (!buffer_is_empty(sce->content_type)) {
-		lua_pushlstring(L, sce->content_type->ptr, sce->content_type->used - 1);
+	if (!buffer_string_is_empty(sce->content_type)) {
+		lua_pushlstring(L, CONST_BUF_LEN(sce->content_type));
 	} else {
 		lua_pushnil(L);
 	}
@@ -369,8 +365,8 @@
 	lua_pop(L, 1);
 
 	if (NULL != (ds = (data_string *)array_get_element(con->request.headers, key))) {
-		if (ds->value->used) {
-			lua_pushlstring(L, ds->value->ptr, ds->value->used - 1);
+		if (!buffer_is_empty(ds->value)) {
+			lua_pushlstring(L, CONST_BUF_LEN(ds->value));
 		} else {
 			lua_pushnil(L);
 		}
@@ -446,6 +442,7 @@
 		MAGNET_ENV_PHYICAL_PATH,
 		MAGNET_ENV_PHYICAL_REL_PATH,
 		MAGNET_ENV_PHYICAL_DOC_ROOT,
+		MAGNET_ENV_PHYICAL_BASEDIR,
 
 		MAGNET_ENV_URI_PATH,
 		MAGNET_ENV_URI_PATH_RAW,
@@ -466,6 +463,7 @@
 	{ "physical.path", MAGNET_ENV_PHYICAL_PATH },
 	{ "physical.rel-path", MAGNET_ENV_PHYICAL_REL_PATH },
 	{ "physical.doc-root", MAGNET_ENV_PHYICAL_DOC_ROOT },
+	{ "physical.basedir", MAGNET_ENV_PHYICAL_BASEDIR },
 
 	{ "uri.path", MAGNET_ENV_URI_PATH },
 	{ "uri.path-raw", MAGNET_ENV_URI_PATH_RAW },
@@ -497,6 +495,7 @@
 	case MAGNET_ENV_PHYICAL_PATH: dest = con->physical.path; break;
 	case MAGNET_ENV_PHYICAL_REL_PATH: dest = con->physical.rel_path; break;
 	case MAGNET_ENV_PHYICAL_DOC_ROOT: dest = con->physical.doc_root; break;
+	case MAGNET_ENV_PHYICAL_BASEDIR: dest = con->physical.basedir; break;
 
 	case MAGNET_ENV_URI_PATH: dest = con->uri.path; break;
 	case MAGNET_ENV_URI_PATH_RAW: dest = con->uri.path_raw; break;
@@ -552,8 +551,8 @@
 
 	dest = magnet_env_get_buffer(srv, con, key);
 
-	if (dest && dest->used) {
-		lua_pushlstring(L, dest->ptr, dest->used - 1);
+	if (!buffer_is_empty(dest)) {
+		lua_pushlstring(L, CONST_BUF_LEN(dest));
 	} else {
 		lua_pushnil(L);
 	}
@@ -614,8 +613,8 @@
 	lua_pushstring(L, magnet_env[pos].name);
 
 	dest = magnet_env_get_buffer_by_id(srv, con, magnet_env[pos].type);
-	if (dest && dest->used) {
-		lua_pushlstring(L, dest->ptr, dest->used - 1);
+	if (!buffer_is_empty(dest)) {
+		lua_pushlstring(L, CONST_BUF_LEN(dest));
 	} else {
 		lua_pushnil(L);
 	}
@@ -646,7 +645,8 @@
 	con = lua_touserdata(L, -1);
 	lua_pop(L, 1);
 
-	if (NULL != (ds = (data_string *)array_get_element(con->environment, key)) && ds->value->used)
+	ds = (data_string *)array_get_element(con->environment, key);
+	if (NULL != ds && !buffer_is_empty(ds->value))
 		lua_pushlstring(L, CONST_BUF_LEN(ds->value));
 	else
 		lua_pushnil(L);
@@ -693,7 +693,7 @@
 	/* lighty.header */
 
 	lua_getfield(L, -1, "lighty"); /* lighty.* from the env  */
-	assert(lua_istable(L, -1));
+	force_assert(lua_istable(L, -1));
 
 	lua_getfield(L, -1, "header"); /* lighty.header */
 	if (lua_istable(L, -1)) {
@@ -737,11 +737,11 @@
 	 * get the environment of the function
 	 */
 
-	assert(lua_isfunction(L, -1));
+	force_assert(lua_isfunction(L, -1));
 	lua_getfenv(L, -1); /* -1 is the function */
 
 	lua_getfield(L, -1, "lighty"); /* lighty.* from the env  */
-	assert(lua_istable(L, -1));
+	force_assert(lua_istable(L, -1));
 
 	lua_getfield(L, -1, "content"); /* lighty.content */
 	if (lua_istable(L, -1)) {
@@ -756,19 +756,24 @@
 				size_t s_len = 0;
 				const char *s = lua_tolstring(L, -1, &s_len);
 
-				chunkqueue_append_mem(con->write_queue, s, s_len + 1);
+				chunkqueue_append_mem(con->write_queue, s, s_len);
 			} else if (lua_istable(L, -1)) {
 				lua_getfield(L, -1, "filename");
 				lua_getfield(L, -2, "length");
 				lua_getfield(L, -3, "offset");
 
 				if (lua_isstring(L, -3)) { /* filename has to be a string */
-					buffer *fn = buffer_init();
+					buffer *fn;
 					stat_cache_entry *sce;
+					const char *fn_str;
+					handler_t res;
+
+					fn_str = lua_tostring(L, -3);
+					fn = buffer_init_string(fn_str);
 
-					buffer_copy_string(fn, lua_tostring(L, -3));
+					res = stat_cache_get_entry(srv, con, fn, &sce);
 
-					if (HANDLER_GO_ON == stat_cache_get_entry(srv, con, fn, &sce)) {
+					if (HANDLER_GO_ON == res) {
 						off_t off = 0;
 						off_t len = 0;
 
@@ -783,11 +788,13 @@
 						}
 
 						if (off < 0) {
-							return luaL_error(L, "offset for '%s' is negative", fn->ptr);
+							buffer_free(fn);
+							return luaL_error(L, "offset for '%s' is negative", fn_str);
 						}
 
 						if (len < off) {
-							return luaL_error(L, "offset > length for '%s'", fn->ptr);
+							buffer_free(fn);
+							return luaL_error(L, "offset > length for '%s'", fn_str);
 						}
 
 						chunkqueue_append_file(con->write_queue, fn, off, len - off);
@@ -870,7 +877,7 @@
 
 		lua_pop(L, 1);
 
-		assert(lua_gettop(L) == 0); /* only the function should be on the stack */
+		force_assert(lua_gettop(L) == 0); /* only the function should be on the stack */
 
 		con->http_status = 500;
 		con->mode = DIRECT;
@@ -992,7 +999,7 @@
 			lua_tostring(L, -1));
 		lua_pop(L, 1); /* remove the error-msg and the function copy from the stack */
 
-		assert(lua_gettop(L) == 1); /* only the function should be on the stack */
+		force_assert(lua_gettop(L) == 1); /* only the function should be on the stack */
 
 		con->http_status = 500;
 		con->mode = DIRECT;
@@ -1002,7 +1009,7 @@
 	lua_remove(L, errfunc);
 
 	/* we should have the function-copy and the return value on the stack */
-	assert(lua_gettop(L) == 2);
+	force_assert(lua_gettop(L) == 2);
 
 	if (lua_isnumber(L, -1)) {
 		/* if the ret-value is a number, take it */
@@ -1028,16 +1035,16 @@
 			con->mode = DIRECT;
 		}
 
-		assert(lua_gettop(L) == 1); /* only the function should be on the stack */
+		force_assert(lua_gettop(L) == 1); /* only the function should be on the stack */
 
 		/* we are finished */
 		return HANDLER_FINISHED;
 	} else if (MAGNET_RESTART_REQUEST == lua_return_value) {
-		assert(lua_gettop(L) == 1); /* only the function should be on the stack */
+		force_assert(lua_gettop(L) == 1); /* only the function should be on the stack */
 
 		return HANDLER_COMEBACK;
 	} else {
-		assert(lua_gettop(L) == 1); /* only the function should be on the stack */
+		force_assert(lua_gettop(L) == 1); /* only the function should be on the stack */
 
 		return HANDLER_GO_ON;
 	}
@@ -1056,7 +1063,7 @@
 		data_string *ds = (data_string *)files->data[i];
 		handler_t ret;
 
-		if (buffer_is_empty(ds->value)) continue;
+		if (buffer_string_is_empty(ds->value)) continue;
 
 		ret = magnet_attract(srv, con, p, ds->value);
 
diff -u lighttpd-1.4.32/src/mod_magnet_cache.c lighttpd-1.4.36/src/mod_magnet_cache.c
--- lighttpd-1.4.32/src/mod_magnet_cache.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/mod_magnet_cache.c	2015-07-26 05:36:36.000000000 -0500
@@ -80,7 +80,7 @@
 				break;
 			}
 
-			assert(lua_isfunction(sc->L, -1));
+			force_assert(lua_isfunction(sc->L, -1));
 			lua_pushvalue(sc->L, -1); /* copy the function-reference */
 
 			return sc->L;
@@ -104,7 +104,7 @@
 
 		cache->ptr[cache->used++] = sc;
 
-		buffer_copy_string_buffer(sc->name, name);
+		buffer_copy_buffer(sc->name, name);
 
 		sc->L = luaL_newstate();
 		luaL_openlibs(sc->L);
@@ -119,7 +119,7 @@
 	}
 
 	if (HANDLER_GO_ON == stat_cache_get_entry(srv, con, sc->name, &sce)) {
-		buffer_copy_string_buffer(sc->etag, sce->etag);
+		buffer_copy_buffer(sc->etag, sce->etag);
 	}
 
 	/**
@@ -128,7 +128,7 @@
 	 * as pcall() will pop the script from the stack when done, we have to
 	 * duplicate it here
 	 */
-	assert(lua_isfunction(sc->L, -1));
+	force_assert(lua_isfunction(sc->L, -1));
 	lua_pushvalue(sc->L, -1); /* copy the function-reference */
 
 	return sc->L;
diff -u lighttpd-1.4.32/src/mod_mysql_vhost.c lighttpd-1.4.36/src/mod_mysql_vhost.c
--- lighttpd-1.4.32/src/mod_mysql_vhost.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/mod_mysql_vhost.c	2015-07-26 05:36:36.000000000 -0500
@@ -25,10 +25,6 @@
  *   for domain to directory lookups,
  *   i.e virtual hosts (vhosts).
  *
- * Optionally sets fcgi_offset and fcgi_arg
- *   in preparation for fcgi.c to handle
- *   per-user fcgi chroot jails.
- *
  * /ada@riksnet.se 2004-12-06
  */
 
@@ -63,8 +59,6 @@
 typedef struct {
 	buffer	*server_name;
 	buffer	*document_root;
-	buffer	*fcgi_arg;
-	unsigned fcgi_offset;
 } plugin_connection_data;
 
 /* init the plugin data */
@@ -127,7 +121,7 @@
 	UNUSED(srv);
 
 #ifdef DEBUG
-        log_error_write(srv, __FILE__, __LINE__, "ss",
+	log_error_write(srv, __FILE__, __LINE__, "ss",
 		"mod_mysql_connection_data", c ? "old" : "NEW");
 #endif
 
@@ -136,8 +130,6 @@
 
 	c->server_name = buffer_init();
 	c->document_root = buffer_init();
-	c->fcgi_arg = buffer_init();
-	c->fcgi_offset = 0;
 
 	return con->plugin_ctx[p->id] = c;
 }
@@ -158,8 +150,6 @@
 
 	buffer_free(c->server_name);
 	buffer_free(c->document_root);
-	buffer_free(c->fcgi_arg);
-	c->fcgi_offset = 0;
 
 	free(c);
 
@@ -173,24 +163,24 @@
 
 	char *qmark;
 	size_t i = 0;
+	buffer *sel;
 
 	config_values_t cv[] = {
-		{ "mysql-vhost.db",	NULL, T_CONFIG_STRING, 	T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.user",	NULL, T_CONFIG_STRING, 	T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.pass",	NULL, T_CONFIG_STRING, 	T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.sock",	NULL, T_CONFIG_STRING, 	T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.sql",	NULL, T_CONFIG_STRING, 	T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.hostname", NULL, T_CONFIG_STRING,T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.port",   NULL, T_CONFIG_SHORT,   T_CONFIG_SCOPE_SERVER },
-                { NULL,			NULL, T_CONFIG_UNSET,	T_CONFIG_SCOPE_UNSET }
-        };
+		{ "mysql-vhost.db",       NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_SERVER },
+		{ "mysql-vhost.user",     NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_SERVER },
+		{ "mysql-vhost.pass",     NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_SERVER },
+		{ "mysql-vhost.sock",     NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_SERVER },
+		{ "mysql-vhost.sql",      NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_SERVER },
+		{ "mysql-vhost.hostname", NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_SERVER },
+		{ "mysql-vhost.port",     NULL, T_CONFIG_SHORT,  T_CONFIG_SCOPE_SERVER },
+		{ NULL,                   NULL, T_CONFIG_UNSET,  T_CONFIG_SCOPE_UNSET }
+	};
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
+	sel = buffer_init();
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
-		buffer *sel;
-
 
 		s = calloc(1, sizeof(plugin_config));
 		s->mydb = buffer_init();
@@ -198,8 +188,7 @@
 		s->mypass = buffer_init();
 		s->mysock = buffer_init();
 		s->hostname = buffer_init();
-		s->port   = 0;               /* default port for mysql */
-		sel = buffer_init();
+		s->port = 0;               /* default port for mysql */
 		s->mysql = NULL;
 
 		s->mysql_pre = buffer_init();
@@ -209,25 +198,26 @@
 		cv[1].destination = s->myuser;
 		cv[2].destination = s->mypass;
 		cv[3].destination = s->mysock;
+		buffer_reset(sel);
 		cv[4].destination = sel;
 		cv[5].destination = s->hostname;
 		cv[6].destination = &(s->port);
 
 		p->config_storage[i] = s;
 
-        	if (config_insert_values_global(srv,
+		if (config_insert_values_global(srv,
 			((data_config *)srv->config_context->data[i])->value,
 			cv)) return HANDLER_ERROR;
 
 		s->mysql_pre = buffer_init();
 		s->mysql_post = buffer_init();
 
-		if (sel->used && (qmark = strchr(sel->ptr, '?'))) {
+		if (!buffer_string_is_empty(sel) && (qmark = strchr(sel->ptr, '?'))) {
 			*qmark = '\0';
 			buffer_copy_string(s->mysql_pre, sel->ptr);
 			buffer_copy_string(s->mysql_post, qmark+1);
 		} else {
-			buffer_copy_string_buffer(s->mysql_pre, sel);
+			buffer_copy_buffer(s->mysql_pre, sel);
 		}
 
 		/* required:
@@ -242,13 +232,14 @@
 		 */
 
 		/* all have to be set */
-		if (!(buffer_is_empty(s->myuser) ||
-		      buffer_is_empty(s->mydb))) {
+		if (!(buffer_string_is_empty(s->myuser) ||
+		      buffer_string_is_empty(s->mydb))) {
 			my_bool reconnect = 1;
 
 			if (NULL == (s->mysql = mysql_init(NULL))) {
 				log_error_write(srv, __FILE__, __LINE__, "s", "mysql_init() failed, exiting...");
 
+				buffer_free(sel);
 				return HANDLER_ERROR;
 			}
 
@@ -257,10 +248,10 @@
 			mysql_options(s->mysql, MYSQL_OPT_RECONNECT, &reconnect);
 #endif
 
-#define FOO(x) (s->x->used ? s->x->ptr : NULL)
+#define FOO(x) (buffer_string_is_empty(s->x) ? NULL : s->x->ptr)
 
 #if MYSQL_VERSION_ID >= 40100
-                        /* CLIENT_MULTI_STATEMENTS first appeared in 4.1 */ 
+			/* CLIENT_MULTI_STATEMENTS first appeared in 4.1 */ 
 			if (!mysql_real_connect(s->mysql, FOO(hostname), FOO(myuser), FOO(mypass),
 						FOO(mydb), s->port, FOO(mysock), CLIENT_MULTI_STATEMENTS)) {
 #else
@@ -269,29 +260,16 @@
 #endif
 				log_error_write(srv, __FILE__, __LINE__, "s", mysql_error(s->mysql));
 
+				buffer_free(sel);
 				return HANDLER_ERROR;
 			}
 #undef FOO
 
-#if 0
-			/* set close_on_exec for mysql the hard way */
-			/* Note: this only works as it is done during startup, */
-			/* otherwise we cannot be sure that mysql is fd i-1 */
-			{ int fd;
-			if (-1 != (fd = open("/dev/null", 0))) {
-				close(fd);
-#ifdef FD_CLOEXEC
-				fcntl(fd-1, F_SETFD, FD_CLOEXEC);
-#endif
-			} }
-#else
-#ifdef FD_CLOEXEC
-			fcntl(s->mysql->net.fd, F_SETFD, FD_CLOEXEC);
-#endif
-#endif
+			fd_close_on_exec(s->mysql->net.fd);
 		}
 	}
 
+	buffer_free(sel);
 	return HANDLER_GO_ON;
 }
 
@@ -346,26 +324,35 @@
 	MYSQL_RES *result = NULL;
 
 	/* no host specified? */
-	if (!con->uri.authority->used) return HANDLER_GO_ON;
+	if (buffer_string_is_empty(con->uri.authority)) return HANDLER_GO_ON;
 
 	mod_mysql_vhost_patch_connection(srv, con, p);
 
 	if (!p->conf.mysql) return HANDLER_GO_ON;
+	if (buffer_string_is_empty(p->conf.mysql_pre)) return HANDLER_GO_ON;
 
 	/* sets up connection data if not done yet */
 	c = mod_mysql_vhost_connection_data(srv, con, p_d);
 
 	/* check if cached this connection */
-	if (c->server_name->used && /* con->uri.authority->used && */
-            buffer_is_equal(c->server_name, con->uri.authority)) goto GO_ON;
+	if (buffer_is_equal(c->server_name, con->uri.authority)) goto GO_ON;
 
 	/* build and run SQL query */
-	buffer_copy_string_buffer(p->tmp_buf, p->conf.mysql_pre);
-	if (p->conf.mysql_post->used) {
-		buffer_append_string_buffer(p->tmp_buf, con->uri.authority);
+	buffer_copy_buffer(p->tmp_buf, p->conf.mysql_pre);
+	if (!buffer_is_empty(p->conf.mysql_post)) {
+		/* escape the uri.authority */
+		unsigned long to_len;
+
+		buffer_string_prepare_append(p->tmp_buf, buffer_string_length(con->uri.authority) * 2);
+
+		to_len = mysql_real_escape_string(p->conf.mysql,
+				p->tmp_buf->ptr + buffer_string_length(p->tmp_buf),
+				CONST_BUF_LEN(con->uri.authority));
+		buffer_commit(p->tmp_buf, to_len);
+
 		buffer_append_string_buffer(p->tmp_buf, p->conf.mysql_post);
 	}
-   	if (mysql_query(p->conf.mysql, p->tmp_buf->ptr)) {
+	if (mysql_real_query(p->conf.mysql, CONST_BUF_LEN(p->tmp_buf))) {
 		log_error_write(srv, __FILE__, __LINE__, "s", mysql_error(p->conf.mysql));
 		goto ERR500;
 	}
@@ -383,51 +370,40 @@
 
 	/* sanity check that really is a directory */
 	buffer_copy_string(p->tmp_buf, row[0]);
-	BUFFER_APPEND_SLASH(p->tmp_buf);
+	buffer_append_slash(p->tmp_buf);
 
 	if (HANDLER_ERROR == stat_cache_get_entry(srv, con, p->tmp_buf, &sce)) {
 		log_error_write(srv, __FILE__, __LINE__, "sb", strerror(errno), p->tmp_buf);
 		goto ERR500;
 	}
-        if (!S_ISDIR(sce->st.st_mode)) {
+	if (!S_ISDIR(sce->st.st_mode)) {
 		log_error_write(srv, __FILE__, __LINE__, "sb", "Not a directory", p->tmp_buf);
 		goto ERR500;
 	}
 
 	/* cache the data */
-	buffer_copy_string_buffer(c->server_name, con->uri.authority);
-	buffer_copy_string_buffer(c->document_root, p->tmp_buf);
-
-	/* fcgi_offset and fcgi_arg are optional */
-	if (cols > 1 && row[1]) {
-		c->fcgi_offset = atoi(row[1]);
+	buffer_copy_buffer(c->server_name, con->uri.authority);
+	buffer_copy_buffer(c->document_root, p->tmp_buf);
 
-		if (cols > 2 && row[2]) {
-			buffer_copy_string(c->fcgi_arg, row[2]);
-		} else {
-			c->fcgi_arg->used = 0;
-		}
-	} else {
-		c->fcgi_offset = c->fcgi_arg->used = 0;
-	}
 	mysql_free_result(result);
 #if MYSQL_VERSION_ID >= 40100
 	while (mysql_next_result(p->conf.mysql) == 0);
 #endif
 
 	/* fix virtual server and docroot */
-GO_ON:	buffer_copy_string_buffer(con->server_name, c->server_name);
-	buffer_copy_string_buffer(con->physical.doc_root, c->document_root);
+GO_ON:
+	buffer_copy_buffer(con->server_name, c->server_name);
+	buffer_copy_buffer(con->physical.doc_root, c->document_root);
 
 #ifdef DEBUG
-	log_error_write(srv, __FILE__, __LINE__, "sbbdb",
+	log_error_write(srv, __FILE__, __LINE__, "sbb",
 		result ? "NOT CACHED" : "cached",
-		con->server_name, con->physical.doc_root,
-		c->fcgi_offset, c->fcgi_arg);
+		con->server_name, con->physical.doc_root);
 #endif
 	return HANDLER_GO_ON;
 
-ERR500:	if (result) mysql_free_result(result);
+ERR500:
+	if (result) mysql_free_result(result);
 #if MYSQL_VERSION_ID >= 40100
 	while (mysql_next_result(p->conf.mysql) == 0);
 #endif
diff -u lighttpd-1.4.32/src/mod_proxy.c lighttpd-1.4.36/src/mod_proxy.c
--- lighttpd-1.4.32/src/mod_proxy.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.36/src/mod_proxy.c	2015-07-26 05:36:36.000000000 -0500
@@ -167,12 +167,11 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
-			if (s) {
+			if (NULL == s) continue;
 
-				array_free(s->extensions);
+			array_free(s->extensions);
 
-				free(s);
-			}
+			free(s);
 		}
 		free(p->config_storage);
 	}
@@ -194,7 +193,7 @@
 		{ NULL,                        NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
 	};
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -217,7 +216,7 @@
 			return HANDLER_ERROR;
 		}
 
-		if (buffer_is_empty(p->balance_buf)) {
+		if (buffer_string_is_empty(p->balance_buf)) {
 			s->balance = PROXY_BALANCE_FAIR;
 		} else if (buffer_is_equal_string(p->balance_buf, CONST_STR_LEN("fair"))) {
 			s->balance = PROXY_BALANCE_FAIR;
@@ -292,16 +291,17 @@
 
 					df->port = 80;
 
-					buffer_copy_string_buffer(df->key, da_host->key);
+					buffer_copy_buffer(df->key, da_host->key);
 
 					pcv[0].destination = df->host;
 					pcv[1].destination = &(df->port);
 
 					if (0 != config_insert_values_internal(srv, da_host->value, pcv)) {
+						df->free((data_unset*) df);
 						return HANDLER_ERROR;
 					}
 
-					if (buffer_is_empty(df->host)) {
+					if (buffer_string_is_empty(df->host)) {
 						log_error_write(srv, __FILE__, __LINE__, "sbbbs",
 								"missing key (string):",
 								da->key,
@@ -309,6 +309,7 @@
 								da_host->key,
 								"host");
 
+						df->free((data_unset*) df);
 						return HANDLER_ERROR;
 					}
 
@@ -317,7 +318,7 @@
 					if (NULL == (dfa = (data_array *)array_get_element(s->extensions, da_ext->key->ptr))) {
 						dfa = data_array_init();
 
-						buffer_copy_string_buffer(dfa->key, da_ext->key);
+						buffer_copy_buffer(dfa->key, da_ext->key);
 
 						array_insert_unique(dfa->value, (data_unset *)df);
 						array_insert_unique(s->extensions, (data_unset *)dfa);
@@ -360,6 +361,9 @@
 static int proxy_establish_connection(server *srv, handler_ctx *hctx) {
 	struct sockaddr *proxy_addr;
 	struct sockaddr_in proxy_addr_in;
+#if defined(HAVE_SYS_UN_H)
+	struct sockaddr_un proxy_addr_un;
+#endif
 #if defined(HAVE_IPV6) && defined(HAVE_INET_PTON)
 	struct sockaddr_in6 proxy_addr_in6;
 #endif
@@ -370,6 +374,15 @@
 	int proxy_fd       = hctx->fd;
 
 
+#if defined(HAVE_SYS_UN_H)
+	if (strstr(host->host->ptr, "/")) {
+		memset(&proxy_addr_un, 0, sizeof(proxy_addr_un));
+		proxy_addr_un.sun_family = AF_UNIX;
+		strcpy(proxy_addr_un.sun_path, host->host->ptr);
+		servlen = sizeof(proxy_addr_un);
+		proxy_addr = (struct sockaddr *) &proxy_addr_un;
+	} else
+#endif
 #if defined(HAVE_IPV6) && defined(HAVE_INET_PTON)
 	if (strstr(host->host->ptr, ":")) {
 		memset(&proxy_addr_in6, 0, sizeof(proxy_addr_in6));
@@ -415,27 +428,27 @@
 }
 
 static void proxy_set_header(connection *con, const char *key, const char *value) {
-    data_string *ds_dst;
+	data_string *ds_dst;
+
+	if (NULL == (ds_dst = (data_string *)array_get_unused_element(con->request.headers, TYPE_STRING))) {
+		ds_dst = data_string_init();
+	}
 
-    if (NULL == (ds_dst = (data_string *)array_get_unused_element(con->request.headers, TYPE_STRING))) {
-          ds_dst = data_string_init();
-    }
-
-    buffer_copy_string(ds_dst->key, key);
-    buffer_copy_string(ds_dst->value, value);
-    array_insert_unique(con->request.headers, (data_unset *)ds_dst);
+	buffer_copy_string(ds_dst->key, key);
+	buffer_copy_string(ds_dst->value, value);
+	array_insert_unique(con->request.headers, (data_unset *)ds_dst);
 }
 
 static void proxy_append_header(connection *con, const char *key, const char *value) {
-    data_string *ds_dst;
+	data_string *ds_dst;
 
-    if (NULL == (ds_dst = (data_string *)array_get_unused_element(con->request.headers, TYPE_STRING))) {
-          ds_dst = data_string_init();
-    }
-
-    buffer_copy_string(ds_dst->key, key);
-    buffer_append_string(ds_dst->value, value);
-    array_insert_unique(con->request.headers, (data_unset *)ds_dst);
+	if (NULL == (ds_dst = (data_string *)array_get_unused_element(con->request.headers, TYPE_STRING))) {
+		ds_dst = data_string_init();
+	}
+
+	buffer_copy_string(ds_dst->key, key);
+	buffer_append_string(ds_dst->value, value);
+	array_insert_unique(con->request.headers, (data_unset *)ds_dst);
 }
 
 
@@ -447,7 +460,7 @@
 
 	/* build header */
 
-	b = chunkqueue_get_append_buffer(hctx->wb);
+	b = buffer_init();
 
 	/* request line */
 	buffer_copy_string(b, get_http_method_name(con->request.http_method));
@@ -459,11 +472,10 @@
 	proxy_append_header(con, "X-Forwarded-For", (char *)inet_ntop_cache_get_ip(srv, &(con->dst_addr)));
 	/* http_host is NOT is just a pointer to a buffer
 	 * which is NULL if it is not set */
-	if (con->request.http_host &&
-	    !buffer_is_empty(con->request.http_host)) {
+	if (!buffer_string_is_empty(con->request.http_host)) {
 		proxy_set_header(con, "X-Host", con->request.http_host->ptr);
 	}
-	proxy_set_header(con, "X-Forwarded-Proto", con->conf.is_ssl ? "https" : "http");
+	proxy_set_header(con, "X-Forwarded-Proto", con->uri.scheme->ptr);
 
 	/* request header */
 	for (i = 0; i < con->request.headers->used; i++) {
@@ -471,7 +483,7 @@
 
 		ds = (data_string *)con->request.headers->data[i];
 
-		if (ds->value->used && ds->key->used) {
+		if (!buffer_is_empty(ds->value) && !buffer_is_empty(ds->key)) {
 			if (buffer_is_equal_string(ds->key, CONST_STR_LEN("Connection"))) continue;
 			if (buffer_is_equal_string(ds->key, CONST_STR_LEN("Proxy-Connection"))) continue;
 
@@ -484,60 +496,16 @@
 
 	buffer_append_string_len(b, CONST_STR_LEN("\r\n"));
 
-	hctx->wb->bytes_in += b->used - 1;
+	hctx->wb->bytes_in += buffer_string_length(b);
+	chunkqueue_append_buffer(hctx->wb, b);
+	buffer_free(b);
+
 	/* body */
 
 	if (con->request.content_length) {
 		chunkqueue *req_cq = con->request_content_queue;
-		chunk *req_c;
-		off_t offset;
-
-		/* something to send ? */
-		for (offset = 0, req_c = req_cq->first; offset != req_cq->bytes_in; req_c = req_c->next) {
-			off_t weWant = req_cq->bytes_in - offset;
-			off_t weHave = 0;
-
-			/* we announce toWrite octects
-			 * now take all the request_content chunk that we need to fill this request
-			 * */
-
-			switch (req_c->type) {
-			case FILE_CHUNK:
-				weHave = req_c->file.length - req_c->offset;
-
-				if (weHave > weWant) weHave = weWant;
-
-				chunkqueue_append_file(hctx->wb, req_c->file.name, req_c->offset, weHave);
-
-				req_c->offset += weHave;
-				req_cq->bytes_out += weHave;
-
-				hctx->wb->bytes_in += weHave;
-
-				break;
-			case MEM_CHUNK:
-				/* append to the buffer */
-				weHave = req_c->mem->used - 1 - req_c->offset;
-
-				if (weHave > weWant) weHave = weWant;
-
-				b = chunkqueue_get_append_buffer(hctx->wb);
-				buffer_append_memory(b, req_c->mem->ptr + req_c->offset, weHave);
-				b->used++; /* add virtual \0 */
-
-				req_c->offset += weHave;
-				req_cq->bytes_out += weHave;
-
-				hctx->wb->bytes_in += weHave;
-
-				break;
-			default:
-				break;
-			}
-
-			offset += weHave;
-		}
 
+		chunkqueue_steal(hctx->wb, req_cq, req_cq->bytes_in);
 	}
 
 	return 0;
@@ -559,7 +527,7 @@
 
 	/* \r\n -> \0\0 */
 
-	buffer_copy_string_buffer(p->parse_response, in);
+	buffer_copy_buffer(p->parse_response, in);
 
 	for (s = p->parse_response->ptr; NULL != (ns = strstr(s, "\r\n")); s = ns + 2) {
 		char *key, *value;
@@ -663,19 +631,13 @@
 
 	if (p->conf.debug) {
 		log_error_write(srv, __FILE__, __LINE__, "sd",
-			       "proxy - have to read:", b);
+				"proxy - have to read:", b);
 	}
 
 	if (b > 0) {
-		if (hctx->response->used == 0) {
-			/* avoid too small buffer */
-			buffer_prepare_append(hctx->response, b + 1);
-			hctx->response->used = 1;
-		} else {
-			buffer_prepare_append(hctx->response, b);
-		}
+		buffer_string_prepare_append(hctx->response, b);
 
-		if (-1 == (r = read(hctx->fd, hctx->response->ptr + hctx->response->used - 1, b))) {
+		if (-1 == (r = read(hctx->fd, hctx->response->ptr + buffer_string_length(hctx->response), buffer_string_space(hctx->response)))) {
 			if (errno == EAGAIN) return 0;
 			log_error_write(srv, __FILE__, __LINE__, "sds",
 					"unexpected end-of-file (perhaps the proxy process died):",
@@ -684,10 +646,9 @@
 		}
 
 		/* this should be catched by the b > 0 above */
-		assert(r);
+		force_assert(r);
 
-		hctx->response->used += r;
-		hctx->response->ptr[hctx->response->used - 1] = '\0';
+		buffer_commit(hctx->response, r);
 
 #if 0
 		log_error_write(srv, __FILE__, __LINE__, "sdsbs",
@@ -696,19 +657,19 @@
 
 		if (0 == con->got_response) {
 			con->got_response = 1;
-			buffer_prepare_copy(hctx->response_header, 128);
+			buffer_string_prepare_copy(hctx->response_header, 1023);
 		}
 
 		if (0 == con->file_started) {
 			char *c;
 
 			/* search for the \r\n\r\n in the string */
-			if (NULL != (c = buffer_search_string_len(hctx->response, "\r\n\r\n", 4))) {
+			if (NULL != (c = buffer_search_string_len(hctx->response, CONST_STR_LEN("\r\n\r\n")))) {
 				size_t hlen = c - hctx->response->ptr + 4;
-				size_t blen = hctx->response->used - hlen - 1;
+				size_t blen = buffer_string_length(hctx->response) - hlen;
 				/* found */
 
-				buffer_append_string_len(hctx->response_header, hctx->response->ptr, c - hctx->response->ptr + 4);
+				buffer_append_string_len(hctx->response_header, hctx->response->ptr, hlen);
 #if 0
 				log_error_write(srv, __FILE__, __LINE__, "sb", "Header:", hctx->response_header);
 #endif
@@ -722,23 +683,21 @@
 				}
 
 				con->file_started = 1;
-				if (blen) {
-					http_chunk_append_mem(srv, con, c + 4, blen + 1);
-				}
-				hctx->response->used = 0;
+				if (blen > 0) http_chunk_append_mem(srv, con, c + 4, blen);
+				buffer_reset(hctx->response);
 				joblist_append(srv, con);
 			}
 		} else {
-			http_chunk_append_mem(srv, con, hctx->response->ptr, hctx->response->used);
+			http_chunk_append_buffer(srv, con, hctx->response);
 			joblist_append(srv, con);
-			hctx->response->used = 0;
+			buffer_reset(hctx->response);
 		}
 
 	} else {
 		/* reading from upstream done */
 		con->file_finished = 1;
 
-		http_chunk_append_mem(srv, con, NULL, 0);
+		http_chunk_close(srv, con);
 		joblist_append(srv, con);
 
 		fin = 1;
@@ -754,8 +713,7 @@
 
 	int ret;
 
-	if (!host ||
-	    (!host->host->used || !host->port)) return -1;
+	if (!host || buffer_string_is_empty(host->host) || !host->port) return -1;
 
 	switch(hctx->state) {
 	case PROXY_STATE_CONNECT:
@@ -770,19 +728,27 @@
 		break;
 
 	case PROXY_STATE_INIT:
+#if defined(HAVE_SYS_UN_H)
+		if (strstr(host->host->ptr,"/")) {
+			if (-1 == (hctx->fd = socket(AF_UNIX, SOCK_STREAM, 0))) {
+				log_error_write(srv, __FILE__, __LINE__, "ss", "socket failed: ", strerror(errno));
+				return HANDLER_ERROR;
+			}
+		} else
+#endif
 #if defined(HAVE_IPV6) && defined(HAVE_INET_PTON)
 		if (strstr(host->host->ptr,":")) {
-		    if (-1 == (hctx->fd = socket(AF_INET6, SOCK_STREAM, 0))) {
-			log_error_write(srv, __FILE__, __LINE__, "ss", "socket failed: ", strerror(errno));
-			return HANDLER_ERROR;
-		    }
+			if (-1 == (hctx->fd = socket(AF_INET6, SOCK_STREAM, 0))) {
+				log_error_write(srv, __FILE__, __LINE__, "ss", "socket failed: ", strerror(errno));
+				return HANDLER_ERROR;
+			}
 		} else
 #endif
 		{
-		    if (-1 == (hctx->fd = socket(AF_INET, SOCK_STREAM, 0))) {
-			log_error_write(srv, __FILE__, __LINE__, "ss", "socket failed: ", strerror(errno));
-			return HANDLER_ERROR;
-		    }
+			if (-1 == (hctx->fd = socket(AF_INET, SOCK_STREAM, 0))) {
+				log_error_write(srv, __FILE__, __LINE__, "ss", "socket failed: ", strerror(errno));
+				return HANDLER_ERROR;
+			}
 		}
 		hctx->fde_ndx = -1;
 
@@ -974,6 +940,7 @@
 		case 1:
 			/* we are done */
 			proxy_connection_close(srv, hctx);
+			log_error_write(srv, __FILE__, __LINE__, "s", "proxy request finished");
 
 			joblist_append(srv, con);
 			return HANDLER_FINISHED;
@@ -1090,7 +1057,7 @@
 		}
 
 		if (!con->file_finished) {
-			http_chunk_append_mem(srv, con, NULL, 0);
+			http_chunk_close(srv, con);
 		}
 
 		con->file_finished = 1;
@@ -1128,13 +1095,8 @@
 	mod_proxy_patch_connection(srv, con, p);
 
 	fn = con->uri.path;
-
-	if (fn->used == 0) {
-		return HANDLER_ERROR;
-	}
-
-	s_len = fn->used - 1;
-
+	if (buffer_string_is_empty(fn)) return HANDLER_ERROR;
+	s_len = buffer_string_length(fn);
 
 	path_info_offset = 0;
 
@@ -1149,9 +1111,9 @@
 
 		ext = (data_array *)p->conf.extensions->data[k];
 
-		if (ext->key->used == 0) continue;
+		if (buffer_is_empty(ext->key)) continue;
 
-		ct_len = ext->key->used - 1;
+		ct_len = buffer_string_length(ext->key);
 
 		if (s_len < ct_len) continue;
 
@@ -1256,7 +1218,7 @@
 		}
 
 		/* just to be sure */
-		assert(extension->value->used < INT_MAX);
+		force_assert(extension->value->used < INT_MAX);
 
 		host = (data_proxy *)extension->value->data[0];
 
diff -u lighttpd-1.4.32/src/mod_redirect.c lighttpd-1.4.36/src/mod_redirect.c
--- lighttpd-1.4.32/src/mod_redirect.c	2012-05-30 11:54:43.000000000 -0500
+++ lighttpd-1.4.36/src/mod_redirect.c	2015-07-26 05:36:36.000000000 -0500
@@ -47,6 +47,8 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
+			if (NULL == s) continue;
+
 			pcre_keyvalue_buffer_free(s->redirect);
 
 			free(s);
@@ -65,7 +67,6 @@
 
 SETDEFAULTS_FUNC(mod_redirect_set_defaults) {
 	plugin_data *p = p_d;
-	data_unset *du;
 	size_t i = 0;
 
 	config_values_t cv[] = {
@@ -77,13 +78,14 @@
 	if (!p) return HANDLER_ERROR;
 
 	/* 0 */
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
 		size_t j;
 		array *ca;
-		data_array *da = (data_array *)du;
+		data_unset *du;
+		data_array *da;
 
 		s = calloc(1, sizeof(plugin_config));
 		s->redirect   = pcre_keyvalue_buffer_init();
@@ -129,6 +131,7 @@
 
 				log_error_write(srv, __FILE__, __LINE__, "sb",
 						"pcre-compile failed for", da->value->data[j]->key);
+				return HANDLER_ERROR;
 			}
 		}
 	}
@@ -182,7 +185,7 @@
 
 	mod_redirect_patch_connection(srv, con, p);
 
-	buffer_copy_string_buffer(p->match_buf, con->request.uri);
+	buffer_copy_buffer(p->match_buf, con->request.uri);
 
 	for (i = 0; i < p->conf.redirect->used; i++) {
 		pcre *match;
@@ -197,9 +200,9 @@
 		match       = kv->key;
 		extra       = kv->key_extra;
 		pattern     = kv->value->ptr;
-		pattern_len = kv->value->used - 1;
+		pattern_len = buffer_string_length(kv->value);
 
-		if ((n = pcre_exec(match, extra, p->match_buf->ptr, p->match_buf->used - 1, 0, 0, ovec, 3 * N)) < 0) {
+		if ((n = pcre_exec(match, extra, CONST_BUF_LEN(p->match_buf), 0, 0, ovec, 3 * N)) < 0) {
 			if (n != PCRE_ERROR_NOMATCH) {
 				log_error_write(srv, __FILE__, __LINE__, "sd",
 						"execution error while matching: ", n);
diff -u lighttpd-1.4.32/src/mod_rewrite.c lighttpd-1.4.36/src/mod_rewrite.c
--- lighttpd-1.4.32/src/mod_rewrite.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.36/src/mod_rewrite.c	2015-07-26 05:36:36.000000000 -0500
@@ -101,7 +101,7 @@
 	}
 
 	kvb->ptr[kvb->used]->value = buffer_init();
-	buffer_copy_string_buffer(kvb->ptr[kvb->used]->value, value);
+	buffer_copy_buffer(kvb->ptr[kvb->used]->value, value);
 	kvb->ptr[kvb->used]->once = once;
 
 	kvb->used++;
@@ -146,6 +146,9 @@
 		size_t i;
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
+
+			if (NULL == s) continue;
+
 			rewrite_rule_buffer_free(s->rewrite);
 			rewrite_rule_buffer_free(s->rewrite_NF);
 
@@ -191,6 +194,7 @@
 							    once)) {
 				log_error_write(srv, __FILE__, __LINE__, "sb",
 						"pcre-compile failed for", da->value->data[j]->key);
+				return HANDLER_ERROR;
 			}
 		}
 	}
@@ -242,7 +246,7 @@
 	if (!p) return HANDLER_ERROR;
 
 	/* 0 */
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 #else
 	UNUSED(p_d);
 #endif
@@ -296,8 +300,6 @@
 		data_config *dc = (data_config *)srv->config_context->data[i];
 		s = p->config_storage[i];
 
-		if (COMP_HTTP_URL == dc->comp) continue;
-
 		/* condition didn't match */
 		if (!config_check_cond(srv, con, dc)) continue;
 
@@ -360,7 +362,7 @@
 		if (hctx->state == REWRITE_STATE_FINISHED) return HANDLER_GO_ON;
 	}
 
-	buffer_copy_string_buffer(p->match_buf, con->request.uri);
+	buffer_copy_buffer(p->match_buf, con->request.uri);
 
 	for (i = 0; i < kvb->used; i++) {
 		pcre *match;
@@ -373,9 +375,9 @@
 
 		match       = rule->key;
 		pattern     = rule->value->ptr;
-		pattern_len = rule->value->used - 1;
+		pattern_len = buffer_string_length(rule->value);
 
-		if ((n = pcre_exec(match, NULL, p->match_buf->ptr, p->match_buf->used - 1, 0, 0, ovec, 3 * N)) < 0) {
+		if ((n = pcre_exec(match, NULL, CONST_BUF_LEN(p->match_buf), 0, 0, ovec, 3 * N)) < 0) {
 			if (n != PCRE_ERROR_NOMATCH) {
 				log_error_write(srv, __FILE__, __LINE__, "sd",
 						"execution error while matching: ", n);
diff -u lighttpd-1.4.32/src/mod_rrdtool.c lighttpd-1.4.36/src/mod_rrdtool.c
--- lighttpd-1.4.32/src/mod_rrdtool.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/mod_rrdtool.c	2015-07-26 05:36:36.000000000 -0500
@@ -7,6 +7,7 @@
 #include "plugin.h"
 #include <sys/types.h>
 
+#include <assert.h>
 #include <fcntl.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -64,6 +65,8 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
+			if (NULL == s) continue;
+
 			buffer_free(s->path_rrdtool_bin);
 			buffer_free(s->path_rrd);
 
@@ -169,10 +172,8 @@
 		p->read_fd = from_rrdtool_fds[0];
 		p->rrdtool_pid = pid;
 
-#ifdef FD_CLOEXEC
-		fcntl(p->write_fd, F_SETFD, FD_CLOEXEC);
-		fcntl(p->read_fd, F_SETFD, FD_CLOEXEC);
-#endif
+		fd_close_on_exec(p->write_fd);
+		fd_close_on_exec(p->read_fd);
 
 		break;
 	}
@@ -265,22 +266,22 @@
 		"RRA:MIN:0.5:24:775 "
 		"RRA:MIN:0.5:288:797\n"));
 
-	if (-1 == (safe_write(p->write_fd, p->cmd->ptr, p->cmd->used - 1))) {
+	if (-1 == (safe_write(p->write_fd, CONST_BUF_LEN(p->cmd)))) {
 		log_error_write(srv, __FILE__, __LINE__, "ss",
 			"rrdtool-write: failed", strerror(errno));
 
 		return HANDLER_ERROR;
 	}
 
-	buffer_prepare_copy(p->resp, 4096);
-	if (-1 == (r = safe_read(p->read_fd, p->resp->ptr, p->resp->size))) {
+	buffer_string_prepare_copy(p->resp, 4095);
+	if (-1 == (r = safe_read(p->read_fd, p->resp->ptr, p->resp->size - 1))) {
 		log_error_write(srv, __FILE__, __LINE__, "ss",
 			"rrdtool-read: failed", strerror(errno));
 
 		return HANDLER_ERROR;
 	}
 
-	p->resp->used = r;
+	buffer_commit(p->resp, r);
 
 	if (p->resp->ptr[0] != 'O' ||
 		p->resp->ptr[1] != 'K') {
@@ -345,7 +346,8 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	force_assert(srv->config_context->used > 0);
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -366,7 +368,7 @@
 			return HANDLER_ERROR;
 		}
 
-		if (i > 0 && !buffer_is_empty(s->path_rrdtool_bin)) {
+		if (i > 0 && !buffer_string_is_empty(s->path_rrdtool_bin)) {
 			/* path_rrdtool_bin is a global option */
 
 			log_error_write(srv, __FILE__, __LINE__, "s",
@@ -382,7 +384,7 @@
 
 	/* check for dir */
 
-	if (buffer_is_empty(p->conf.path_rrdtool_bin)) {
+	if (buffer_string_is_empty(p->conf.path_rrdtool_bin)) {
 		log_error_write(srv, __FILE__, __LINE__, "s",
 				"rrdtool.binary has to be set");
 		return HANDLER_ERROR;
@@ -409,7 +411,7 @@
 		plugin_config *s = p->config_storage[i];
 		int r;
 
-		if (buffer_is_empty(s->path_rrd)) continue;
+		if (buffer_string_is_empty(s->path_rrd)) continue;
 
 		/* write the data down every minute */
 
@@ -418,14 +420,14 @@
 		buffer_copy_string_len(p->cmd, CONST_STR_LEN("update "));
 		buffer_append_string_buffer(p->cmd, s->path_rrd);
 		buffer_append_string_len(p->cmd, CONST_STR_LEN(" N:"));
-		buffer_append_off_t(p->cmd, s->bytes_read);
+		buffer_append_int(p->cmd, s->bytes_read);
 		buffer_append_string_len(p->cmd, CONST_STR_LEN(":"));
-		buffer_append_off_t(p->cmd, s->bytes_written);
+		buffer_append_int(p->cmd, s->bytes_written);
 		buffer_append_string_len(p->cmd, CONST_STR_LEN(":"));
-		buffer_append_long(p->cmd, s->requests);
+		buffer_append_int(p->cmd, s->requests);
 		buffer_append_string_len(p->cmd, CONST_STR_LEN("\n"));
 
-		if (-1 == (r = safe_write(p->write_fd, p->cmd->ptr, p->cmd->used - 1))) {
+		if (-1 == (r = safe_write(p->write_fd, CONST_BUF_LEN(p->cmd)))) {
 			p->rrdtool_running = 0;
 
 			log_error_write(srv, __FILE__, __LINE__, "ss",
@@ -434,8 +436,8 @@
 			return HANDLER_ERROR;
 		}
 
-		buffer_prepare_copy(p->resp, 4096);
-		if (-1 == (r = safe_read(p->read_fd, p->resp->ptr, p->resp->size))) {
+		buffer_string_prepare_copy(p->resp, 4095);
+		if (-1 == (r = safe_read(p->read_fd, p->resp->ptr, p->resp->size - 1))) {
 			p->rrdtool_running = 0;
 
 			log_error_write(srv, __FILE__, __LINE__, "ss",
@@ -444,7 +446,7 @@
 			return HANDLER_ERROR;
 		}
 
-		p->resp->used = r;
+		buffer_commit(p->resp, r);
 
 		if (p->resp->ptr[0] != 'O' ||
 		    p->resp->ptr[1] != 'K') {
diff -u lighttpd-1.4.32/src/mod_scgi.c lighttpd-1.4.36/src/mod_scgi.c
--- lighttpd-1.4.32/src/mod_scgi.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.36/src/mod_scgi.c	2015-07-26 05:36:36.000000000 -0500
@@ -306,7 +306,6 @@
 
 	int      reconnects; /* number of reconnect attempts */
 
-	read_buffer *rb;
 	chunkqueue *wb;
 
 	buffer   *response_header;
@@ -351,7 +350,7 @@
 	handler_ctx * hctx;
 
 	hctx = calloc(1, sizeof(*hctx));
-	assert(hctx);
+	force_assert(hctx);
 
 	hctx->fde_ndx = -1;
 
@@ -380,11 +379,6 @@
 
 	chunkqueue_free(hctx->wb);
 
-	if (hctx->rb) {
-		if (hctx->rb->ptr) free(hctx->rb->ptr);
-		free(hctx->rb);
-	}
-
 	free(hctx);
 }
 
@@ -495,20 +489,20 @@
 	if (i == ext->used) {
 		/* filextension is new */
 		fe = calloc(1, sizeof(*fe));
-		assert(fe);
+		force_assert(fe);
 		fe->key = buffer_init();
-		buffer_copy_string_buffer(fe->key, key);
+		buffer_copy_buffer(fe->key, key);
 
 		/* */
 
 		if (ext->size == 0) {
 			ext->size = 8;
 			ext->exts = malloc(ext->size * sizeof(*(ext->exts)));
-			assert(ext->exts);
+			force_assert(ext->exts);
 		} else if (ext->used == ext->size) {
 			ext->size += 8;
 			ext->exts = realloc(ext->exts, ext->size * sizeof(*(ext->exts)));
-			assert(ext->exts);
+			force_assert(ext->exts);
 		}
 		ext->exts[ext->used++] = fe;
 	} else {
@@ -518,11 +512,11 @@
 	if (fe->size == 0) {
 		fe->size = 4;
 		fe->hosts = malloc(fe->size * sizeof(*(fe->hosts)));
-		assert(fe->hosts);
+		force_assert(fe->hosts);
 	} else if (fe->size == fe->used) {
 		fe->size += 4;
 		fe->hosts = realloc(fe->hosts, fe->size * sizeof(*(fe->hosts)));
-		assert(fe->hosts);
+		force_assert(fe->hosts);
 	}
 
 	fe->hosts[fe->used++] = fh;
@@ -560,7 +554,7 @@
 			plugin_config *s = p->config_storage[i];
 			scgi_exts *exts;
 
-			if (!s) continue;
+			if (NULL == s) continue;
 
 			exts = s->exts;
 
@@ -579,7 +573,7 @@
 						if (proc->pid != 0) kill(proc->pid, SIGTERM);
 
 						if (proc->is_local &&
-						    !buffer_is_empty(proc->socket)) {
+						    !buffer_string_is_empty(proc->socket)) {
 							unlink(proc->socket->ptr);
 						}
 					}
@@ -588,7 +582,7 @@
 						if (proc->pid != 0) kill(proc->pid, SIGTERM);
 
 						if (proc->is_local &&
-						    !buffer_is_empty(proc->socket)) {
+						    !buffer_string_is_empty(proc->socket)) {
 							unlink(proc->socket->ptr);
 						}
 					}
@@ -665,18 +659,24 @@
 				"new proc, socket:", proc->port, proc->socket);
 	}
 
-	if (!buffer_is_empty(proc->socket)) {
+	if (!buffer_string_is_empty(proc->socket)) {
 		memset(&scgi_addr, 0, sizeof(scgi_addr));
 
 #ifdef HAVE_SYS_UN_H
 		scgi_addr_un.sun_family = AF_UNIX;
-		strcpy(scgi_addr_un.sun_path, proc->socket->ptr);
+		if (buffer_string_length(proc->socket) + 1 > sizeof(scgi_addr_un.sun_path)) {
+			log_error_write(srv, __FILE__, __LINE__, "sB",
+					"ERROR: Unix Domain socket filename too long:",
+					proc->socket);
+			return -1;
+		}
+		memcpy(scgi_addr_un.sun_path, proc->socket->ptr, buffer_string_length(proc->socket) + 1);
 
 #ifdef SUN_LEN
 		servlen = SUN_LEN(&scgi_addr_un);
 #else
 		/* stevens says: */
-		servlen = proc->socket->used + sizeof(scgi_addr_un.sun_family);
+		servlen = buffer_string_length(proc->socket) + 1 + sizeof(scgi_addr_un.sun_family);
 #endif
 		socket_type = AF_UNIX;
 		scgi_addr = (struct sockaddr *) &scgi_addr_un;
@@ -688,7 +688,7 @@
 	} else {
 		scgi_addr_in.sin_family = AF_INET;
 
-		if (buffer_is_empty(host->host)) {
+		if (buffer_string_is_empty(host->host)) {
 			scgi_addr_in.sin_addr.s_addr = htonl(INADDR_ANY);
 		} else {
 			struct hostent *he;
@@ -735,7 +735,7 @@
 		pid_t child;
 		int val;
 
-		if (!buffer_is_empty(proc->socket)) {
+		if (!buffer_string_is_empty(proc->socket)) {
 			unlink(proc->socket->ptr);
 		}
 
@@ -752,6 +752,7 @@
 		if (setsockopt(scgi_fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val)) < 0) {
 			log_error_write(srv, __FILE__, __LINE__, "ss",
 					"socketsockopt failed:", strerror(errno));
+			close(scgi_fd);
 			return -1;
 		}
 
@@ -762,12 +763,14 @@
 				proc->socket,
 				proc->port,
 				strerror(errno));
+			close(scgi_fd);
 			return -1;
 		}
 
 		if (-1 == listen(scgi_fd, 1024)) {
 			log_error_write(srv, __FILE__, __LINE__, "ss",
 				"listen failed:", strerror(errno));
+			close(scgi_fd);
 			return -1;
 		}
 
@@ -918,6 +921,7 @@
 	plugin_data *p = p_d;
 	data_unset *du;
 	size_t i = 0;
+	scgi_extension_host *df = NULL;
 
 	config_values_t cv[] = {
 		{ "scgi.server",              NULL, T_CONFIG_LOCAL, T_CONFIG_SCOPE_CONNECTION },       /* 0 */
@@ -925,7 +929,7 @@
 		{ NULL,                          NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
 	};
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -942,7 +946,7 @@
 		ca = ((data_config *)srv->config_context->data[i])->value;
 
 		if (0 != config_insert_values_global(srv, ca, cv)) {
-			return HANDLER_ERROR;
+			goto error;
 		}
 
 		/*
@@ -957,7 +961,7 @@
 				log_error_write(srv, __FILE__, __LINE__, "sss",
 						"unexpected type for key: ", "scgi.server", "array of strings");
 
-				return HANDLER_ERROR;
+				goto error;
 			}
 
 
@@ -975,7 +979,7 @@
 							"unexpected type for key: ", "scgi.server",
 							"[", da->value->data[j]->key, "](string)");
 
-					return HANDLER_ERROR;
+					goto error;
 				}
 
 				/*
@@ -993,8 +997,6 @@
 				for (n = 0; n < da_ext->value->used; n++) {
 					data_array *da_host = (data_array *)da_ext->value->data[n];
 
-					scgi_extension_host *df;
-
 					config_values_t fcv[] = {
 						{ "host",              NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },       /* 0 */
 						{ "docroot",           NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },       /* 1 */
@@ -1023,7 +1025,7 @@
 								"scgi.server",
 								"[", da_host->key, "](string)");
 
-						return HANDLER_ERROR;
+						goto error;
 					}
 
 					df = scgi_host_init();
@@ -1055,31 +1057,31 @@
 
 
 					if (0 != config_insert_values_internal(srv, da_host->value, fcv)) {
-						return HANDLER_ERROR;
+						goto error;
 					}
 
-					if ((!buffer_is_empty(df->host) || df->port) &&
-					    !buffer_is_empty(df->unixsocket)) {
+					if ((!buffer_string_is_empty(df->host) || df->port) &&
+					    !buffer_string_is_empty(df->unixsocket)) {
 						log_error_write(srv, __FILE__, __LINE__, "s",
 								"either host+port or socket");
 
-						return HANDLER_ERROR;
+						goto error;
 					}
 
-					if (!buffer_is_empty(df->unixsocket)) {
+					if (!buffer_string_is_empty(df->unixsocket)) {
 						/* unix domain socket */
 						struct sockaddr_un un;
 
-						if (df->unixsocket->used > sizeof(un.sun_path) - 2) {
+						if (buffer_string_length(df->unixsocket) + 1 > sizeof(un.sun_path) - 2) {
 							log_error_write(srv, __FILE__, __LINE__, "s",
 									"path of the unixdomain socket is too large");
-							return HANDLER_ERROR;
+							goto error;
 						}
 					} else {
 						/* tcp/ip */
 
-						if (buffer_is_empty(df->host) &&
-						    buffer_is_empty(df->bin_path)) {
+						if (buffer_string_is_empty(df->host) &&
+						    buffer_string_is_empty(df->bin_path)) {
 							log_error_write(srv, __FILE__, __LINE__, "sbbbs",
 									"missing key (string):",
 									da->key,
@@ -1087,7 +1089,7 @@
 									da_host->key,
 									"host");
 
-							return HANDLER_ERROR;
+							goto error;
 						} else if (df->port == 0) {
 							log_error_write(srv, __FILE__, __LINE__, "sbbbs",
 									"missing key (short):",
@@ -1095,11 +1097,11 @@
 									da_ext->key,
 									da_host->key,
 									"port");
-							return HANDLER_ERROR;
+							goto error;
 						}
 					}
 
-					if (!buffer_is_empty(df->bin_path)) {
+					if (!buffer_string_is_empty(df->bin_path)) {
 						/* a local socket + self spawning */
 						size_t pno;
 
@@ -1126,12 +1128,12 @@
 							proc->id = df->num_procs++;
 							df->max_id++;
 
-							if (buffer_is_empty(df->unixsocket)) {
+							if (buffer_string_is_empty(df->unixsocket)) {
 								proc->port = df->port + pno;
 							} else {
-								buffer_copy_string_buffer(proc->socket, df->unixsocket);
+								buffer_copy_buffer(proc->socket, df->unixsocket);
 								buffer_append_string_len(proc->socket, CONST_STR_LEN("-"));
-								buffer_append_long(proc->socket, pno);
+								buffer_append_int(proc->socket, pno);
 							}
 
 							if (s->debug) {
@@ -1145,7 +1147,8 @@
 							if (scgi_spawn_connection(srv, p, df, proc)) {
 								log_error_write(srv, __FILE__, __LINE__, "s",
 										"[ERROR]: spawning fcgi failed.");
-								return HANDLER_ERROR;
+								scgi_process_free(proc);
+								goto error;
 							}
 
 							proc->next = df->first;
@@ -1162,10 +1165,10 @@
 						df->active_procs++;
 						fp->state = PROC_STATE_RUNNING;
 
-						if (buffer_is_empty(df->unixsocket)) {
+						if (buffer_string_is_empty(df->unixsocket)) {
 							fp->port = df->port;
 						} else {
-							buffer_copy_string_buffer(fp->socket, df->unixsocket);
+							buffer_copy_buffer(fp->socket, df->unixsocket);
 						}
 
 						df->first = fp;
@@ -1176,12 +1179,17 @@
 
 					/* if extension already exists, take it */
 					scgi_extension_insert(s->exts, da_ext->key, df);
+					df = NULL;
 				}
 			}
 		}
 	}
 
 	return HANDLER_GO_ON;
+
+error:
+	if (NULL != df) scgi_host_free(df);
+	return HANDLER_ERROR;
 }
 
 static int scgi_set_state(server *srv, handler_ctx *hctx, scgi_connection_state_t state) {
@@ -1293,14 +1301,12 @@
 
 	len = key_len + val_len + 2;
 
-	buffer_prepare_append(env, len);
+	buffer_string_prepare_append(env, len);
 
-	memcpy(env->ptr + env->used, key, key_len);
-	env->ptr[env->used + key_len] = '\0';
-	env->used += key_len + 1;
-	memcpy(env->ptr + env->used, val, val_len);
-	env->ptr[env->used + val_len] = '\0';
-	env->used += val_len + 1;
+	buffer_append_string_len(env, key, key_len);
+	buffer_append_string_len(env, "", 1);
+	buffer_append_string_len(env, val, val_len);
+	buffer_append_string_len(env, "", 1);
 
 	return 0;
 }
@@ -1328,16 +1334,23 @@
 
 	memset(&scgi_addr, 0, sizeof(scgi_addr));
 
-	if (!buffer_is_empty(proc->socket)) {
+	if (!buffer_string_is_empty(proc->socket)) {
 #ifdef HAVE_SYS_UN_H
 		/* use the unix domain socket */
 		scgi_addr_un.sun_family = AF_UNIX;
-		strcpy(scgi_addr_un.sun_path, proc->socket->ptr);
+		if (buffer_string_length(proc->socket) + 1 > sizeof(scgi_addr_un.sun_path)) {
+			log_error_write(srv, __FILE__, __LINE__, "sB",
+					"ERROR: Unix Domain socket filename too long:",
+					proc->socket);
+			return -1;
+		}
+		memcpy(scgi_addr_un.sun_path, proc->socket->ptr, buffer_string_length(proc->socket) + 1);
+
 #ifdef SUN_LEN
 		servlen = SUN_LEN(&scgi_addr_un);
 #else
 		/* stevens says: */
-		servlen = proc->socket->used + sizeof(scgi_addr_un.sun_family);
+		servlen = buffer_string_length(proc->socket) + 1 + sizeof(scgi_addr_un.sun_family);
 #endif
 		scgi_addr = (struct sockaddr *) &scgi_addr_un;
 #else
@@ -1403,22 +1416,8 @@
 
 		ds = (data_string *)con->request.headers->data[i];
 
-		if (ds->value->used && ds->key->used) {
-			size_t j;
-			buffer_reset(srv->tmp_buf);
-
-			if (0 != strcasecmp(ds->key->ptr, "CONTENT-TYPE")) {
-				buffer_copy_string_len(srv->tmp_buf, CONST_STR_LEN("HTTP_"));
-				srv->tmp_buf->used--;
-			}
-
-			buffer_prepare_append(srv->tmp_buf, ds->key->used + 2);
-			for (j = 0; j < ds->key->used - 1; j++) {
-				srv->tmp_buf->ptr[srv->tmp_buf->used++] =
-					light_isalpha(ds->key->ptr[j]) ?
-					ds->key->ptr[j] & ~32 : '_';
-			}
-			srv->tmp_buf->ptr[srv->tmp_buf->used++] = '\0';
+		if (!buffer_is_empty(ds->value) && !buffer_is_empty(ds->key)) {
+			buffer_copy_string_encoded_cgi_varnames(srv->tmp_buf, CONST_BUF_LEN(ds->key), 1);
 
 			scgi_env_add(p->scgi_env, CONST_BUF_LEN(srv->tmp_buf), CONST_BUF_LEN(ds->value));
 		}
@@ -1429,17 +1428,8 @@
 
 		ds = (data_string *)con->environment->data[i];
 
-		if (ds->value->used && ds->key->used) {
-			size_t j;
-			buffer_reset(srv->tmp_buf);
-
-			buffer_prepare_append(srv->tmp_buf, ds->key->used + 2);
-			for (j = 0; j < ds->key->used - 1; j++) {
-				srv->tmp_buf->ptr[srv->tmp_buf->used++] =
-					light_isalnum((unsigned char)ds->key->ptr[j]) ?
-					toupper((unsigned char)ds->key->ptr[j]) : '_';
-			}
-			srv->tmp_buf->ptr[srv->tmp_buf->used++] = '\0';
+		if (!buffer_is_empty(ds->value) && !buffer_is_empty(ds->key)) {
+			buffer_copy_string_encoded_cgi_varnames(srv->tmp_buf, CONST_BUF_LEN(ds->key), 0);
 
 			scgi_env_add(p->scgi_env, CONST_BUF_LEN(srv->tmp_buf), CONST_BUF_LEN(ds->value));
 		}
@@ -1450,7 +1440,7 @@
 
 
 static int scgi_create_env(server *srv, handler_ctx *hctx) {
-	char buf[32];
+	char buf[LI_ITOSTRING_LENGTH];
 	const char *s;
 #ifdef HAVE_IPV6
 	char b2[INET6_ADDRSTRLEN + 1];
@@ -1466,12 +1456,11 @@
 	sock_addr our_addr;
 	socklen_t our_addr_len;
 
-	buffer_prepare_copy(p->scgi_env, 1024);
+	buffer_string_prepare_copy(p->scgi_env, 1023);
 
 	/* CGI-SPEC 6.1.2, FastCGI spec 6.3 and SCGI spec */
 
-	/* request.content_length < SSIZE_MAX, see request.c */
-	LI_ltostr(buf, con->request.content_length);
+	li_itostr(buf, con->request.content_length);
 	scgi_env_add(p->scgi_env, CONST_STR_LEN("CONTENT_LENGTH"), buf, strlen(buf));
 	scgi_env_add(p->scgi_env, CONST_STR_LEN("SCGI"), CONST_STR_LEN("1"));
 
@@ -1482,8 +1471,8 @@
 		scgi_env_add(p->scgi_env, CONST_STR_LEN("SERVER_SOFTWARE"), CONST_BUF_LEN(con->conf.server_tag));
 	}
 
-	if (con->server_name->used) {
-		size_t len = con->server_name->used - 1;
+	if (!buffer_is_empty(con->server_name)) {
+		size_t len = buffer_string_length(con->server_name);
 
 		if (con->server_name->ptr[0] == '[') {
 			const char *colon = strstr(con->server_name->ptr, "]:");
@@ -1509,7 +1498,7 @@
 
 	scgi_env_add(p->scgi_env, CONST_STR_LEN("GATEWAY_INTERFACE"), CONST_STR_LEN("CGI/1.1"));
 
-	LI_ltostr(buf,
+	li_utostr(buf,
 #ifdef HAVE_IPV6
 	       ntohs(srv_sock->addr.plain.sa_family ? srv_sock->addr.ipv6.sin6_port : srv_sock->addr.ipv4.sin_port)
 #else
@@ -1529,7 +1518,7 @@
 	}
 	scgi_env_add(p->scgi_env, CONST_STR_LEN("SERVER_ADDR"), s, strlen(s));
 
-	LI_ltostr(buf,
+	li_utostr(buf,
 #ifdef HAVE_IPV6
 	       ntohs(con->dst_addr.plain.sa_family ? con->dst_addr.ipv6.sin6_port : con->dst_addr.ipv4.sin_port)
 #else
@@ -1542,12 +1531,6 @@
 	s = inet_ntop_cache_get_ip(srv, &(con->dst_addr));
 	scgi_env_add(p->scgi_env, CONST_STR_LEN("REMOTE_ADDR"), s, strlen(s));
 
-	if (!buffer_is_empty(con->authed_user)) {
-		scgi_env_add(p->scgi_env, CONST_STR_LEN("REMOTE_USER"),
-			     CONST_BUF_LEN(con->authed_user));
-	}
-
-
 	/*
 	 * SCRIPT_NAME, PATH_INFO and PATH_TRANSLATED according to
 	 * http://cgi-spec.golux.com/draft-coar-cgi-v11-03-clean.html
@@ -1556,15 +1539,15 @@
 
 	scgi_env_add(p->scgi_env, CONST_STR_LEN("SCRIPT_NAME"), CONST_BUF_LEN(con->uri.path));
 
-	if (!buffer_is_empty(con->request.pathinfo)) {
+	if (!buffer_string_is_empty(con->request.pathinfo)) {
 		scgi_env_add(p->scgi_env, CONST_STR_LEN("PATH_INFO"), CONST_BUF_LEN(con->request.pathinfo));
 
 		/* PATH_TRANSLATED is only defined if PATH_INFO is set */
 
-		if (!buffer_is_empty(host->docroot)) {
-			buffer_copy_string_buffer(p->path, host->docroot);
+		if (!buffer_string_is_empty(host->docroot)) {
+			buffer_copy_buffer(p->path, host->docroot);
 		} else {
-			buffer_copy_string_buffer(p->path, con->physical.basedir);
+			buffer_copy_buffer(p->path, con->physical.basedir);
 		}
 		buffer_append_string_buffer(p->path, con->request.pathinfo);
 		scgi_env_add(p->scgi_env, CONST_STR_LEN("PATH_TRANSLATED"), CONST_BUF_LEN(p->path));
@@ -1580,19 +1563,19 @@
 	 * parameter.
 	 */
 
-	if (!buffer_is_empty(host->docroot)) {
+	if (!buffer_string_is_empty(host->docroot)) {
 		/*
 		 * rewrite SCRIPT_FILENAME
 		 *
 		 */
 
-		buffer_copy_string_buffer(p->path, host->docroot);
+		buffer_copy_buffer(p->path, host->docroot);
 		buffer_append_string_buffer(p->path, con->uri.path);
 
 		scgi_env_add(p->scgi_env, CONST_STR_LEN("SCRIPT_FILENAME"), CONST_BUF_LEN(p->path));
 		scgi_env_add(p->scgi_env, CONST_STR_LEN("DOCUMENT_ROOT"), CONST_BUF_LEN(host->docroot));
 	} else {
-		buffer_copy_string_buffer(p->path, con->physical.path);
+		buffer_copy_buffer(p->path, con->physical.path);
 
 		scgi_env_add(p->scgi_env, CONST_STR_LEN("SCRIPT_FILENAME"), CONST_BUF_LEN(p->path));
 		scgi_env_add(p->scgi_env, CONST_STR_LEN("DOCUMENT_ROOT"), CONST_BUF_LEN(con->physical.basedir));
@@ -1601,7 +1584,7 @@
 	if (!buffer_is_equal(con->request.uri, con->request.orig_uri)) {
 		scgi_env_add(p->scgi_env, CONST_STR_LEN("REDIRECT_URI"), CONST_BUF_LEN(con->request.uri));
 	}
-	if (!buffer_is_empty(con->uri.query)) {
+	if (!buffer_string_is_empty(con->uri.query)) {
 		scgi_env_add(p->scgi_env, CONST_STR_LEN("QUERY_STRING"), CONST_BUF_LEN(con->uri.query));
 	} else {
 		scgi_env_add(p->scgi_env, CONST_STR_LEN("QUERY_STRING"), CONST_STR_LEN(""));
@@ -1614,72 +1597,28 @@
 	scgi_env_add(p->scgi_env, CONST_STR_LEN("SERVER_PROTOCOL"), s, strlen(s));
 
 #ifdef USE_OPENSSL
-	if (srv_sock->is_ssl) {
+	if (buffer_is_equal_caseless_string(con->uri.scheme, CONST_STR_LEN("https"))) {
 		scgi_env_add(p->scgi_env, CONST_STR_LEN("HTTPS"), CONST_STR_LEN("on"));
 	}
 #endif
 
 	scgi_env_add_request_headers(srv, con, p);
 
-	b = chunkqueue_get_append_buffer(hctx->wb);
+	b = buffer_init();
 
-	buffer_append_long(b, p->scgi_env->used);
+	buffer_append_int(b, buffer_string_length(p->scgi_env));
 	buffer_append_string_len(b, CONST_STR_LEN(":"));
-	buffer_append_string_len(b, (const char *)p->scgi_env->ptr, p->scgi_env->used);
+	buffer_append_string_buffer(b, p->scgi_env);
 	buffer_append_string_len(b, CONST_STR_LEN(","));
 
-	hctx->wb->bytes_in += b->used - 1;
+	hctx->wb->bytes_in += buffer_string_length(b);
+	chunkqueue_append_buffer(hctx->wb, b);
+	buffer_free(b);
 
 	if (con->request.content_length) {
 		chunkqueue *req_cq = con->request_content_queue;
-		chunk *req_c;
-		off_t offset;
-
-		/* something to send ? */
-		for (offset = 0, req_c = req_cq->first; offset != req_cq->bytes_in; req_c = req_c->next) {
-			off_t weWant = req_cq->bytes_in - offset;
-			off_t weHave = 0;
-
-			/* we announce toWrite octects
-			 * now take all the request_content chunk that we need to fill this request
-			 * */
-
-			switch (req_c->type) {
-			case FILE_CHUNK:
-				weHave = req_c->file.length - req_c->offset;
-
-				if (weHave > weWant) weHave = weWant;
-
-				chunkqueue_append_file(hctx->wb, req_c->file.name, req_c->offset, weHave);
-
-				req_c->offset += weHave;
-				req_cq->bytes_out += weHave;
-
-				hctx->wb->bytes_in += weHave;
-
-				break;
-			case MEM_CHUNK:
-				/* append to the buffer */
-				weHave = req_c->mem->used - 1 - req_c->offset;
-
-				if (weHave > weWant) weHave = weWant;
-
-				b = chunkqueue_get_append_buffer(hctx->wb);
-				buffer_append_memory(b, req_c->mem->ptr + req_c->offset, weHave);
-				b->used++; /* add virtual \0 */
-
-				req_c->offset += weHave;
-				req_cq->bytes_out += weHave;
-
-				hctx->wb->bytes_in += weHave;
-
-				break;
-			default:
-				break;
-			}
 
-			offset += weHave;
-		}
+		chunkqueue_steal(hctx->wb, req_cq, req_cq->bytes_in);
 	}
 
 	return 0;
@@ -1692,7 +1631,7 @@
 
 	UNUSED(srv);
 
-	buffer_copy_string_buffer(p->parse_response, in);
+	buffer_copy_buffer(p->parse_response, in);
 
 	for (s = p->parse_response->ptr;
 	     NULL != (ns = (eol == EOL_RN ? strstr(s, "\r\n") : strchr(s, '\n')));
@@ -1795,7 +1734,7 @@
 	while(1) {
 		int n;
 
-		buffer_prepare_copy(hctx->response, 1024);
+		buffer_string_prepare_copy(hctx->response, 1023);
 		if (-1 == (n = read(hctx->fd, hctx->response->ptr, hctx->response->size - 1))) {
 			if (errno == EAGAIN || errno == EINTR) {
 				/* would block, wait for signal */
@@ -1812,14 +1751,13 @@
 			con->file_finished = 1;
 
 			/* send final chunk */
-			http_chunk_append_mem(srv, con, NULL, 0);
+			http_chunk_close(srv, con);
 			joblist_append(srv, con);
 
 			return 1;
 		}
 
-		hctx->response->ptr[n] = '\0';
-		hctx->response->used = n+1;
+		buffer_commit(hctx->response, n);
 
 		/* split header from body */
 
@@ -1837,7 +1775,7 @@
 			if (0 == strncmp(hctx->response_header->ptr, "HTTP/1.", 7)) in_header = 1;
 
 			/* search for the \r\n\r\n or \n\n in the string */
-			for (c = hctx->response_header->ptr, cp = 0, used = hctx->response_header->used - 1; used; c++, cp++, used--) {
+			for (c = hctx->response_header->ptr, cp = 0, used = buffer_string_length(hctx->response_header); used; c++, cp++, used--) {
 				if (*c == ':') in_header = 1;
 				else if (*c == '\n') {
 					if (in_header == 0) {
@@ -1890,14 +1828,13 @@
 						con->response.transfer_encoding = HTTP_TRANSFER_ENCODING_CHUNKED;
 					}
 
-					http_chunk_append_mem(srv, con, hctx->response_header->ptr, hctx->response_header->used);
+					http_chunk_append_buffer(srv, con, hctx->response_header);
 					joblist_append(srv, con);
 				} else {
-					size_t blen = hctx->response_header->used - hlen - 1;
+					size_t blen = buffer_string_length(hctx->response_header) - hlen;
 
 					/* a small hack: terminate after at the second \r */
-					hctx->response_header->used = hlen;
-					hctx->response_header->ptr[hlen - 1] = '\0';
+					buffer_string_set_length(hctx->response_header, hlen - 1);
 
 					/* parse the response header */
 					scgi_response_parse(srv, con, p, hctx->response_header, eol);
@@ -1908,8 +1845,8 @@
 						con->response.transfer_encoding = HTTP_TRANSFER_ENCODING_CHUNKED;
 					}
 
-					if ((hctx->response->used != hlen) && blen > 0) {
-						http_chunk_append_mem(srv, con, hctx->response_header->ptr + hlen, blen + 1);
+					if (blen > 0) {
+						http_chunk_append_mem(srv, con, hctx->response_header->ptr + hlen, blen);
 						joblist_append(srv, con);
 					}
 				}
@@ -1917,7 +1854,7 @@
 				con->file_started = 1;
 			}
 		} else {
-			http_chunk_append_mem(srv, con, hctx->response->ptr, hctx->response->used);
+			http_chunk_append_buffer(srv, con, hctx->response);
 			joblist_append(srv, con);
 		}
 
@@ -2171,20 +2108,20 @@
 		log_error_write(srv, __FILE__, __LINE__, "s", "fatal error: host = NULL");
 		return HANDLER_ERROR;
 	}
-	if (((!host->host->used || !host->port) && !host->unixsocket->used)) {
+	if (((buffer_string_is_empty(host->host) || !host->port) && buffer_string_is_empty(host->unixsocket))) {
 		log_error_write(srv, __FILE__, __LINE__, "sxddd",
 				"write-req: error",
 				host,
-				host->host->used,
+				buffer_string_length(host->host),
 				host->port,
-				host->unixsocket->used);
+				buffer_string_length(host->unixsocket));
 		return HANDLER_ERROR;
 	}
 
 
 	switch(hctx->state) {
 	case FCGI_STATE_INIT:
-		ret = host->unixsocket->used ? AF_UNIX : AF_INET;
+		ret = buffer_string_is_empty(host->unixsocket) ? AF_INET : AF_UNIX;
 
 		if (-1 == (hctx->fd = socket(ret, SOCK_STREAM, 0))) {
 			if (errno == EMFILE ||
@@ -2712,9 +2649,9 @@
 
 	fn = uri_path_handler ? con->uri.path : con->physical.path;
 
-	if (buffer_is_empty(fn)) return HANDLER_GO_ON;
+	if (buffer_string_is_empty(fn)) return HANDLER_GO_ON;
 
-	s_len = fn->used - 1;
+	s_len = buffer_string_length(fn);
 
 	scgi_patch_connection(srv, con, p);
 
@@ -2723,9 +2660,9 @@
 		size_t ct_len;
 		scgi_extension *ext = p->conf.exts->exts[k];
 
-		if (ext->key->used == 0) continue;
+		if (buffer_is_empty(ext->key)) continue;
 
-		ct_len = ext->key->used - 1;
+		ct_len = buffer_string_length(ext->key);
 
 		if (s_len < ct_len) continue;
 
@@ -2813,7 +2750,7 @@
 
 			if (con->conf.log_request_handling) {
 				log_error_write(srv, __FILE__, __LINE__, "s",
-				"handling it in mod_fastcgi");
+				"handling it in mod_scgi");
 			}
 
 			/* the prefix is the SCRIPT_NAME,
@@ -2839,17 +2776,14 @@
 			/* the rewrite is only done for /prefix/? matches */
 			if (host->fix_root_path_name && extension->key->ptr[0] == '/' && extension->key->ptr[1] == '\0') {
 				buffer_copy_string(con->request.pathinfo, con->uri.path->ptr);
-				con->uri.path->used = 1;
-				con->uri.path->ptr[con->uri.path->used - 1] = '\0';
+				buffer_string_set_length(con->uri.path, 0);
 			} else if (extension->key->ptr[0] == '/' &&
-			    con->uri.path->used > extension->key->used &&
-			    NULL != (pathinfo = strchr(con->uri.path->ptr + extension->key->used - 1, '/'))) {
+			    buffer_string_length(con->uri.path) > buffer_string_length(extension->key) &&
+			    NULL != (pathinfo = strchr(con->uri.path->ptr + buffer_string_length(extension->key), '/'))) {
 				/* rewrite uri.path and pathinfo */
 
 				buffer_copy_string(con->request.pathinfo, pathinfo);
-
-				con->uri.path->used -= con->request.pathinfo->used - 1;
-				con->uri.path->ptr[con->uri.path->used - 1] = '\0';
+				buffer_string_set_length(con->uri.path, buffer_string_length(con->uri.path) - buffer_string_length(con->request.pathinfo));
 			}
 		}
 	} else {
@@ -2871,7 +2805,7 @@
 		con->mode = p->id;
 
 		if (con->conf.log_request_handling) {
-			log_error_write(srv, __FILE__, __LINE__, "s", "handling it in mod_fastcgi");
+			log_error_write(srv, __FILE__, __LINE__, "s", "handling it in mod_scgi");
 		}
 	}
 
@@ -2992,17 +2926,18 @@
 
 					host->num_procs++;
 
-					if (buffer_is_empty(host->unixsocket)) {
+					if (buffer_string_is_empty(host->unixsocket)) {
 						fp->port = host->port + fp->id;
 					} else {
-						buffer_copy_string_buffer(fp->socket, host->unixsocket);
+						buffer_copy_buffer(fp->socket, host->unixsocket);
 						buffer_append_string_len(fp->socket, CONST_STR_LEN("-"));
-						buffer_append_long(fp->socket, fp->id);
+						buffer_append_int(fp->socket, fp->id);
 					}
 
 					if (scgi_spawn_connection(srv, p, host, fp)) {
 						log_error_write(srv, __FILE__, __LINE__, "s",
 								"ERROR: spawning fcgi failed.");
+						scgi_process_free(fp);
 						return HANDLER_ERROR;
 					}
 
diff -u lighttpd-1.4.32/src/mod_secure_download.c lighttpd-1.4.36/src/mod_secure_download.c
--- lighttpd-1.4.32/src/mod_secure_download.c	2011-07-30 04:13:39.000000000 -0500
+++ lighttpd-1.4.36/src/mod_secure_download.c	2015-07-26 05:36:36.000000000 -0500
@@ -65,6 +65,8 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
+			if (NULL == s) continue;
+
 			buffer_free(s->secret);
 			buffer_free(s->doc_root);
 			buffer_free(s->uri_prefix);
@@ -97,7 +99,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -198,19 +200,19 @@
 
 	if (con->mode != DIRECT) return HANDLER_GO_ON;
 
-	if (con->uri.path->used == 0) return HANDLER_GO_ON;
+	if (buffer_is_empty(con->uri.path)) return HANDLER_GO_ON;
 
 	mod_secdownload_patch_connection(srv, con, p);
 
 	if (buffer_is_empty(p->conf.uri_prefix)) return HANDLER_GO_ON;
 
-	if (buffer_is_empty(p->conf.secret)) {
+	if (buffer_string_is_empty(p->conf.secret)) {
 		log_error_write(srv, __FILE__, __LINE__, "s",
 				"secdownload.secret has to be set");
 		return HANDLER_ERROR;
 	}
 
-	if (buffer_is_empty(p->conf.doc_root)) {
+	if (buffer_string_is_empty(p->conf.doc_root)) {
 		log_error_write(srv, __FILE__, __LINE__, "s",
 				"secdownload.document-root has to be set");
 		return HANDLER_ERROR;
@@ -220,9 +222,9 @@
 	 *  /<uri-prefix>[a-f0-9]{32}/[a-f0-9]{8}/<rel-path>
 	 */
 
-	if (0 != strncmp(con->uri.path->ptr, p->conf.uri_prefix->ptr, p->conf.uri_prefix->used - 1)) return HANDLER_GO_ON;
+	if (0 != strncmp(con->uri.path->ptr, p->conf.uri_prefix->ptr, buffer_string_length(p->conf.uri_prefix))) return HANDLER_GO_ON;
 
-	md5_str = con->uri.path->ptr + p->conf.uri_prefix->used - 1;
+	md5_str = con->uri.path->ptr + buffer_string_length(p->conf.uri_prefix);
 
 	if (!is_hex_len(md5_str, 32)) return HANDLER_GO_ON;
 	if (*(md5_str + 32) != '/') return HANDLER_GO_ON;
@@ -233,7 +235,7 @@
 	if (*(ts_str + 8) != '/') return HANDLER_GO_ON;
 
 	for (i = 0; i < 8; i++) {
-		ts = (ts << 4) + hex2int(*(ts_str + i));
+		ts = (ts << 4) + hex2int(ts_str[i]);
 	}
 
 	/* timed-out */
@@ -252,12 +254,12 @@
 	 * <secret><rel-path><timestamp-hex>
 	 */
 
-	buffer_copy_string_buffer(p->md5, p->conf.secret);
+	buffer_copy_buffer(p->md5, p->conf.secret);
 	buffer_append_string(p->md5, rel_uri);
 	buffer_append_string_len(p->md5, ts_str, 8);
 
 	li_MD5_Init(&Md5Ctx);
-	li_MD5_Update(&Md5Ctx, (unsigned char *)p->md5->ptr, p->md5->used - 1);
+	li_MD5_Update(&Md5Ctx, CONST_BUF_LEN(p->md5));
 	li_MD5_Final(HA1, &Md5Ctx);
 
 	buffer_copy_string_hex(p->md5, (char *)HA1, 16);
@@ -275,9 +277,10 @@
 	/* starting with the last / we should have relative-path to the docroot
 	 */
 
-	buffer_copy_string_buffer(con->physical.doc_root, p->conf.doc_root);
+	buffer_copy_buffer(con->physical.doc_root, p->conf.doc_root);
+	buffer_copy_buffer(con->physical.basedir, p->conf.doc_root);
 	buffer_copy_string(con->physical.rel_path, rel_uri);
-	buffer_copy_string_buffer(con->physical.path, con->physical.doc_root);
+	buffer_copy_buffer(con->physical.path, con->physical.doc_root);
 	buffer_append_string_buffer(con->physical.path, con->physical.rel_path);
 
 	return HANDLER_GO_ON;
diff -u lighttpd-1.4.32/src/mod_setenv.c lighttpd-1.4.36/src/mod_setenv.c
--- lighttpd-1.4.32/src/mod_setenv.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.36/src/mod_setenv.c	2015-07-26 05:36:36.000000000 -0500
@@ -67,6 +67,8 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
+			if (NULL == s) continue;
+
 			array_free(s->request_header);
 			array_free(s->response_header);
 			array_free(s->environment);
@@ -96,7 +98,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -185,8 +187,8 @@
 			ds_dst = data_string_init();
 		}
 
-		buffer_copy_string_buffer(ds_dst->key, ds->key);
-		buffer_copy_string_buffer(ds_dst->value, ds->value);
+		buffer_copy_buffer(ds_dst->key, ds->key);
+		buffer_copy_buffer(ds_dst->value, ds->value);
 
 		array_insert_unique(con->request.headers, (data_unset *)ds_dst);
 	}
@@ -199,8 +201,8 @@
 			ds_dst = data_string_init();
 		}
 
-		buffer_copy_string_buffer(ds_dst->key, ds->key);
-		buffer_copy_string_buffer(ds_dst->value, ds->value);
+		buffer_copy_buffer(ds_dst->key, ds->key);
+		buffer_copy_buffer(ds_dst->value, ds->value);
 
 		array_insert_unique(con->environment, (data_unset *)ds_dst);
 	}
diff -u lighttpd-1.4.32/src/mod_simple_vhost.c lighttpd-1.4.36/src/mod_simple_vhost.c
--- lighttpd-1.4.32/src/mod_simple_vhost.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/mod_simple_vhost.c	2015-07-26 05:36:36.000000000 -0500
@@ -5,6 +5,7 @@
 
 #include "plugin.h"
 
+#include <assert.h>
 #include <ctype.h>
 #include <stdlib.h>
 #include <string.h>
@@ -88,7 +89,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -123,37 +124,32 @@
 
 static int build_doc_root(server *srv, connection *con, plugin_data *p, buffer *out, buffer *host) {
 	stat_cache_entry *sce = NULL;
+	force_assert(!buffer_string_is_empty(p->conf.server_root));
 
-	buffer_prepare_copy(out, 128);
+	buffer_string_prepare_copy(out, 127);
+	buffer_copy_buffer(out, p->conf.server_root);
 
-	if (p->conf.server_root->used) {
-		buffer_copy_string_buffer(out, p->conf.server_root);
+	if (!buffer_string_is_empty(host)) {
+		/* a hostname has to start with a alpha-numerical character
+		 * and must not contain a slash "/"
+		 */
+		char *dp;
 
-		if (host->used) {
-			/* a hostname has to start with a alpha-numerical character
-			 * and must not contain a slash "/"
-			 */
-			char *dp;
-
-			BUFFER_APPEND_SLASH(out);
-
-			if (NULL == (dp = strchr(host->ptr, ':'))) {
-				buffer_append_string_buffer(out, host);
-			} else {
-				buffer_append_string_len(out, host->ptr, dp - host->ptr);
-			}
-		}
-		BUFFER_APPEND_SLASH(out);
+		buffer_append_slash(out);
 
-		if (p->conf.document_root->used > 2 && p->conf.document_root->ptr[0] == '/') {
-			buffer_append_string_len(out, p->conf.document_root->ptr + 1, p->conf.document_root->used - 2);
+		if (NULL == (dp = strchr(host->ptr, ':'))) {
+			buffer_append_string_buffer(out, host);
 		} else {
-			buffer_append_string_buffer(out, p->conf.document_root);
-			BUFFER_APPEND_SLASH(out);
+			buffer_append_string_len(out, host->ptr, dp - host->ptr);
 		}
+	}
+	buffer_append_slash(out);
+
+	if (buffer_string_length(p->conf.document_root) > 1 && p->conf.document_root->ptr[0] == '/') {
+		buffer_append_string_len(out, p->conf.document_root->ptr + 1, buffer_string_length(p->conf.document_root) - 1);
 	} else {
-		buffer_copy_string_buffer(out, con->conf.document_root);
-		BUFFER_APPEND_SLASH(out);
+		buffer_append_string_buffer(out, p->conf.document_root);
+		buffer_append_slash(out);
 	}
 
 	if (HANDLER_ERROR == stat_cache_get_entry(srv, con, out, &sce)) {
@@ -228,38 +224,41 @@
 
 	mod_simple_vhost_patch_connection(srv, con, p);
 
-	if (p->conf.docroot_cache_key->used &&
-	    con->uri.authority->used &&
+	/* build_doc_root() requires a server_root; skip module if simple-vhost.server-root is not set
+	 * or set to an empty string (especially don't cache any results!)
+	 */
+	if (buffer_string_is_empty(p->conf.server_root)) return HANDLER_GO_ON;
+
+	if (!buffer_string_is_empty(p->conf.docroot_cache_key) &&
+	    !buffer_string_is_empty(con->uri.authority) &&
 	    buffer_is_equal(p->conf.docroot_cache_key, con->uri.authority)) {
 		/* cache hit */
-		buffer_copy_string_buffer(con->physical.doc_root, p->conf.docroot_cache_value);
-		buffer_copy_string_buffer(con->server_name,       p->conf.docroot_cache_servername);
+		buffer_copy_buffer(con->server_name,       p->conf.docroot_cache_servername);
+		buffer_copy_buffer(con->physical.doc_root, p->conf.docroot_cache_value);
 	} else {
 		/* build document-root */
-		if ((con->uri.authority->used == 0) ||
+		if (buffer_string_is_empty(con->uri.authority) ||
 		    build_doc_root(srv, con, p, p->doc_root, con->uri.authority)) {
 			/* not found, fallback the default-host */
-			if (build_doc_root(srv, con, p,
+			if (0 == build_doc_root(srv, con, p,
 					   p->doc_root,
 					   p->conf.default_host)) {
-				return HANDLER_GO_ON;
-			} else {
-				buffer_copy_string_buffer(con->server_name, p->conf.default_host);
-				buffer_copy_string_buffer(con->physical.doc_root, p->doc_root);
-
+				/* default host worked */
+				buffer_copy_buffer(con->server_name, p->conf.default_host);
+				buffer_copy_buffer(con->physical.doc_root, p->doc_root);
 				/* do not cache default host */
-				return HANDLER_GO_ON;
 			}
-		} else {
-			buffer_copy_string_buffer(con->server_name, con->uri.authority);
+			return HANDLER_GO_ON;
 		}
 
-		/* copy to cache */
-		buffer_copy_string_buffer(p->conf.docroot_cache_key,        con->uri.authority);
-		buffer_copy_string_buffer(p->conf.docroot_cache_value,      p->doc_root);
-		buffer_copy_string_buffer(p->conf.docroot_cache_servername, con->server_name);
+		/* found host */
+		buffer_copy_buffer(con->server_name, con->uri.authority);
+		buffer_copy_buffer(con->physical.doc_root, p->doc_root);
 
-		buffer_copy_string_buffer(con->physical.doc_root, p->doc_root);
+		/* copy to cache */
+		buffer_copy_buffer(p->conf.docroot_cache_key,        con->uri.authority);
+		buffer_copy_buffer(p->conf.docroot_cache_value,      p->doc_root);
+		buffer_copy_buffer(p->conf.docroot_cache_servername, con->server_name);
 	}
 
 	return HANDLER_GO_ON;
diff -u lighttpd-1.4.32/src/mod_skeleton.c lighttpd-1.4.36/src/mod_skeleton.c
--- lighttpd-1.4.32/src/mod_skeleton.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/mod_skeleton.c	2015-07-26 05:36:36.000000000 -0500
@@ -65,7 +65,7 @@
 	return p;
 }
 
-/* detroy the plugin data */
+/* destroy the plugin data */
 FREE_FUNC(mod_skeleton_free) {
 	plugin_data *p = p_d;
 
@@ -79,7 +79,7 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
-			if (!s) continue;
+			if (NULL == s) continue;
 
 			array_free(s->match);
 
@@ -108,7 +108,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
diff -u lighttpd-1.4.32/src/mod_ssi.c lighttpd-1.4.36/src/mod_ssi.c
--- lighttpd-1.4.32/src/mod_ssi.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/mod_ssi.c	2015-07-26 05:36:36.000000000 -0500
@@ -69,6 +69,8 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
+			if (NULL == s) continue;
+
 			array_free(s->ssi_extension);
 			buffer_free(s->content_type);
 
@@ -108,7 +110,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -172,33 +174,13 @@
 
 		ds = (data_string *)con->request.headers->data[i];
 
-		if (ds->value->used && ds->key->used) {
-			size_t j;
-			buffer_reset(srv->tmp_buf);
-
+		if (!buffer_is_empty(ds->value) && !buffer_is_empty(ds->key)) {
 			/* don't forward the Authorization: Header */
 			if (0 == strcasecmp(ds->key->ptr, "AUTHORIZATION")) {
 				continue;
 			}
 
-			if (0 != strcasecmp(ds->key->ptr, "CONTENT-TYPE")) {
-				buffer_copy_string_len(srv->tmp_buf, CONST_STR_LEN("HTTP_"));
-				srv->tmp_buf->used--;
-			}
-
-			buffer_prepare_append(srv->tmp_buf, ds->key->used + 2);
-			for (j = 0; j < ds->key->used - 1; j++) {
-				char c = '_';
-				if (light_isalpha(ds->key->ptr[j])) {
-					/* upper-case */
-					c = ds->key->ptr[j] & ~32;
-				} else if (light_isdigit(ds->key->ptr[j])) {
-					/* copy */
-					c = ds->key->ptr[j];
-				}
-				srv->tmp_buf->ptr[srv->tmp_buf->used++] = c;
-			}
-			srv->tmp_buf->ptr[srv->tmp_buf->used] = '\0';
+			buffer_copy_string_encoded_cgi_varnames(srv->tmp_buf, CONST_BUF_LEN(ds->key), 1);
 
 			ssi_env_add(p->ssi_cgi_env, srv->tmp_buf->ptr, ds->value->ptr);
 		}
@@ -209,24 +191,8 @@
 
 		ds = (data_string *)con->environment->data[i];
 
-		if (ds->value->used && ds->key->used) {
-			size_t j;
-
-			buffer_reset(srv->tmp_buf);
-			buffer_prepare_append(srv->tmp_buf, ds->key->used + 2);
-
-			for (j = 0; j < ds->key->used - 1; j++) {
-				char c = '_';
-				if (light_isalpha(ds->key->ptr[j])) {
-					/* upper-case */
-					c = ds->key->ptr[j] & ~32;
-				} else if (light_isdigit(ds->key->ptr[j])) {
-					/* copy */
-					c = ds->key->ptr[j];
-				}
-				srv->tmp_buf->ptr[srv->tmp_buf->used++] = c;
-			}
-			srv->tmp_buf->ptr[srv->tmp_buf->used] = '\0';
+		if (!buffer_is_empty(ds->value) && !buffer_is_empty(ds->key)) {
+			buffer_copy_string_encoded_cgi_varnames(srv->tmp_buf, CONST_BUF_LEN(ds->key), 0);
 
 			ssi_env_add(p->ssi_cgi_env, srv->tmp_buf->ptr, ds->value->ptr);
 		}
@@ -236,7 +202,7 @@
 }
 
 static int build_ssi_cgi_vars(server *srv, connection *con, plugin_data *p) {
-	char buf[32];
+	char buf[LI_ITOSTRING_LENGTH];
 
 	server_socket *srv_sock = con->srv_socket;
 
@@ -263,7 +229,7 @@
 		     );
 	ssi_env_add(p->ssi_cgi_env, CONST_STRING("GATEWAY_INTERFACE"), "CGI/1.1");
 
-	LI_ltostr(buf,
+	li_utostr(buf,
 #ifdef HAVE_IPV6
 	       ntohs(srv_sock->addr.plain.sa_family ? srv_sock->addr.ipv6.sin6_port : srv_sock->addr.ipv4.sin_port)
 #else
@@ -276,16 +242,10 @@
 	ssi_env_add(p->ssi_cgi_env, CONST_STRING("REMOTE_ADDR"),
 		    inet_ntop_cache_get_ip(srv, &(con->dst_addr)));
 
-	if (con->authed_user->used) {
-		ssi_env_add(p->ssi_cgi_env, CONST_STRING("REMOTE_USER"),
-			     con->authed_user->ptr);
-	}
-
 	if (con->request.content_length > 0) {
 		/* CGI-SPEC 6.1.2 and FastCGI spec 6.3 */
 
-		/* request.content_length < SSIZE_MAX, see request.c */
-		LI_ltostr(buf, con->request.content_length);
+		li_itostr(buf, con->request.content_length);
 		ssi_env_add(p->ssi_cgi_env, CONST_STRING("CONTENT_LENGTH"), buf);
 	}
 
@@ -306,7 +266,7 @@
 	 * parameter.
 	 */
 
-	if (con->request.pathinfo->used) {
+	if (!buffer_string_is_empty(con->request.pathinfo)) {
 		ssi_env_add(p->ssi_cgi_env, CONST_STRING("PATH_INFO"), con->request.pathinfo->ptr);
 	}
 
@@ -314,7 +274,7 @@
 	ssi_env_add(p->ssi_cgi_env, CONST_STRING("DOCUMENT_ROOT"), con->physical.doc_root->ptr);
 
 	ssi_env_add(p->ssi_cgi_env, CONST_STRING("REQUEST_URI"), con->request.uri->ptr);
-	ssi_env_add(p->ssi_cgi_env, CONST_STRING("QUERY_STRING"), con->uri.query->used ? con->uri.query->ptr : "");
+	ssi_env_add(p->ssi_cgi_env, CONST_STRING("QUERY_STRING"), buffer_is_empty(con->uri.query) ? "" : con->uri.query->ptr);
 	ssi_env_add(p->ssi_cgi_env, CONST_STRING("REQUEST_METHOD"), get_http_method_name(con->request.http_method));
 	ssi_env_add(p->ssi_cgi_env, CONST_STRING("REDIRECT_STATUS"), "200");
 	ssi_env_add(p->ssi_cgi_env, CONST_STRING("SERVER_PROTOCOL"), get_http_version_name(con->request.http_version));
@@ -324,8 +284,7 @@
 	return 0;
 }
 
-static int process_ssi_stmt(server *srv, connection *con, plugin_data *p,
-			    const char **l, size_t n) {
+static int process_ssi_stmt(server *srv, connection *con, plugin_data *p, const char **l, size_t n, stat_cache_entry *sce) {
 	size_t i, ssicmd = 0;
 	char buf[255];
 	buffer *b = NULL;
@@ -365,7 +324,6 @@
 		int var = 0;
 		/* int enc = 0; */
 		const char *var_val = NULL;
-		stat_cache_entry *sce = NULL;
 
 		struct {
 			const char *var;
@@ -434,83 +392,76 @@
 			break;
 		}
 
-		stat_cache_get_entry(srv, con, con->physical.path, &sce);
-
 		switch(var) {
 		case SSI_ECHO_USER_NAME: {
 			struct passwd *pw;
 
-			b = chunkqueue_get_append_buffer(con->write_queue);
+			b = buffer_init();
 #ifdef HAVE_PWD_H
 			if (NULL == (pw = getpwuid(sce->st.st_uid))) {
-				buffer_copy_long(b, sce->st.st_uid);
+				buffer_copy_int(b, sce->st.st_uid);
 			} else {
 				buffer_copy_string(b, pw->pw_name);
 			}
 #else
-			buffer_copy_long(b, sce->st.st_uid);
+			buffer_copy_int(b, sce->st.st_uid);
 #endif
+			chunkqueue_append_buffer(con->write_queue, b);
+			buffer_free(b);
 			break;
 		}
 		case SSI_ECHO_LAST_MODIFIED:	{
 			time_t t = sce->st.st_mtime;
 
-			b = chunkqueue_get_append_buffer(con->write_queue);
 			if (0 == strftime(buf, sizeof(buf), p->timefmt->ptr, localtime(&t))) {
-				buffer_copy_string_len(b, CONST_STR_LEN("(none)"));
+				chunkqueue_append_mem(con->write_queue, CONST_STR_LEN("(none)"));
 			} else {
-				buffer_copy_string(b, buf);
+				chunkqueue_append_mem(con->write_queue, buf, strlen(buf));
 			}
 			break;
 		}
 		case SSI_ECHO_DATE_LOCAL: {
 			time_t t = time(NULL);
 
-			b = chunkqueue_get_append_buffer(con->write_queue);
 			if (0 == strftime(buf, sizeof(buf), p->timefmt->ptr, localtime(&t))) {
-				buffer_copy_string_len(b, CONST_STR_LEN("(none)"));
+				chunkqueue_append_mem(con->write_queue, CONST_STR_LEN("(none)"));
 			} else {
-				buffer_copy_string(b, buf);
+				chunkqueue_append_mem(con->write_queue, buf, strlen(buf));
 			}
 			break;
 		}
 		case SSI_ECHO_DATE_GMT: {
 			time_t t = time(NULL);
 
-			b = chunkqueue_get_append_buffer(con->write_queue);
 			if (0 == strftime(buf, sizeof(buf), p->timefmt->ptr, gmtime(&t))) {
-				buffer_copy_string_len(b, CONST_STR_LEN("(none)"));
+				chunkqueue_append_mem(con->write_queue, CONST_STR_LEN("(none)"));
 			} else {
-				buffer_copy_string(b, buf);
+				chunkqueue_append_mem(con->write_queue, buf, strlen(buf));
 			}
 			break;
 		}
 		case SSI_ECHO_DOCUMENT_NAME: {
 			char *sl;
 
-			b = chunkqueue_get_append_buffer(con->write_queue);
 			if (NULL == (sl = strrchr(con->physical.path->ptr, '/'))) {
-				buffer_copy_string_buffer(b, con->physical.path);
+				chunkqueue_append_mem(con->write_queue, CONST_BUF_LEN(con->physical.path));
 			} else {
-				buffer_copy_string(b, sl + 1);
+				chunkqueue_append_mem(con->write_queue, sl + 1, strlen(sl + 1));
 			}
 			break;
 		}
 		case SSI_ECHO_DOCUMENT_URI: {
-			b = chunkqueue_get_append_buffer(con->write_queue);
-			buffer_copy_string_buffer(b, con->uri.path);
+			chunkqueue_append_mem(con->write_queue, CONST_BUF_LEN(con->uri.path));
 			break;
 		}
 		default: {
 			data_string *ds;
 			/* check if it is a cgi-var */
 
-			b = chunkqueue_get_append_buffer(con->write_queue);
-
 			if (NULL != (ds = (data_string *)array_get_element(p->ssi_cgi_env, var_val))) {
-				buffer_copy_string_buffer(b, ds->value);
+				chunkqueue_append_mem(con->write_queue, CONST_BUF_LEN(ds->value));
 			} else {
-				buffer_copy_string_len(b, CONST_STR_LEN("(none)"));
+				chunkqueue_append_mem(con->write_queue, CONST_STR_LEN("(none)"));
 			}
 
 			break;
@@ -584,7 +535,7 @@
 
 			/* we have an uri */
 
-			buffer_copy_string_buffer(p->stat_fn, con->physical.doc_root);
+			buffer_copy_buffer(p->stat_fn, con->physical.doc_root);
 			buffer_append_string_buffer(p->stat_fn, srv->tmp_buf);
 		}
 
@@ -593,7 +544,7 @@
 
 			switch (ssicmd) {
 			case SSI_FSIZE:
-				b = chunkqueue_get_append_buffer(con->write_queue);
+				b = buffer_init();
 				if (p->sizefmt) {
 					int j = 0;
 					const char *abr[] = { " B", " kB", " MB", " GB", " TB", NULL };
@@ -602,18 +553,19 @@
 
 					for (j = 0; s > 1024 && abr[j+1]; s /= 1024, j++);
 
-					buffer_copy_off_t(b, s);
+					buffer_copy_int(b, s);
 					buffer_append_string(b, abr[j]);
 				} else {
-					buffer_copy_off_t(b, st.st_size);
+					buffer_copy_int(b, st.st_size);
 				}
+				chunkqueue_append_buffer(con->write_queue, b);
+				buffer_free(b);
 				break;
 			case SSI_FLASTMOD:
-				b = chunkqueue_get_append_buffer(con->write_queue);
 				if (0 == strftime(buf, sizeof(buf), p->timefmt->ptr, localtime(&t))) {
-					buffer_copy_string_len(b, CONST_STR_LEN("(none)"));
+					chunkqueue_append_mem(con->write_queue, CONST_STR_LEN("(none)"));
 				} else {
-					buffer_copy_string(b, buf);
+					chunkqueue_append_mem(con->write_queue, buf, strlen(buf));
 				}
 				break;
 			case SSI_INCLUDE:
@@ -621,7 +573,7 @@
 
 				/* Keep the newest mtime of included files */
 				if (st.st_mtime > include_file_last_mtime)
-				  include_file_last_mtime = st.st_mtime;
+					include_file_last_mtime = st.st_mtime;
 
 				break;
 			}
@@ -693,7 +645,7 @@
 	case SSI_PRINTENV:
 		if (p->if_is_false) break;
 
-		b = chunkqueue_get_append_buffer(con->write_queue);
+		b = buffer_init();
 		for (i = 0; i < p->ssi_vars->used; i++) {
 			data_string *ds = (data_string *)p->ssi_vars->data[p->ssi_vars->sorted[i]];
 
@@ -710,6 +662,8 @@
 			buffer_append_string_encoded(b, CONST_BUF_LEN(ds->value), ENCODING_MINIMAL_XML);
 			buffer_append_string_len(b, CONST_STR_LEN("\n"));
 		}
+		chunkqueue_append_buffer(con->write_queue, b);
+		buffer_free(b);
 
 		break;
 	case SSI_EXEC: {
@@ -792,26 +746,23 @@
 					int toread;
 					/* read everything from client and paste it into the output */
 					was_interrupted = 0;
-	
+
 					while(1) {
 						if (ioctl(from_exec_fds[0], FIONREAD, &toread)) {
 							log_error_write(srv, __FILE__, __LINE__, "s",
 								"unexpected end-of-file (perhaps the ssi-exec process died)");
 							return -1;
 						}
-	
+
 						if (toread > 0) {
-							b = chunkqueue_get_append_buffer(con->write_queue);
-	
-							buffer_prepare_copy(b, toread + 1);
-	
-							if ((r = read(from_exec_fds[0], b->ptr, b->size - 1)) < 0) {
-								/* read failed */
-								break;
-							} else {
-								b->used = r;
-								b->ptr[b->used++] = '\0';
-							}
+							char *mem;
+							size_t mem_len;
+
+							chunkqueue_get_memory(con->write_queue, &mem, &mem_len, 0, toread);
+							r = read(from_exec_fds[0], mem, mem_len);
+							chunkqueue_use_memory(con->write_queue, r > 0 ? r : 0);
+
+							if (r < 0) break; /* read failed */
 						} else {
 							break;
 						}
@@ -963,6 +914,9 @@
 	int ovec[N * 3];
 #endif
 
+	stat_cache_entry *sce = NULL;
+
+
 	/* get a stream to the file */
 
 	array_reset(p->ssi_vars);
@@ -975,6 +929,11 @@
 	/* Reset the modified time of included files */
 	include_file_last_mtime = 0;
 
+	if (HANDLER_ERROR == stat_cache_get_entry(srv, con, con->physical.path, &sce)) {
+		log_error_write(srv, __FILE__, __LINE__,  "SB", "stat_cache_get_entry failed: ", con->physical.path);
+		return -1;
+	}
+
 	if (-1 == stream_open(&s, con->physical.path)) {
 		log_error_write(srv, __FILE__, __LINE__, "sb",
 				"stream-open: ", con->physical.path);
@@ -1048,7 +1007,7 @@
 		if (!p->if_is_false) chunkqueue_append_file(con->write_queue, con->physical.path, i, ovec[0] - i);
 
 		pcre_get_substring_list(s.start, ovec, n, &l);
-		process_ssi_stmt(srv, con, p, l, n);
+		process_ssi_stmt(srv, con, p, l, n, sce);
 		pcre_free_substring_list(l);
 	}
 
@@ -1072,21 +1031,17 @@
 	con->file_finished = 1;
 	con->mode = p->id;
 
-	if (p->conf.content_type->used <= 1) {
+	if (buffer_string_is_empty(p->conf.content_type)) {
 		response_header_overwrite(srv, con, CONST_STR_LEN("Content-Type"), CONST_STR_LEN("text/html"));
 	} else {
 		response_header_overwrite(srv, con, CONST_STR_LEN("Content-Type"), CONST_BUF_LEN(p->conf.content_type));
 	}
 
 	{
-  	/* Generate "ETag" & "Last-Modified" headers */
-
-		stat_cache_entry *sce = NULL;
+		/* Generate "ETag" & "Last-Modified" headers */
 		time_t lm_time = 0;
 		buffer *mtime = NULL;
 
-		stat_cache_get_entry(srv, con, con->physical.path, &sce);
-
 		etag_mutate(con->physical.etag, sce->etag);
 		response_header_overwrite(srv, con, CONST_STR_LEN("ETag"), CONST_BUF_LEN(con->physical.etag));
 
@@ -1147,16 +1102,16 @@
 
 	if (con->mode != DIRECT) return HANDLER_GO_ON;
 
-	if (con->physical.path->used == 0) return HANDLER_GO_ON;
+	if (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;
 
 	mod_ssi_patch_connection(srv, con, p);
 
 	for (k = 0; k < p->conf.ssi_extension->used; k++) {
 		data_string *ds = (data_string *)p->conf.ssi_extension->data[k];
 
-		if (ds->value->used == 0) continue;
+		if (buffer_is_empty(ds->value)) continue;
 
-		if (buffer_is_equal_right_len(con->physical.path, ds->value, ds->value->used - 1)) {
+		if (buffer_is_equal_right_len(con->physical.path, ds->value, buffer_string_length(ds->value))) {
 			/* handle ssi-request */
 
 			if (mod_ssi_handle_request(srv, con, p)) {
diff -u lighttpd-1.4.32/src/mod_ssi_expr.c lighttpd-1.4.36/src/mod_ssi_expr.c
--- lighttpd-1.4.32/src/mod_ssi_expr.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.36/src/mod_ssi_expr.c	2015-07-26 05:36:36.000000000 -0500
@@ -35,7 +35,7 @@
 
 int ssi_val_tobool(ssi_val_t *B) {
 	if (B->type == SSI_TYPE_STRING) {
-		return B->str->used > 1 ? 1 : 0;
+		return !buffer_string_is_empty(B->str);
 	} else {
 		return B->bo;
 	}
@@ -215,9 +215,9 @@
 			tid = TK_VALUE;
 
 			if (NULL != (ds = (data_string *)array_get_element(p->ssi_cgi_env, token->ptr))) {
-				buffer_copy_string_buffer(token, ds->value);
+				buffer_copy_buffer(token, ds->value);
 			} else if (NULL != (ds = (data_string *)array_get_element(p->ssi_vars, token->ptr))) {
-				buffer_copy_string_buffer(token, ds->value);
+				buffer_copy_buffer(token, ds->value);
 			} else {
 				buffer_copy_string_len(token, CONST_STR_LEN(""));
 			}
diff -u lighttpd-1.4.32/src/mod_ssi_expr.h lighttpd-1.4.36/src/mod_ssi_expr.h
--- lighttpd-1.4.32/src/mod_ssi_expr.h	2011-06-13 06:17:01.000000000 -0500
+++ lighttpd-1.4.36/src/mod_ssi_expr.h	2015-07-26 05:36:36.000000000 -0500
@@ -25,7 +25,7 @@
 void ssiexprparser(void *yyp, int yymajor, buffer *yyminor, ssi_ctx_t *ctx);
 
 int ssi_val_tobool(ssi_val_t *B);
-ssi_val_t *ssi_val_init();
+ssi_val_t *ssi_val_init(void);
 void ssi_val_free(ssi_val_t *s);
 
 #endif
diff -u lighttpd-1.4.32/src/mod_staticfile.c lighttpd-1.4.36/src/mod_staticfile.c
--- lighttpd-1.4.32/src/mod_staticfile.c	2012-11-17 11:32:01.000000000 -0600
+++ lighttpd-1.4.36/src/mod_staticfile.c	2015-07-26 05:36:36.000000000 -0500
@@ -63,6 +63,8 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
+			if (NULL == s) continue;
+
 			array_free(s->exclude_ext);
 
 			free(s);
@@ -91,7 +93,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -285,20 +287,18 @@
 		if (!error) {
 			if (multipart) {
 				/* write boundary-header */
-				buffer *b;
-
-				b = chunkqueue_get_append_buffer(con->write_queue);
+				buffer *b = buffer_init();
 
 				buffer_copy_string_len(b, CONST_STR_LEN("\r\n--"));
 				buffer_append_string(b, boundary);
 
 				/* write Content-Range */
 				buffer_append_string_len(b, CONST_STR_LEN("\r\nContent-Range: bytes "));
-				buffer_append_off_t(b, start);
+				buffer_append_int(b, start);
 				buffer_append_string_len(b, CONST_STR_LEN("-"));
-				buffer_append_off_t(b, end);
+				buffer_append_int(b, end);
 				buffer_append_string_len(b, CONST_STR_LEN("/"));
-				buffer_append_off_t(b, sce->st.st_size);
+				buffer_append_int(b, sce->st.st_size);
 
 				buffer_append_string_len(b, CONST_STR_LEN("\r\nContent-Type: "));
 				buffer_append_string_buffer(b, content_type);
@@ -306,8 +306,9 @@
 				/* write END-OF-HEADER */
 				buffer_append_string_len(b, CONST_STR_LEN("\r\n\r\n"));
 
-				con->response.content_length += b->used - 1;
-
+				con->response.content_length += buffer_string_length(b);
+				chunkqueue_append_buffer(con->write_queue, b);
+				buffer_free(b);
 			}
 
 			chunkqueue_append_file(con->write_queue, con->physical.path, start, end - start + 1);
@@ -320,15 +321,15 @@
 
 	if (multipart) {
 		/* add boundary end */
-		buffer *b;
-
-		b = chunkqueue_get_append_buffer(con->write_queue);
+		buffer *b = buffer_init();
 
 		buffer_copy_string_len(b, "\r\n--", 4);
 		buffer_append_string(b, boundary);
 		buffer_append_string_len(b, "--\r\n", 4);
 
-		con->response.content_length += b->used - 1;
+		con->response.content_length += buffer_string_length(b);
+		chunkqueue_append_buffer(con->write_queue, b);
+		buffer_free(b);
 
 		/* set header-fields */
 
@@ -341,11 +342,11 @@
 		/* add Content-Range-header */
 
 		buffer_copy_string_len(p->range_buf, CONST_STR_LEN("bytes "));
-		buffer_append_off_t(p->range_buf, start);
+		buffer_append_int(p->range_buf, start);
 		buffer_append_string_len(p->range_buf, CONST_STR_LEN("-"));
-		buffer_append_off_t(p->range_buf, end);
+		buffer_append_int(p->range_buf, end);
 		buffer_append_string_len(p->range_buf, CONST_STR_LEN("/"));
-		buffer_append_off_t(p->range_buf, sce->st.st_size);
+		buffer_append_int(p->range_buf, sce->st.st_size);
 
 		response_header_insert(srv, con, CONST_STR_LEN("Content-Range"), CONST_BUF_LEN(p->range_buf));
 	}
@@ -364,8 +365,8 @@
 
 	/* someone else has done a decision for us */
 	if (con->http_status != 0) return HANDLER_GO_ON;
-	if (con->uri.path->used == 0) return HANDLER_GO_ON;
-	if (con->physical.path->used == 0) return HANDLER_GO_ON;
+	if (buffer_is_empty(con->uri.path)) return HANDLER_GO_ON;
+	if (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;
 
 	/* someone else has handled this request */
 	if (con->mode != DIRECT) return HANDLER_GO_ON;
@@ -382,7 +383,7 @@
 
 	mod_staticfile_patch_connection(srv, con, p);
 
-	if (p->conf.disable_pathinfo && 0 != con->request.pathinfo->used) {
+	if (p->conf.disable_pathinfo && !buffer_string_is_empty(con->request.pathinfo)) {
 		if (con->conf.log_request_handling) {
 			log_error_write(srv, __FILE__, __LINE__,  "s",  "-- NOT handling file as static file, pathinfo forbidden");
 		}
@@ -393,9 +394,9 @@
 	for (k = 0; k < p->conf.exclude_ext->used; k++) {
 		ds = (data_string *)p->conf.exclude_ext->data[k];
 
-		if (ds->value->used == 0) continue;
+		if (buffer_is_empty(ds->value)) continue;
 
-		if (buffer_is_equal_right_len(con->physical.path, ds->value, ds->value->used - 1)) {
+		if (buffer_is_equal_right_len(con->physical.path, ds->value, buffer_string_length(ds->value))) {
 			if (con->conf.log_request_handling) {
 				log_error_write(srv, __FILE__, __LINE__,  "s",  "-- NOT handling file as static file, extension forbidden");
 			}
@@ -449,7 +450,7 @@
 	/* set response content-type, if not set already */
 
 	if (NULL == array_get_element(con->response.headers, "Content-Type")) {
-		if (buffer_is_empty(sce->content_type)) {
+		if (buffer_string_is_empty(sce->content_type)) {
 			/* we are setting application/octet-stream, but also announce that
 			 * this header field might change in the seconds few requests 
 			 *
@@ -469,7 +470,7 @@
 	}
 
 	if (allow_caching) {
-		if (p->conf.etags_used && con->etag_flags != 0 && !buffer_is_empty(sce->etag)) {
+		if (p->conf.etags_used && con->etag_flags != 0 && !buffer_string_is_empty(sce->etag)) {
 			if (NULL == array_get_element(con->response.headers, "ETag")) {
 				/* generate e-tag */
 				etag_mutate(con->physical.etag, sce->etag);
diff -u lighttpd-1.4.32/src/mod_status.c lighttpd-1.4.36/src/mod_status.c
--- lighttpd-1.4.32/src/mod_status.c	2011-10-05 08:32:23.000000000 -0500
+++ lighttpd-1.4.36/src/mod_status.c	2015-07-26 05:36:36.000000000 -0500
@@ -115,7 +115,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -199,7 +199,7 @@
 
 static handler_t mod_status_handle_server_status_html(server *srv, connection *con, void *p_d) {
 	plugin_data *p = p_d;
-	buffer *b;
+	buffer *b = buffer_init();
 	size_t j;
 	double avg;
 	char multiplier = '\0';
@@ -208,8 +208,6 @@
 
 	int days, hours, mins, seconds;
 
-	b = chunkqueue_get_append_buffer(con->write_queue);
-
 	buffer_copy_string_len(b, CONST_STR_LEN(
 				 "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n"
 				 "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n"
@@ -323,21 +321,21 @@
 	seconds = ts;
 
 	if (days) {
-		buffer_append_long(b, days);
+		buffer_append_int(b, days);
 		buffer_append_string_len(b, CONST_STR_LEN(" days "));
 	}
 
 	if (hours) {
-		buffer_append_long(b, hours);
+		buffer_append_int(b, hours);
 		buffer_append_string_len(b, CONST_STR_LEN(" hours "));
 	}
 
 	if (mins) {
-		buffer_append_long(b, mins);
+		buffer_append_int(b, mins);
 		buffer_append_string_len(b, CONST_STR_LEN(" min "));
 	}
 
-	buffer_append_long(b, seconds);
+	buffer_append_int(b, seconds);
 	buffer_append_string_len(b, CONST_STR_LEN(" s"));
 
 	buffer_append_string_len(b, CONST_STR_LEN("</td></tr>\n"));
@@ -357,7 +355,7 @@
 
 	mod_status_get_multiplier(&avg, &multiplier, 1000);
 
-	buffer_append_long(b, avg);
+	buffer_append_int(b, avg);
 	buffer_append_string_len(b, CONST_STR_LEN(" "));
 	if (multiplier)	buffer_append_string_len(b, &multiplier, 1);
 	buffer_append_string_len(b, CONST_STR_LEN("req</td></tr>\n"));
@@ -382,7 +380,7 @@
 
 	mod_status_get_multiplier(&avg, &multiplier, 1000);
 
-	buffer_append_long(b, avg);
+	buffer_append_int(b, avg);
 	buffer_append_string_len(b, CONST_STR_LEN(" "));
 	if (multiplier)	buffer_append_string_len(b, &multiplier, 1);
 	buffer_append_string_len(b, CONST_STR_LEN("req/s</td></tr>\n"));
@@ -411,7 +409,7 @@
 
 	mod_status_get_multiplier(&avg, &multiplier, 1000);
 
-	buffer_append_long(b, avg);
+	buffer_append_int(b, avg);
 	buffer_append_string_len(b, CONST_STR_LEN(" "));
 	if (multiplier)	buffer_append_string_len(b, &multiplier, 1);
 
@@ -444,14 +442,14 @@
 		"s = response-start, S = response-end\n"));
 
 	buffer_append_string_len(b, CONST_STR_LEN("<b>"));
-	buffer_append_long(b, srv->conns->used);
+	buffer_append_int(b, srv->conns->used);
 	buffer_append_string_len(b, CONST_STR_LEN(" connections</b>\n"));
 
 	for (j = 0; j < srv->conns->used; j++) {
 		connection *c = srv->conns->ptr[j];
 		const char *state;
 
-		if (CON_STATE_READ == c->state && c->request.orig_uri->used > 0) {
+		if (CON_STATE_READ == c->state && !buffer_string_is_empty(c->request.orig_uri)) {
 			state = "k";
 		} else {
 			state = connection_get_short_state(c->state);
@@ -488,22 +486,22 @@
 		buffer_append_string_len(b, CONST_STR_LEN("</td><td class=\"int\">"));
 
 		if (c->request.content_length) {
-			buffer_append_long(b, c->request_content_queue->bytes_in);
+			buffer_append_int(b, c->request_content_queue->bytes_in);
 			buffer_append_string_len(b, CONST_STR_LEN("/"));
-			buffer_append_long(b, c->request.content_length);
+			buffer_append_int(b, c->request.content_length);
 		} else {
 			buffer_append_string_len(b, CONST_STR_LEN("0/0"));
 		}
 
 		buffer_append_string_len(b, CONST_STR_LEN("</td><td class=\"int\">"));
 
-		buffer_append_off_t(b, chunkqueue_written(c->write_queue));
+		buffer_append_int(b, c->write_queue->bytes_out);
 		buffer_append_string_len(b, CONST_STR_LEN("/"));
-		buffer_append_off_t(b, chunkqueue_length(c->write_queue));
+		buffer_append_int(b, c->write_queue->bytes_out + chunkqueue_length(c->write_queue));
 
 		buffer_append_string_len(b, CONST_STR_LEN("</td><td class=\"string\">"));
 
-		if (CON_STATE_READ == c->state && c->request.orig_uri->used > 0) {
+		if (CON_STATE_READ == c->state && !buffer_string_is_empty(c->request.orig_uri)) {
 			buffer_append_string_len(b, CONST_STR_LEN("keep-alive"));
 		} else {
 			buffer_append_string(b, connection_get_state(c->state));
@@ -511,11 +509,11 @@
 
 		buffer_append_string_len(b, CONST_STR_LEN("</td><td class=\"int\">"));
 
-		buffer_append_long(b, srv->cur_ts - c->request_start);
+		buffer_append_int(b, srv->cur_ts - c->request_start);
 
 		buffer_append_string_len(b, CONST_STR_LEN("</td><td class=\"string\">"));
 
-		if (buffer_is_empty(c->server_name)) {
+		if (buffer_string_is_empty(c->server_name)) {
 			buffer_append_string_buffer(b, c->uri.authority);
 		}
 		else {
@@ -524,16 +522,16 @@
 
 		buffer_append_string_len(b, CONST_STR_LEN("</td><td class=\"string\">"));
 
-		if (!buffer_is_empty(c->uri.path)) {
+		if (!buffer_string_is_empty(c->uri.path)) {
 			buffer_append_string_encoded(b, CONST_BUF_LEN(c->uri.path), ENCODING_HTML);
 		}
 
-		if (!buffer_is_empty(c->uri.query)) {
+		if (!buffer_string_is_empty(c->uri.query)) {
 			buffer_append_string_len(b, CONST_STR_LEN("?"));
 			buffer_append_string_encoded(b, CONST_BUF_LEN(c->uri.query), ENCODING_HTML);
 		}
 
-		if (!buffer_is_empty(c->request.orig_uri)) {
+		if (!buffer_string_is_empty(c->request.orig_uri)) {
 			buffer_append_string_len(b, CONST_STR_LEN(" ("));
 			buffer_append_string_encoded(b, CONST_BUF_LEN(c->request.orig_uri), ENCODING_HTML);
 			buffer_append_string_len(b, CONST_STR_LEN(")"));
@@ -555,6 +553,9 @@
 		      "</html>\n"
 		      ));
 
+	chunkqueue_append_buffer(con->write_queue, b);
+	buffer_free(b);
+
 	response_header_overwrite(srv, con, CONST_STR_LEN("Content-Type"), CONST_STR_LEN("text/html"));
 
 	return 0;
@@ -563,15 +564,13 @@
 
 static handler_t mod_status_handle_server_status_text(server *srv, connection *con, void *p_d) {
 	plugin_data *p = p_d;
-	buffer *b;
+	buffer *b = buffer_init();
 	double avg;
 	time_t ts;
 	char buf[32];
 	unsigned int k;
 	unsigned int l;
 
-	b = chunkqueue_get_append_buffer(con->write_queue);
-
 	/* output total number of requests */
 	buffer_append_string_len(b, CONST_STR_LEN("Total Accesses: "));
 	avg = p->abs_requests;
@@ -589,22 +588,22 @@
 	/* output uptime */
 	buffer_append_string_len(b, CONST_STR_LEN("Uptime: "));
 	ts = srv->cur_ts - srv->startup_ts;
-	buffer_append_long(b, ts);
+	buffer_append_int(b, ts);
 	buffer_append_string_len(b, CONST_STR_LEN("\n"));
 
 	/* output busy servers */
 	buffer_append_string_len(b, CONST_STR_LEN("BusyServers: "));
-	buffer_append_long(b, srv->conns->used);
+	buffer_append_int(b, srv->conns->used);
 	buffer_append_string_len(b, CONST_STR_LEN("\n"));
 
 	buffer_append_string_len(b, CONST_STR_LEN("IdleServers: "));
-       buffer_append_long(b, srv->conns->size - srv->conns->used);
-       buffer_append_string_len(b, CONST_STR_LEN("\n"));
+	buffer_append_int(b, srv->conns->size - srv->conns->used);
+	buffer_append_string_len(b, CONST_STR_LEN("\n"));
 
-       /* output scoreboard */
-       buffer_append_string_len(b, CONST_STR_LEN("Scoreboard: "));
-       for (k = 0; k < srv->conns->used; k++) {
-        	connection *c = srv->conns->ptr[k];
+	/* output scoreboard */
+	buffer_append_string_len(b, CONST_STR_LEN("Scoreboard: "));
+	for (k = 0; k < srv->conns->used; k++) {
+		connection *c = srv->conns->ptr[k];
 		const char *state = connection_get_short_state(c->state);
 		buffer_append_string_len(b, state, 1);
 	}
@@ -613,8 +612,10 @@
 	}
 	buffer_append_string_len(b, CONST_STR_LEN("\n"));
 
-	/* set text/plain output */
+	chunkqueue_append_buffer(con->write_queue, b);
+	buffer_free(b);
 
+	/* set text/plain output */
 	response_header_overwrite(srv, con, CONST_STR_LEN("Content-Type"), CONST_STR_LEN("text/plain"));
 
 	return 0;
@@ -634,17 +635,19 @@
 		return HANDLER_FINISHED;
 	}
 
-	b = chunkqueue_get_append_buffer(con->write_queue);
-
+	b = buffer_init();
 	for (i = 0; i < st->used; i++) {
 		size_t ndx = st->sorted[i];
 
 		buffer_append_string_buffer(b, st->data[ndx]->key);
 		buffer_append_string_len(b, CONST_STR_LEN(": "));
-		buffer_append_long(b, ((data_integer *)(st->data[ndx]))->value);
+		buffer_append_int(b, ((data_integer *)(st->data[ndx]))->value);
 		buffer_append_string_len(b, CONST_STR_LEN("\n"));
 	}
 
+	chunkqueue_append_buffer(con->write_queue, b);
+	buffer_free(b);
+
 	response_header_overwrite(srv, con, CONST_STR_LEN("Content-Type"), CONST_STR_LEN("text/plain"));
 
 	con->http_status = 200;
@@ -671,7 +674,8 @@
 
 static handler_t mod_status_handle_server_config(server *srv, connection *con, void *p_d) {
 	plugin_data *p = p_d;
-	buffer *b, *m = p->module_list;
+	buffer *b = buffer_init();
+	buffer *m = p->module_list;
 	size_t i;
 
 	struct ev_map { fdevent_handler_t et; const char *name; } event_handlers[] =
@@ -703,8 +707,6 @@
 		{ FDEVENT_HANDLER_UNSET,          NULL }
 	};
 
-	b = chunkqueue_get_append_buffer(con->write_queue);
-
 	buffer_copy_string_len(b, CONST_STR_LEN(
 			   "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n"
 			   "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n"
@@ -740,7 +742,7 @@
 		plugin *pl = ps[i];
 
 		if (i == 0) {
-			buffer_copy_string_buffer(m, pl->name);
+			buffer_copy_buffer(m, pl->name);
 		} else {
 			buffer_append_string_len(m, CONST_STR_LEN("<br />"));
 			buffer_append_string_buffer(m, pl->name);
@@ -756,6 +758,9 @@
 		      "</html>\n"
 		      ));
 
+	chunkqueue_append_buffer(con->write_queue, b);
+	buffer_free(b);
+
 	response_header_overwrite(srv, con, CONST_STR_LEN("Content-Type"), CONST_STR_LEN("text/html"));
 
 	con->http_status = 200;
@@ -809,13 +814,13 @@
 
 	mod_status_patch_connection(srv, con, p);
 
-	if (!buffer_is_empty(p->conf.status_url) &&
+	if (!buffer_string_is_empty(p->conf.status_url) &&
 	    buffer_is_equal(p->conf.status_url, con->uri.path)) {
 		return mod_status_handle_server_status(srv, con, p_d);
-	} else if (!buffer_is_empty(p->conf.config_url) &&
+	} else if (!buffer_string_is_empty(p->conf.config_url) &&
 	    buffer_is_equal(p->conf.config_url, con->uri.path)) {
 		return mod_status_handle_server_config(srv, con, p_d);
-	} else if (!buffer_is_empty(p->conf.statistics_url) &&
+	} else if (!buffer_string_is_empty(p->conf.statistics_url) &&
 	    buffer_is_equal(p->conf.statistics_url, con->uri.path)) {
 		return mod_status_handle_server_statistics(srv, con, p_d);
 	}
diff -u lighttpd-1.4.32/src/mod_trigger_b4_dl.c lighttpd-1.4.36/src/mod_trigger_b4_dl.c
--- lighttpd-1.4.32/src/mod_trigger_b4_dl.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/mod_trigger_b4_dl.c	2015-07-26 05:36:36.000000000 -0500
@@ -89,7 +89,7 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
-			if (!s) continue;
+			if (NULL == s) continue;
 
 			buffer_free(s->db_filename);
 			buffer_free(s->download_url);
@@ -143,7 +143,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -175,19 +175,17 @@
 			return HANDLER_ERROR;
 		}
 #if defined(HAVE_GDBM_H)
-		if (!buffer_is_empty(s->db_filename)) {
+		if (!buffer_string_is_empty(s->db_filename)) {
 			if (NULL == (s->db = gdbm_open(s->db_filename->ptr, 4096, GDBM_WRCREAT | GDBM_NOLOCK, S_IRUSR | S_IWUSR, 0))) {
 				log_error_write(srv, __FILE__, __LINE__, "s",
 						"gdbm-open failed");
 				return HANDLER_ERROR;
 			}
-#ifdef FD_CLOEXEC
-			fcntl(gdbm_fdesc(s->db), F_SETFD, FD_CLOEXEC);
-#endif
+			fd_close_on_exec(gdbm_fdesc(s->db));
 		}
 #endif
 #if defined(HAVE_PCRE_H)
-		if (!buffer_is_empty(s->download_url)) {
+		if (!buffer_string_is_empty(s->download_url)) {
 			if (NULL == (s->download_regex = pcre_compile(s->download_url->ptr,
 								      0, &errptr, &erroff, NULL))) {
 
@@ -198,7 +196,7 @@
 			}
 		}
 
-		if (!buffer_is_empty(s->trigger_url)) {
+		if (!buffer_string_is_empty(s->trigger_url)) {
 			if (NULL == (s->trigger_regex = pcre_compile(s->trigger_url->ptr,
 								     0, &errptr, &erroff, NULL))) {
 
@@ -322,7 +320,7 @@
 
 	if (con->mode != DIRECT) return HANDLER_GO_ON;
 
-	if (con->uri.path->used == 0) return HANDLER_GO_ON;
+	if (buffer_is_empty(con->uri.path)) return HANDLER_GO_ON;
 
 	mod_trigger_b4_dl_patch_connection(srv, con, p);
 
@@ -358,7 +356,7 @@
 	}
 
 	/* check if URL is a trigger -> insert IP into DB */
-	if ((n = pcre_exec(p->conf.trigger_regex, NULL, con->uri.path->ptr, con->uri.path->used - 1, 0, 0, ovec, 3 * N)) < 0) {
+	if ((n = pcre_exec(p->conf.trigger_regex, NULL, CONST_BUF_LEN(con->uri.path), 0, 0, ovec, 3 * N)) < 0) {
 		if (n != PCRE_ERROR_NOMATCH) {
 			log_error_write(srv, __FILE__, __LINE__, "sd",
 					"execution error while matching:", n);
@@ -385,11 +383,12 @@
 # endif
 # if defined(HAVE_MEMCACHE_H)
 		if (p->conf.mc) {
-			size_t i;
-			buffer_copy_string_buffer(p->tmp_buf, p->conf.mc_namespace);
+			size_t i, len;
+			buffer_copy_buffer(p->tmp_buf, p->conf.mc_namespace);
 			buffer_append_string(p->tmp_buf, remote_ip);
 
-			for (i = 0; i < p->tmp_buf->used - 1; i++) {
+			len = buffer_string_length(p->tmp_buf);
+			for (i = 0; i < len; i++) {
 				if (p->tmp_buf->ptr[i] == ' ') p->tmp_buf->ptr[i] = '-';
 			}
 
@@ -409,7 +408,7 @@
 	}
 
 	/* check if URL is a download -> check IP in DB, update timestamp */
-	if ((n = pcre_exec(p->conf.download_regex, NULL, con->uri.path->ptr, con->uri.path->used - 1, 0, 0, ovec, 3 * N)) < 0) {
+	if ((n = pcre_exec(p->conf.download_regex, NULL, CONST_BUF_LEN(con->uri.path), 0, 0, ovec, 3 * N)) < 0) {
 		if (n != PCRE_ERROR_NOMATCH) {
 			log_error_write(srv, __FILE__, __LINE__, "sd",
 					"execution error while matching: ", n);
@@ -437,7 +436,7 @@
 				return HANDLER_FINISHED;
 			}
 
-			last_hit = *(time_t *)(val.dptr);
+			memcpy(&last_hit, val.dptr, sizeof(time_t));
 
 			free(val.dptr);
 
@@ -471,12 +470,13 @@
 # if defined(HAVE_MEMCACHE_H)
 		if (p->conf.mc) {
 			void *r;
-			size_t i;
+			size_t i, len;
 
-			buffer_copy_string_buffer(p->tmp_buf, p->conf.mc_namespace);
+			buffer_copy_buffer(p->tmp_buf, p->conf.mc_namespace);
 			buffer_append_string(p->tmp_buf, remote_ip);
 
-			for (i = 0; i < p->tmp_buf->used - 1; i++) {
+			len = buffer_string_length(p->tmp_buf);
+			for (i = 0; i < len; i++) {
 				if (p->tmp_buf->ptr[i] == ' ') p->tmp_buf->ptr[i] = '-';
 			}
 
@@ -555,7 +555,7 @@
 
 			val = gdbm_fetch(s->db, key);
 
-			last_hit = *(time_t *)(val.dptr);
+			memcpy(&last_hit, val.dptr, sizeof(time_t));
 
 			free(val.dptr);
 
diff -u lighttpd-1.4.32/src/mod_userdir.c lighttpd-1.4.36/src/mod_userdir.c
--- lighttpd-1.4.32/src/mod_userdir.c	2011-07-30 04:18:49.000000000 -0500
+++ lighttpd-1.4.36/src/mod_userdir.c	2015-07-26 05:36:36.000000000 -0500
@@ -22,6 +22,7 @@
 	buffer *path;
 	buffer *basepath;
 	unsigned short letterhomes;
+	unsigned short active;
 } plugin_config;
 
 typedef struct {
@@ -59,6 +60,8 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
+			if (NULL == s) continue;
+
 			array_free(s->include_user);
 			array_free(s->exclude_user);
 			buffer_free(s->path);
@@ -88,13 +91,14 @@
 		{ "userdir.exclude-user",       NULL, T_CONFIG_ARRAY,  T_CONFIG_SCOPE_CONNECTION },       /* 1 */
 		{ "userdir.include-user",       NULL, T_CONFIG_ARRAY,  T_CONFIG_SCOPE_CONNECTION },       /* 2 */
 		{ "userdir.basepath",           NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },       /* 3 */
-		{ "userdir.letterhomes",	NULL, T_CONFIG_BOOLEAN,T_CONFIG_SCOPE_CONNECTION },	  /* 4 */
+		{ "userdir.letterhomes",        NULL, T_CONFIG_BOOLEAN,T_CONFIG_SCOPE_CONNECTION },       /* 4 */
+		{ "userdir.active",             NULL, T_CONFIG_BOOLEAN,T_CONFIG_SCOPE_CONNECTION },       /* 5 */
 		{ NULL,                         NULL, T_CONFIG_UNSET,  T_CONFIG_SCOPE_UNSET }
 	};
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -105,12 +109,16 @@
 		s->path = buffer_init();
 		s->basepath = buffer_init();
 		s->letterhomes = 0;
+		/* enabled by default for backward compatibility; if userdir.path isn't set userdir is disabled too,
+		 * but you can't disable it by setting it to an empty string. */
+		s->active = 1;
 
 		cv[0].destination = s->path;
 		cv[1].destination = s->exclude_user;
 		cv[2].destination = s->include_user;
 		cv[3].destination = s->basepath;
 		cv[4].destination = &(s->letterhomes);
+		cv[5].destination = &(s->active);
 
 		p->config_storage[i] = s;
 
@@ -133,6 +141,7 @@
 	PATCH(include_user);
 	PATCH(basepath);
 	PATCH(letterhomes);
+	PATCH(active);
 
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -156,6 +165,8 @@
 				PATCH(basepath);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("userdir.letterhomes"))) {
 				PATCH(letterhomes);
+			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("userdir.active"))) {
+				PATCH(active);
 			}
 		}
 	}
@@ -172,14 +183,14 @@
 	struct passwd *pwd = NULL;
 #endif
 
-	if (con->uri.path->used == 0) return HANDLER_GO_ON;
+	if (buffer_is_empty(con->uri.path)) return HANDLER_GO_ON;
 
 	mod_userdir_patch_connection(srv, con, p);
 
 	/* enforce the userdir.path to be set in the config, ugly fix for #1587;
 	 * should be replaced with a clean .enabled option in 1.5
 	 */
-	if (p->conf.path->used == 0) return HANDLER_GO_ON;
+	if (!p->conf.active || buffer_is_empty(p->conf.path)) return HANDLER_GO_ON;
 
 	/* /~user/foo.html -> /home/user/public_html/foo.html */
 
@@ -200,7 +211,7 @@
 
 	buffer_copy_string_len(p->username, con->uri.path->ptr + 2, rel_url - (con->uri.path->ptr + 2));
 
-	if (buffer_is_empty(p->conf.basepath)
+	if (buffer_string_is_empty(p->conf.basepath)
 #ifdef HAVE_PWD_H
 	    && NULL == (pwd = getpwnam(p->username->ptr))
 #endif
@@ -236,7 +247,7 @@
 
 	/* we build the physical path */
 
-	if (buffer_is_empty(p->conf.basepath)) {
+	if (buffer_string_is_empty(p->conf.basepath)) {
 #ifdef HAVE_PWD_H
 		buffer_copy_string(p->temp_path, pwd->pw_dir);
 #endif
@@ -263,18 +274,18 @@
 			buffer_to_lower(p->username);
 		}
 
-		buffer_copy_string_buffer(p->temp_path, p->conf.basepath);
-		BUFFER_APPEND_SLASH(p->temp_path);
+		buffer_copy_buffer(p->temp_path, p->conf.basepath);
+		buffer_append_slash(p->temp_path);
 		if (p->conf.letterhomes) {
 			buffer_append_string_len(p->temp_path, p->username->ptr, 1);
-			BUFFER_APPEND_SLASH(p->temp_path);
+			buffer_append_slash(p->temp_path);
 		}
 		buffer_append_string_buffer(p->temp_path, p->username);
 	}
-	BUFFER_APPEND_SLASH(p->temp_path);
+	buffer_append_slash(p->temp_path);
 	buffer_append_string_buffer(p->temp_path, p->conf.path);
 
-	if (buffer_is_empty(p->conf.basepath)) {
+	if (buffer_string_is_empty(p->conf.basepath)) {
 		struct stat st;
 		int ret;
 
@@ -284,6 +295,8 @@
 		}
 	}
 
+	buffer_copy_buffer(con->physical.basedir, p->temp_path);
+
 	/* the physical rel_path is basically the same as uri.path;
 	 * but it is converted to lowercase in case of force_lowercase_filenames and some special handling
 	 * for trailing '.', ' ' and '/' on windows
@@ -291,7 +304,7 @@
 	 * (docroot should only set the docroot/server name, phyiscal should only change the phyiscal.path;
 	 *  the exception mod_secure_download doesn't work with userdir anyway)
 	 */
-	BUFFER_APPEND_SLASH(p->temp_path);
+	buffer_append_slash(p->temp_path);
 	/* if no second '/' is found, we assume that it was stripped from the uri.path for the special handling
 	 * on windows.
 	 * we do not care about the trailing slash here on windows, as we already ensured it is a directory
@@ -302,7 +315,7 @@
 	if (NULL != (rel_url = strchr(con->physical.rel_path->ptr + 2, '/'))) {
 		buffer_append_string(p->temp_path, rel_url + 1); /* skip the / */
 	}
-	buffer_copy_string_buffer(con->physical.path, p->temp_path);
+	buffer_copy_buffer(con->physical.path, p->temp_path);
 
 	buffer_reset(p->temp_path);
 
diff -u lighttpd-1.4.32/src/mod_usertrack.c lighttpd-1.4.36/src/mod_usertrack.c
--- lighttpd-1.4.32/src/mod_usertrack.c	2011-07-30 04:00:53.000000000 -0500
+++ lighttpd-1.4.36/src/mod_usertrack.c	2015-07-26 05:36:36.000000000 -0500
@@ -48,6 +48,8 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
+			if (NULL == s) continue;
+
 			buffer_free(s->cookie_name);
 			buffer_free(s->cookie_domain);
 
@@ -78,7 +80,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -98,11 +100,11 @@
 			return HANDLER_ERROR;
 		}
 
-		if (buffer_is_empty(s->cookie_name)) {
+		if (buffer_string_is_empty(s->cookie_name)) {
 			buffer_copy_string_len(s->cookie_name, CONST_STR_LEN("TRACKID"));
 		} else {
-			size_t j;
-			for (j = 0; j < s->cookie_name->used - 1; j++) {
+			size_t j, len = buffer_string_length(s->cookie_name);
+			for (j = 0; j < len; j++) {
 				char c = s->cookie_name->ptr[j] | 32;
 				if (c < 'a' || c > 'z') {
 					log_error_write(srv, __FILE__, __LINE__, "sb",
@@ -114,9 +116,9 @@
 			}
 		}
 
-		if (!buffer_is_empty(s->cookie_domain)) {
-			size_t j;
-			for (j = 0; j < s->cookie_domain->used - 1; j++) {
+		if (!buffer_string_is_empty(s->cookie_domain)) {
+			size_t j, len = buffer_string_length(s->cookie_domain);
+			for (j = 0; j < len; j++) {
 				char c = s->cookie_domain->ptr[j];
 				if (c <= 32 || c >= 127 || c == '"' || c == '\\') {
 					log_error_write(srv, __FILE__, __LINE__, "sb",
@@ -173,9 +175,9 @@
 	data_string *ds;
 	unsigned char h[16];
 	li_MD5_CTX Md5Ctx;
-	char hh[32];
+	char hh[LI_ITOSTRING_LENGTH];
 
-	if (con->uri.path->used == 0) return HANDLER_GO_ON;
+	if (buffer_is_empty(con->uri.path)) return HANDLER_GO_ON;
 
 	mod_usertrack_patch_connection(srv, con, p);
 
@@ -193,7 +195,7 @@
 			char *nc;
 
 			/* skip WS */
-			for (nc = g + p->conf.cookie_name->used-1; *nc == ' ' || *nc == '\t'; nc++);
+			for (nc = g + buffer_string_length(p->conf.cookie_name); *nc == ' ' || *nc == '\t'; nc++);
 
 			if (*nc == '=') {
 				/* ok, found the key of our own cookie */
@@ -211,7 +213,7 @@
 		ds = data_response_init();
 	}
 	buffer_copy_string_len(ds->key, CONST_STR_LEN("Set-Cookie"));
-	buffer_copy_string_buffer(ds->value, p->conf.cookie_name);
+	buffer_copy_buffer(ds->value, p->conf.cookie_name);
 	buffer_append_string_len(ds->value, CONST_STR_LEN("="));
 
 
@@ -219,14 +221,14 @@
 
 	/* generate shared-secret */
 	li_MD5_Init(&Md5Ctx);
-	li_MD5_Update(&Md5Ctx, (unsigned char *)con->uri.path->ptr, con->uri.path->used - 1);
-	li_MD5_Update(&Md5Ctx, (unsigned char *)"+", 1);
+	li_MD5_Update(&Md5Ctx, CONST_BUF_LEN(con->uri.path));
+	li_MD5_Update(&Md5Ctx, CONST_STR_LEN("+"));
 
 	/* we assume sizeof(time_t) == 4 here, but if not it ain't a problem at all */
-	LI_ltostr(hh, srv->cur_ts);
+	li_itostr(hh, srv->cur_ts);
 	li_MD5_Update(&Md5Ctx, (unsigned char *)hh, strlen(hh));
 	li_MD5_Update(&Md5Ctx, (unsigned char *)srv->entropy, sizeof(srv->entropy));
-	LI_ltostr(hh, rand());
+	li_itostr(hh, rand());
 	li_MD5_Update(&Md5Ctx, (unsigned char *)hh, strlen(hh));
 
 	li_MD5_Final(h, &Md5Ctx);
@@ -235,14 +237,14 @@
 	buffer_append_string_len(ds->value, CONST_STR_LEN("; Path=/"));
 	buffer_append_string_len(ds->value, CONST_STR_LEN("; Version=1"));
 
-	if (!buffer_is_empty(p->conf.cookie_domain)) {
+	if (!buffer_string_is_empty(p->conf.cookie_domain)) {
 		buffer_append_string_len(ds->value, CONST_STR_LEN("; Domain="));
 		buffer_append_string_encoded(ds->value, CONST_BUF_LEN(p->conf.cookie_domain), ENCODING_REL_URI);
 	}
 
 	if (p->conf.cookie_max_age) {
 		buffer_append_string_len(ds->value, CONST_STR_LEN("; max-age="));
-		buffer_append_long(ds->value, p->conf.cookie_max_age);
+		buffer_append_int(ds->value, p->conf.cookie_max_age);
 	}
 
 	array_insert_unique(con->response.headers, (data_unset *)ds);
diff -u lighttpd-1.4.32/src/mod_webdav.c lighttpd-1.4.36/src/mod_webdav.c
--- lighttpd-1.4.32/src/mod_webdav.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.36/src/mod_webdav.c	2015-07-26 05:36:36.000000000 -0500
@@ -120,7 +120,7 @@
 		for (i = 0; i < srv->config_context->used; i++) {
 			plugin_config *s = p->config_storage[i];
 
-			if (!s) continue;
+			if (NULL == s) continue;
 
 			buffer_free(s->sqlite_db_name);
 #ifdef USE_PROPPATCH
@@ -179,7 +179,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -198,7 +198,7 @@
 			return HANDLER_ERROR;
 		}
 
-		if (!buffer_is_empty(s->sqlite_db_name)) {
+		if (!buffer_string_is_empty(s->sqlite_db_name)) {
 #ifdef USE_PROPPATCH
 			const char *next_stmt;
 			char *err;
@@ -446,7 +446,7 @@
 
 	UNUSED(srv);
 
-	if (con->uri.path->used == 0) return HANDLER_GO_ON;
+	if (buffer_is_empty(con->uri.path)) return HANDLER_GO_ON;
 
 	mod_webdav_patch_connection(srv, con, p);
 
@@ -519,7 +519,7 @@
 	} else {
 		buffer_copy_string_len(b, CONST_STR_LEN("HTTP/1.0 "));
 	}
-	buffer_append_long(b, status);
+	buffer_append_int(b, status);
 	buffer_append_string_len(b, CONST_STR_LEN(" "));
 	buffer_append_string(b, get_http_status_name(status));
 
@@ -558,9 +558,8 @@
 			/* bind the values to the insert */
 
 			sqlite3_bind_text(stmt, 1,
-					  dst->rel_path->ptr,
-					  dst->rel_path->used - 1,
-					  SQLITE_TRANSIENT);
+				CONST_BUF_LEN(dst->rel_path),
+				SQLITE_TRANSIENT);
 
 			if (SQLITE_DONE != sqlite3_step(stmt)) {
 				/* */
@@ -590,17 +589,17 @@
 			int status = 0;
 
 			if ((de->d_name[0] == '.' && de->d_name[1] == '\0')  ||
-			    (de->d_name[0] == '.' && de->d_name[1] == '.' && de->d_name[2] == '\0')) {
+			  (de->d_name[0] == '.' && de->d_name[1] == '.' && de->d_name[2] == '\0')) {
 				continue;
 				/* ignore the parent dir */
 			}
 
-			buffer_copy_string_buffer(d.path, dst->path);
-			BUFFER_APPEND_SLASH(d.path);
+			buffer_copy_buffer(d.path, dst->path);
+			buffer_append_slash(d.path);
 			buffer_append_string(d.path, de->d_name);
 
-			buffer_copy_string_buffer(d.rel_path, dst->rel_path);
-			BUFFER_APPEND_SLASH(d.rel_path);
+			buffer_copy_buffer(d.rel_path, dst->rel_path);
+			buffer_append_slash(d.rel_path);
 			buffer_append_string(d.rel_path, de->d_name);
 
 			/* stat and unlink afterwards */
@@ -636,9 +635,8 @@
 						/* bind the values to the insert */
 
 						sqlite3_bind_text(stmt, 1,
-								  d.rel_path->ptr,
-								  d.rel_path->used - 1,
-								  SQLITE_TRANSIENT);
+							CONST_BUF_LEN(d.rel_path),
+							SQLITE_TRANSIENT);
 
 						if (SQLITE_DONE != sqlite3_step(stmt)) {
 							/* */
@@ -714,14 +712,12 @@
 
 			/* bind the values to the insert */
 			sqlite3_bind_text(stmt, 1,
-					  dst->rel_path->ptr,
-					  dst->rel_path->used - 1,
-					  SQLITE_TRANSIENT);
+				CONST_BUF_LEN(dst->rel_path),
+				SQLITE_TRANSIENT);
 
 			sqlite3_bind_text(stmt, 2,
-					  src->rel_path->ptr,
-					  src->rel_path->used - 1,
-					  SQLITE_TRANSIENT);
+				CONST_BUF_LEN(src->rel_path),
+				SQLITE_TRANSIENT);
 
 			if (SQLITE_DONE != sqlite3_step(stmt)) {
 				/* */
@@ -751,25 +747,25 @@
 		while (NULL != (de = readdir(srcdir))) {
 			struct stat st;
 
-			if ((de->d_name[0] == '.' && de->d_name[1] == '\0') ||
-		            (de->d_name[0] == '.' && de->d_name[1] == '.' && de->d_name[2] == '\0')) {
+			if ((de->d_name[0] == '.' && de->d_name[1] == '\0')
+				|| (de->d_name[0] == '.' && de->d_name[1] == '.' && de->d_name[2] == '\0')) {
 				continue;
 			}
 
-			buffer_copy_string_buffer(s.path, src->path);
-			BUFFER_APPEND_SLASH(s.path);
+			buffer_copy_buffer(s.path, src->path);
+			buffer_append_slash(s.path);
 			buffer_append_string(s.path, de->d_name);
 
-			buffer_copy_string_buffer(d.path, dst->path);
-			BUFFER_APPEND_SLASH(d.path);
+			buffer_copy_buffer(d.path, dst->path);
+			buffer_append_slash(d.path);
 			buffer_append_string(d.path, de->d_name);
 
-			buffer_copy_string_buffer(s.rel_path, src->rel_path);
-			BUFFER_APPEND_SLASH(s.rel_path);
+			buffer_copy_buffer(s.rel_path, src->rel_path);
+			buffer_append_slash(s.rel_path);
 			buffer_append_string(s.rel_path, de->d_name);
 
-			buffer_copy_string_buffer(d.rel_path, dst->rel_path);
-			BUFFER_APPEND_SLASH(d.rel_path);
+			buffer_copy_buffer(d.rel_path, dst->rel_path);
+			buffer_append_slash(d.rel_path);
 			buffer_append_string(d.rel_path, de->d_name);
 
 			if (-1 == stat(s.path->ptr, &st)) {
@@ -793,14 +789,12 @@
 
 						/* bind the values to the insert */
 						sqlite3_bind_text(stmt, 1,
-							  dst->rel_path->ptr,
-							  dst->rel_path->used - 1,
-							  SQLITE_TRANSIENT);
+							CONST_BUF_LEN(dst->rel_path),
+							SQLITE_TRANSIENT);
 
 						sqlite3_bind_text(stmt, 2,
-							  src->rel_path->ptr,
-							  src->rel_path->used - 1,
-							  SQLITE_TRANSIENT);
+							CONST_BUF_LEN(src->rel_path),
+							SQLITE_TRANSIENT);
 
 						if (SQLITE_DONE != sqlite3_step(stmt)) {
 							/* */
@@ -851,9 +845,9 @@
 				for (k = 0; k < con->conf.mimetypes->used; k++) {
 					data_string *ds = (data_string *)con->conf.mimetypes->data[k];
 
-					if (ds->key->used == 0) continue;
+					if (buffer_is_empty(ds->key)) continue;
 
-					if (buffer_is_equal_right_len(dst->path, ds->key, ds->key->used - 1)) {
+					if (buffer_is_equal_right_len(dst->path, ds->key, buffer_string_length(ds->key))) {
 						buffer_append_string_len(b,CONST_STR_LEN("<D:getcontenttype>"));
 						buffer_append_string_buffer(b, ds->value);
 						buffer_append_string_len(b, CONST_STR_LEN("</D:getcontenttype>"));
@@ -877,7 +871,7 @@
 			found = 1;
 		} else if (0 == strcmp(prop_name, "getcontentlength")) {
 			buffer_append_string_len(b,CONST_STR_LEN("<D:getcontentlength>"));
-			buffer_append_off_t(b, sce->st.st_size);
+			buffer_append_int(b, sce->st.st_size);
 			buffer_append_string_len(b, CONST_STR_LEN("</D:getcontentlength>"));
 			found = 1;
 		} else if (0 == strcmp(prop_name, "getcontentlanguage")) {
@@ -907,17 +901,16 @@
 			/* bind the values to the insert */
 
 			sqlite3_bind_text(stmt, 1,
-					  dst->rel_path->ptr,
-					  dst->rel_path->used - 1,
-					  SQLITE_TRANSIENT);
+				CONST_BUF_LEN(dst->rel_path),
+				SQLITE_TRANSIENT);
 			sqlite3_bind_text(stmt, 2,
-					  prop_name,
-					  strlen(prop_name),
-					  SQLITE_TRANSIENT);
+				prop_name,
+				strlen(prop_name),
+				SQLITE_TRANSIENT);
 			sqlite3_bind_text(stmt, 3,
-					  prop_ns,
-					  strlen(prop_ns),
-					  SQLITE_TRANSIENT);
+				prop_ns,
+				strlen(prop_ns),
+				SQLITE_TRANSIENT);
 
 			/* it is the PK */
 			while (SQLITE_ROW == sqlite3_step(stmt)) {
@@ -1046,7 +1039,7 @@
 			break;
 		case MEM_CHUNK:
 			/* append to the buffer */
-			weHave = c->mem->used - 1 - c->offset;
+			weHave = buffer_string_length(c->mem) - c->offset;
 
 			if (weHave > weWant) weHave = weWant;
 
@@ -1062,8 +1055,6 @@
 			cq->bytes_out += weHave;
 
 			break;
-		case UNUSED_CHUNK:
-			break;
 		}
 		chunkqueue_remove_finished_chunks(cq);
 	}
@@ -1096,7 +1087,7 @@
 static int webdav_lockdiscovery(server *srv, connection *con,
 		buffer *locktoken, const char *lockscope, const char *locktype, int depth) {
 
-	buffer *b;
+	buffer *b = buffer_init();
 
 	response_header_overwrite(srv, con, CONST_STR_LEN("Lock-Token"), CONST_BUF_LEN(locktoken));
 
@@ -1104,8 +1095,6 @@
 		CONST_STR_LEN("Content-Type"),
 		CONST_STR_LEN("text/xml; charset=\"utf-8\""));
 
-	b = chunkqueue_get_append_buffer(con->write_queue);
-
 	buffer_copy_string_len(b, CONST_STR_LEN("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"));
 
 	buffer_append_string_len(b,CONST_STR_LEN("<D:prop xmlns:D=\"DAV:\" xmlns:ns0=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">\n"));
@@ -1145,6 +1134,9 @@
 	buffer_append_string_len(b,CONST_STR_LEN("</D:lockdiscovery>\n"));
 	buffer_append_string_len(b,CONST_STR_LEN("</D:prop>\n"));
 
+	chunkqueue_append_buffer(con->write_queue, b);
+	buffer_free(b);
+
 	return 0;
 }
 #endif
@@ -1191,8 +1183,8 @@
 		sqlite3_reset(stmt);
 
 		sqlite3_bind_text(stmt, 1,
-			  CONST_BUF_LEN(uri),
-			  SQLITE_TRANSIENT);
+			CONST_BUF_LEN(uri),
+			SQLITE_TRANSIENT);
 
 		while (SQLITE_ROW == sqlite3_step(stmt)) {
 			has_lock = 0;
@@ -1224,7 +1216,7 @@
 
 	if (!p->conf.enabled) return HANDLER_GO_ON;
 	/* physical path is setup */
-	if (con->physical.path->used == 0) return HANDLER_GO_ON;
+	if (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;
 
 	/* PROPFIND need them */
 	if (NULL != (ds = (data_string *)array_get_element(con->request.headers, "Depth"))) {
@@ -1258,7 +1250,7 @@
 			if (1 == webdav_parse_chunkqueue(srv, con, p, con->request_content_queue, &xml)) {
 				xmlNode *rootnode = xmlDocGetRootElement(xml);
 
-				assert(rootnode);
+				force_assert(rootnode);
 
 				if (0 == xmlStrcmp(rootnode->name, BAD_CAST "propfind")) {
 					xmlNode *cmd;
@@ -1275,7 +1267,7 @@
 								if (prop->type == XML_TEXT_NODE) continue; /* ignore WS */
 
 								if (prop->ns &&
-								    (0 == xmlStrcmp(prop->ns->href, BAD_CAST "")) &&
+								  (0 == xmlStrcmp(prop->ns->href, BAD_CAST "")) &&
 								    (0 != xmlStrcmp(prop->ns->prefix, BAD_CAST ""))) {
 									size_t i;
 									log_error_write(srv, __FILE__, __LINE__, "ss",
@@ -1319,9 +1311,8 @@
 								/* bind the values to the insert */
 
 								sqlite3_bind_text(stmt, 1,
-										  con->uri.path->ptr,
-										  con->uri.path->used - 1,
-										  SQLITE_TRANSIENT);
+									CONST_BUF_LEN(con->uri.path),
+									SQLITE_TRANSIENT);
 
 								if (SQLITE_DONE != sqlite3_step(stmt)) {
 								}
@@ -1343,7 +1334,7 @@
 
 		response_header_overwrite(srv, con, CONST_STR_LEN("Content-Type"), CONST_STR_LEN("text/xml; charset=\"utf-8\""));
 
-		b = chunkqueue_get_append_buffer(con->write_queue);
+		b = buffer_init();
 
 		buffer_copy_string_len(b, CONST_STR_LEN("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"));
 
@@ -1367,7 +1358,7 @@
 			buffer_append_string_encoded(b, CONST_BUF_LEN(con->uri.path), ENCODING_REL_URI);
 			buffer_append_string_len(b,CONST_STR_LEN("</D:href>\n"));
 
-			if (!buffer_is_empty(prop_200)) {
+			if (!buffer_string_is_empty(prop_200)) {
 				buffer_append_string_len(b,CONST_STR_LEN("<D:propstat>\n"));
 				buffer_append_string_len(b,CONST_STR_LEN("<D:prop>\n"));
 
@@ -1379,7 +1370,7 @@
 
 				buffer_append_string_len(b,CONST_STR_LEN("</D:propstat>\n"));
 			}
-			if (!buffer_is_empty(prop_404)) {
+			if (!buffer_string_is_empty(prop_404)) {
 				buffer_append_string_len(b,CONST_STR_LEN("<D:propstat>\n"));
 				buffer_append_string_len(b,CONST_STR_LEN("<D:prop>\n"));
 
@@ -1410,11 +1401,11 @@
 						/* ignore the parent dir */
 					}
 
-					buffer_copy_string_buffer(d.path, dst->path);
-					BUFFER_APPEND_SLASH(d.path);
+					buffer_copy_buffer(d.path, dst->path);
+					buffer_append_slash(d.path);
 
-					buffer_copy_string_buffer(d.rel_path, dst->rel_path);
-					BUFFER_APPEND_SLASH(d.rel_path);
+					buffer_copy_buffer(d.rel_path, dst->rel_path);
+					buffer_append_slash(d.rel_path);
 
 					if (de->d_name[0] == '.' && de->d_name[1] == '\0') {
 						/* don't append the . */
@@ -1436,7 +1427,7 @@
 					buffer_append_string_encoded(b, CONST_BUF_LEN(d.rel_path), ENCODING_REL_URI);
 					buffer_append_string_len(b,CONST_STR_LEN("</D:href>\n"));
 
-					if (!buffer_is_empty(prop_200)) {
+					if (!buffer_string_is_empty(prop_200)) {
 						buffer_append_string_len(b,CONST_STR_LEN("<D:propstat>\n"));
 						buffer_append_string_len(b,CONST_STR_LEN("<D:prop>\n"));
 
@@ -1448,7 +1439,7 @@
 
 						buffer_append_string_len(b,CONST_STR_LEN("</D:propstat>\n"));
 					}
-					if (!buffer_is_empty(prop_404)) {
+					if (!buffer_string_is_empty(prop_404)) {
 						buffer_append_string_len(b,CONST_STR_LEN("<D:propstat>\n"));
 						buffer_append_string_len(b,CONST_STR_LEN("<D:prop>\n"));
 
@@ -1489,6 +1480,10 @@
 		if (p->conf.log_xml) {
 			log_error_write(srv, __FILE__, __LINE__, "sb", "XML-response-body:", b);
 		}
+
+		chunkqueue_append_buffer(con->write_queue, b);
+		buffer_free(b);
+
 		con->file_finished = 1;
 
 		return HANDLER_FINISHED;
@@ -1557,7 +1552,7 @@
 				/* we got an error somewhere in between, build a 207 */
 				response_header_overwrite(srv, con, CONST_STR_LEN("Content-Type"), CONST_STR_LEN("text/xml; charset=\"utf-8\""));
 
-				b = chunkqueue_get_append_buffer(con->write_queue);
+				b = buffer_init();
 
 				buffer_copy_string_len(b, CONST_STR_LEN("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"));
 
@@ -1571,6 +1566,9 @@
 					log_error_write(srv, __FILE__, __LINE__, "sb", "XML-response-body:", b);
 				}
 
+				chunkqueue_append_buffer(con->write_queue, b);
+				buffer_free(b);
+
 				con->http_status = 207;
 				con->file_finished = 1;
 			} else {
@@ -1690,7 +1688,7 @@
 
 			/* if the file doesn't exist, create it */
 			if (-1 == (fd = open(con->physical.path->ptr, O_WRONLY|O_TRUNC, WEBDAV_FILE_MODE))) {
-				if (errno == ENOENT &&
+				if (errno != ENOENT ||
 				    -1 == (fd = open(con->physical.path->ptr, O_WRONLY|O_CREAT|O_TRUNC|O_EXCL, WEBDAV_FILE_MODE))) {
 					/* we can't open the file */
 					con->http_status = 403;
@@ -1717,7 +1715,7 @@
 					if (-1 == c->file.fd &&  /* open the file if not already open */
 					    -1 == (c->file.fd = open(c->file.name->ptr, O_RDONLY))) {
 						log_error_write(srv, __FILE__, __LINE__, "ss", "open failed: ", strerror(errno));
-
+						close(fd);
 						return HANDLER_ERROR;
 					}
 
@@ -1726,7 +1724,7 @@
 								strerror(errno), c->file.name,  c->file.fd);
 						close(c->file.fd);
 						c->file.fd = -1;
-
+						close(fd);
 						return HANDLER_ERROR;
 					}
 
@@ -1751,7 +1749,7 @@
 				}
 				break;
 			case MEM_CHUNK:
-				if ((r = write(fd, c->mem->ptr + c->offset, c->mem->used - c->offset - 1)) < 0) {
+				if ((r = write(fd, c->mem->ptr + c->offset, buffer_string_length(c->mem) - c->offset)) < 0) {
 					switch(errno) {
 					case ENOSPC:
 						con->http_status = 507;
@@ -1763,8 +1761,6 @@
 					}
 				}
 				break;
-			case UNUSED_CHUNK:
-				break;
 			}
 
 			if (r > 0) {
@@ -1806,7 +1802,7 @@
 		}
 
 		if (NULL != (ds = (data_string *)array_get_element(con->request.headers, "Overwrite"))) {
-			if (ds->value->used != 2 ||
+			if (buffer_string_length(ds->value) != 1 ||
 			    (ds->value->ptr[0] != 'F' &&
 			     ds->value->ptr[0] != 'T') )  {
 				con->http_status = 400;
@@ -1862,25 +1858,25 @@
 			return HANDLER_FINISHED;
 		}
 
-		buffer_copy_string_buffer(p->tmp_buf, p->uri.path_raw);
+		buffer_copy_buffer(p->tmp_buf, p->uri.path_raw);
 		buffer_urldecode_path(p->tmp_buf);
 		buffer_path_simplify(p->uri.path, p->tmp_buf);
 
 		/* we now have a URI which is clean. transform it into a physical path */
-		buffer_copy_string_buffer(p->physical.doc_root, con->physical.doc_root);
-		buffer_copy_string_buffer(p->physical.rel_path, p->uri.path);
+		buffer_copy_buffer(p->physical.doc_root, con->physical.doc_root);
+		buffer_copy_buffer(p->physical.rel_path, p->uri.path);
 
 		if (con->conf.force_lowercase_filenames) {
 			buffer_to_lower(p->physical.rel_path);
 		}
 
-		buffer_copy_string_buffer(p->physical.path, p->physical.doc_root);
-		BUFFER_APPEND_SLASH(p->physical.path);
-		buffer_copy_string_buffer(p->physical.basedir, p->physical.path);
+		buffer_copy_buffer(p->physical.path, p->physical.doc_root);
+		buffer_append_slash(p->physical.path);
+		buffer_copy_buffer(p->physical.basedir, p->physical.path);
 
 		/* don't add a second / */
 		if (p->physical.rel_path->ptr[0] == '/') {
-			buffer_append_string_len(p->physical.path, p->physical.rel_path->ptr + 1, p->physical.rel_path->used - 2);
+			buffer_append_string_len(p->physical.path, p->physical.rel_path->ptr + 1, buffer_string_length(p->physical.rel_path) - 1);
 		} else {
 			buffer_append_string_buffer(p->physical.path, p->physical.rel_path);
 		}
@@ -1989,9 +1985,8 @@
 
 						/* bind the values to the insert */
 						sqlite3_bind_text(stmt, 1,
-								  con->uri.path->ptr,
-								  con->uri.path->used - 1,
-								  SQLITE_TRANSIENT);
+							CONST_BUF_LEN(con->uri.path),
+							SQLITE_TRANSIENT);
 
 						if (SQLITE_DONE != sqlite3_step(stmt)) {
 							log_error_write(srv, __FILE__, __LINE__, "ss", "sql-move(delete old) failed:", sqlite3_errmsg(p->conf.sql));
@@ -2005,14 +2000,12 @@
 
 						/* bind the values to the insert */
 						sqlite3_bind_text(stmt, 1,
-								  p->uri.path->ptr,
-								  p->uri.path->used - 1,
-								  SQLITE_TRANSIENT);
+							CONST_BUF_LEN(p->uri.path),
+							SQLITE_TRANSIENT);
 
 						sqlite3_bind_text(stmt, 2,
-								  con->uri.path->ptr,
-								  con->uri.path->used - 1,
-								  SQLITE_TRANSIENT);
+							CONST_BUF_LEN(con->uri.path),
+							SQLITE_TRANSIENT);
 
 						if (SQLITE_DONE != sqlite3_step(stmt)) {
 							log_error_write(srv, __FILE__, __LINE__, "ss", "sql-move failed:", sqlite3_errmsg(p->conf.sql));
@@ -2117,29 +2110,28 @@
 									/* bind the values to the insert */
 
 									sqlite3_bind_text(stmt, 1,
-											  con->uri.path->ptr,
-											  con->uri.path->used - 1,
-											  SQLITE_TRANSIENT);
+										CONST_BUF_LEN(con->uri.path),
+										SQLITE_TRANSIENT);
 									sqlite3_bind_text(stmt, 2,
-											  (char *)prop->name,
-											  strlen((char *)prop->name),
-											  SQLITE_TRANSIENT);
+										(char *)prop->name,
+										strlen((char *)prop->name),
+										SQLITE_TRANSIENT);
 									if (prop->ns) {
 										sqlite3_bind_text(stmt, 3,
-												  (char *)prop->ns->href,
-												  strlen((char *)prop->ns->href),
-												  SQLITE_TRANSIENT);
+											(char *)prop->ns->href,
+											strlen((char *)prop->ns->href),
+											SQLITE_TRANSIENT);
 									} else {
 										sqlite3_bind_text(stmt, 3,
-												  "",
-												  0,
-												  SQLITE_TRANSIENT);
+											"",
+											0,
+											SQLITE_TRANSIENT);
 									}
 									if (stmt == p->conf.stmt_update_prop) {
 										sqlite3_bind_text(stmt, 4,
-											  (char *)xmlNodeGetContent(prop),
-											  strlen((char *)xmlNodeGetContent(prop)),
-											  SQLITE_TRANSIENT);
+											(char *)xmlNodeGetContent(prop),
+											strlen((char *)xmlNodeGetContent(prop)),
+											SQLITE_TRANSIENT);
 									}
 
 									if (SQLITE_DONE != (r = sqlite3_step(stmt))) {
@@ -2235,7 +2227,7 @@
 			if (1 == webdav_parse_chunkqueue(srv, con, p, con->request_content_queue, &xml)) {
 				xmlNode *rootnode = xmlDocGetRootElement(xml);
 
-				assert(rootnode);
+				force_assert(rootnode);
 
 				if (0 == xmlStrcmp(rootnode->name, BAD_CAST "lockinfo")) {
 					xmlNode *lockinfo;
@@ -2286,9 +2278,8 @@
 							sqlite3_reset(stmt);
 
 							sqlite3_bind_text(stmt, 1,
-									  p->uri.path->ptr,
-									  p->uri.path->used - 1,
-									  SQLITE_TRANSIENT);
+								CONST_BUF_LEN(p->uri.path),
+								SQLITE_TRANSIENT);
 
 							/* it is the PK */
 							while (SQLITE_ROW == sqlite3_step(stmt)) {
@@ -2335,32 +2326,32 @@
 							sqlite3_reset(stmt);
 
 							sqlite3_bind_text(stmt, 1,
-									  CONST_BUF_LEN(p->tmp_buf),
-									  SQLITE_TRANSIENT);
+									CONST_BUF_LEN(p->tmp_buf),
+									SQLITE_TRANSIENT);
 
 							sqlite3_bind_text(stmt, 2,
-									  CONST_BUF_LEN(con->uri.path),
-									  SQLITE_TRANSIENT);
+									CONST_BUF_LEN(con->uri.path),
+									SQLITE_TRANSIENT);
 
 							sqlite3_bind_text(stmt, 3,
-									  (const char *)lockscope,
-									  xmlStrlen(lockscope),
-									  SQLITE_TRANSIENT);
+									(const char *)lockscope,
+									xmlStrlen(lockscope),
+									SQLITE_TRANSIENT);
 
 							sqlite3_bind_text(stmt, 4,
-									  (const char *)locktype,
-									  xmlStrlen(locktype),
-									  SQLITE_TRANSIENT);
+									(const char *)locktype,
+									xmlStrlen(locktype),
+									SQLITE_TRANSIENT);
 
 							/* owner */
 							sqlite3_bind_text(stmt, 5,
-									  "",
-									  0,
-									  SQLITE_TRANSIENT);
+									"",
+									0,
+									SQLITE_TRANSIENT);
 
 							/* depth */
 							sqlite3_bind_int(stmt, 6,
-									 depth);
+									depth);
 
 
 							if (SQLITE_DONE != sqlite3_step(stmt)) {
@@ -2390,19 +2381,19 @@
 				sqlite3_stmt *stmt = p->conf.stmt_refresh_lock;
 
 				/* remove the < > around the token */
-				if (locktoken->used < 6) {
+				if (buffer_string_length(locktoken) < 5) {
 					con->http_status = 400;
 
 					return HANDLER_FINISHED;
 				}
 
-				buffer_copy_string_len(p->tmp_buf, locktoken->ptr + 2, locktoken->used - 5);
+				buffer_copy_string_len(p->tmp_buf, locktoken->ptr + 2, buffer_string_length(locktoken) - 4);
 
 				sqlite3_reset(stmt);
 
 				sqlite3_bind_text(stmt, 1,
-					  CONST_BUF_LEN(p->tmp_buf),
-					  SQLITE_TRANSIENT);
+					CONST_BUF_LEN(p->tmp_buf),
+					SQLITE_TRANSIENT);
 
 				if (SQLITE_DONE != sqlite3_step(stmt)) {
 					log_error_write(srv, __FILE__, __LINE__, "ss",
@@ -2433,7 +2424,7 @@
 			sqlite3_stmt *stmt = p->conf.stmt_remove_lock;
 
 			/* remove the < > around the token */
-			if (locktoken->used < 4) {
+			if (buffer_string_length(locktoken) < 3) {
 				con->http_status = 400;
 
 				return HANDLER_FINISHED;
@@ -2449,17 +2440,17 @@
 			 * - 412
 			 *  */
 
-			buffer_copy_string_len(p->tmp_buf, locktoken->ptr + 1, locktoken->used - 3);
+			buffer_copy_string_len(p->tmp_buf, locktoken->ptr + 1, buffer_string_length(locktoken) - 2);
 
 			sqlite3_reset(stmt);
 
 			sqlite3_bind_text(stmt, 1,
-				  CONST_BUF_LEN(p->tmp_buf),
-				  SQLITE_TRANSIENT);
+				CONST_BUF_LEN(p->tmp_buf),
+				SQLITE_TRANSIENT);
 
 			sqlite3_bind_text(stmt, 2,
-				  CONST_BUF_LEN(con->uri.path),
-				  SQLITE_TRANSIENT);
+				CONST_BUF_LEN(con->uri.path),
+				SQLITE_TRANSIENT);
 
 			if (SQLITE_DONE != sqlite3_step(stmt)) {
 				log_error_write(srv, __FILE__, __LINE__, "ss",
diff -u lighttpd-1.4.32/src/network.c lighttpd-1.4.36/src/network.c
--- lighttpd-1.4.32/src/network.c	2012-11-08 05:52:51.000000000 -0600
+++ lighttpd-1.4.36/src/network.c	2015-07-26 05:36:36.000000000 -0500
@@ -25,7 +25,9 @@
 # include <openssl/ssl.h>
 # include <openssl/err.h>
 # include <openssl/rand.h>
-# include <openssl/dh.h>
+# ifndef OPENSSL_NO_DH
+#  include <openssl/dh.h>
+# endif
 # include <openssl/bn.h>
 
 # if OPENSSL_VERSION_NUMBER >= 0x0090800fL
@@ -42,8 +44,6 @@
 	if (0 != (where & SSL_CB_HANDSHAKE_START)) {
 		connection *con = SSL_get_app_data(ssl);
 		++con->renegotiations;
-	} else if (0 != (where & SSL_CB_HANDSHAKE_DONE)) {
-		ssl->s3->flags |= SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS;
 	}
 }
 #endif
@@ -112,20 +112,46 @@
 	config_patch_connection(srv, con, COMP_HTTP_SCHEME);
 	config_patch_connection(srv, con, COMP_HTTP_HOST);
 
-	if (NULL == con->conf.ssl_ctx) {
-		/* ssl_ctx <=> pemfile was set <=> ssl_ctx got patched: so this should never happen */
+	if (NULL == con->conf.ssl_pemfile_x509 || NULL == con->conf.ssl_pemfile_pkey) {
+		/* x509/pkey available <=> pemfile was set <=> pemfile got patched: so this should never happen, unless you nest $SERVER["socket"] */
 		log_error_write(srv, __FILE__, __LINE__, "ssb", "SSL:",
-			"null SSL_CTX for TLS server name", con->tlsext_server_name);
+			"no certificate/private key for TLS server name", con->tlsext_server_name);
 		return SSL_TLSEXT_ERR_ALERT_FATAL;
 	}
 
-	/* switch to new SSL_CTX in reaction to a client's server_name extension */
-	if (con->conf.ssl_ctx != SSL_set_SSL_CTX(ssl, con->conf.ssl_ctx)) {
-		log_error_write(srv, __FILE__, __LINE__, "ssb", "SSL:",
-			"failed to set SSL_CTX for TLS server name", con->tlsext_server_name);
+	/* first set certificate! setting private key checks whether certificate matches it */
+	if (!SSL_use_certificate(ssl, con->conf.ssl_pemfile_x509)) {
+		log_error_write(srv, __FILE__, __LINE__, "ssb:s", "SSL:",
+			"failed to set certificate for TLS server name", con->tlsext_server_name,
+			ERR_error_string(ERR_get_error(), NULL));
+		return SSL_TLSEXT_ERR_ALERT_FATAL;
+	}
+
+	if (!SSL_use_PrivateKey(ssl, con->conf.ssl_pemfile_pkey)) {
+		log_error_write(srv, __FILE__, __LINE__, "ssb:s", "SSL:",
+			"failed to set private key for TLS server name", con->tlsext_server_name,
+			ERR_error_string(ERR_get_error(), NULL));
 		return SSL_TLSEXT_ERR_ALERT_FATAL;
 	}
 
+	if (con->conf.ssl_verifyclient) {
+		if (NULL == con->conf.ssl_ca_file_cert_names) {
+			log_error_write(srv, __FILE__, __LINE__, "ssb:s", "SSL:",
+				"can't verify client without ssl.ca-file for TLS server name", con->tlsext_server_name,
+				ERR_error_string(ERR_get_error(), NULL));
+			return SSL_TLSEXT_ERR_ALERT_FATAL;
+		}
+
+		SSL_set_client_CA_list(ssl, SSL_dup_CA_list(con->conf.ssl_ca_file_cert_names));
+		/* forcing verification here is really not that useful - a client could just connect without SNI */
+		SSL_set_verify(
+			ssl,
+			SSL_VERIFY_PEER | (con->conf.ssl_verifyclient_enforce ? SSL_VERIFY_FAIL_IF_NO_PEER_CERT : 0),
+			NULL
+		);
+		SSL_set_verify_depth(ssl, con->conf.ssl_verifyclient_depth);
+	}
+
 	return SSL_TLSEXT_ERR_OK;
 }
 #endif
@@ -161,10 +187,10 @@
 	srv_socket->fde_ndx = -1;
 
 	srv_socket->srv_token = buffer_init();
-	buffer_copy_string_buffer(srv_socket->srv_token, host_token);
+	buffer_copy_buffer(srv_socket->srv_token, host_token);
 
 	b = buffer_init();
-	buffer_copy_string_buffer(b, host_token);
+	buffer_copy_buffer(b, host_token);
 
 	/* ipv4:port
 	 * [ipv6]:port
@@ -224,7 +250,6 @@
 			log_error_write(srv, __FILE__, __LINE__, "ss", "socket failed:", strerror(errno));
 			goto error_free_socket;
 		}
-		srv_socket->use_ipv6 = 1;
 	}
 #endif
 
@@ -236,10 +261,8 @@
 		}
 	}
 
-#ifdef FD_CLOEXEC
 	/* set FD_CLOEXEC now, fdevent_fcntl_set is called later; needed for pipe-logger forks */
-	fcntl(srv_socket->fd, F_SETFD, FD_CLOEXEC);
-#endif
+	fd_close_on_exec(srv_socket->fd);
 
 	/* */
 	srv->cur_fds = srv_socket->fd;
@@ -326,15 +349,23 @@
 
 		break;
 	case AF_UNIX:
+		memset(&srv_socket->addr, 0, sizeof(struct sockaddr_un));
 		srv_socket->addr.un.sun_family = AF_UNIX;
-		strcpy(srv_socket->addr.un.sun_path, host);
+		{
+			size_t hostlen = strlen(host) + 1;
+			if (hostlen > sizeof(srv_socket->addr.un.sun_path)) {
+				log_error_write(srv, __FILE__, __LINE__, "sS", "unix socket filename too long:", host);
+				goto error_free_socket;
+			}
+			memcpy(srv_socket->addr.un.sun_path, host, hostlen);
 
-#ifdef SUN_LEN
-		addr_len = SUN_LEN(&srv_socket->addr.un);
+#if defined(SUN_LEN)
+			addr_len = SUN_LEN(&srv_socket->addr.un);
 #else
-		/* stevens says: */
-		addr_len = strlen(host) + 1 + sizeof(srv_socket->addr.un.sun_family);
+			/* stevens says: */
+			addr_len = hostlen + sizeof(srv_socket->addr.un.sun_family);
 #endif
+		}
 
 		/* check if the socket exists and try to connect to it. */
 		if (-1 != (fd = connect(srv_socket->fd, (struct sockaddr *) &(srv_socket->addr), addr_len))) {
@@ -389,7 +420,7 @@
 		goto error_free_socket;
 	}
 
-	if (s->is_ssl) {
+	if (s->ssl_enabled) {
 #ifdef USE_OPENSSL
 		if (NULL == (srv_socket->ssl_ctx = s->ssl_ctx)) {
 			log_error_write(srv, __FILE__, __LINE__, "s", "ssl.pemfile has to be set");
@@ -423,15 +454,15 @@
 #endif
 	}
 
-	srv_socket->is_ssl = s->is_ssl;
+	srv_socket->is_ssl = s->ssl_enabled;
 
 	if (srv->srv_sockets.size == 0) {
 		srv->srv_sockets.size = 4;
 		srv->srv_sockets.used = 0;
-		srv->srv_sockets.ptr = malloc(srv->srv_sockets.size * sizeof(server_socket));
+		srv->srv_sockets.ptr = malloc(srv->srv_sockets.size * sizeof(server_socket*));
 	} else if (srv->srv_sockets.used == srv->srv_sockets.size) {
 		srv->srv_sockets.size += 4;
-		srv->srv_sockets.ptr = realloc(srv->srv_sockets.ptr, srv->srv_sockets.size * sizeof(server_socket));
+		srv->srv_sockets.ptr = realloc(srv->srv_sockets.ptr, srv->srv_sockets.size * sizeof(server_socket*));
 	}
 
 	srv->srv_sockets.ptr[srv->srv_sockets.used++] = srv_socket;
@@ -492,9 +523,98 @@
 	NETWORK_BACKEND_SOLARIS_SENDFILEV
 } network_backend_t;
 
+#ifdef USE_OPENSSL
+static X509* x509_load_pem_file(server *srv, const char *file) {
+	BIO *in;
+	X509 *x = NULL;
+
+	in = BIO_new(BIO_s_file());
+	if (NULL == in) {
+		log_error_write(srv, __FILE__, __LINE__, "S", "SSL: BIO_new(BIO_s_file()) failed");
+		goto error;
+	}
+
+	if (BIO_read_filename(in,file) <= 0) {
+		log_error_write(srv, __FILE__, __LINE__, "SSS", "SSL: BIO_read_filename('", file,"') failed");
+		goto error;
+	}
+	x = PEM_read_bio_X509(in, NULL, NULL, NULL);
+
+	if (NULL == x) {
+		log_error_write(srv, __FILE__, __LINE__, "SSS", "SSL: couldn't read X509 certificate from '", file,"'");
+		goto error;
+	}
+
+	BIO_free(in);
+	return x;
+
+error:
+	if (NULL != in) BIO_free(in);
+	return NULL;
+}
+
+static EVP_PKEY* evp_pkey_load_pem_file(server *srv, const char *file) {
+	BIO *in;
+	EVP_PKEY *x = NULL;
+
+	in=BIO_new(BIO_s_file());
+	if (NULL == in) {
+		log_error_write(srv, __FILE__, __LINE__, "s", "SSL: BIO_new(BIO_s_file()) failed");
+		goto error;
+	}
+
+	if (BIO_read_filename(in,file) <= 0) {
+		log_error_write(srv, __FILE__, __LINE__, "SSS", "SSL: BIO_read_filename('", file,"') failed");
+		goto error;
+	}
+	x = PEM_read_bio_PrivateKey(in, NULL, NULL, NULL);
+
+	if (NULL == x) {
+		log_error_write(srv, __FILE__, __LINE__, "SSS", "SSL: couldn't read private key from '", file,"'");
+		goto error;
+	}
+
+	BIO_free(in);
+	return x;
+
+error:
+	if (NULL != in) BIO_free(in);
+	return NULL;
+}
+
+static int network_openssl_load_pemfile(server *srv, size_t ndx) {
+	specific_config *s = srv->config_storage[ndx];
+
+#ifdef OPENSSL_NO_TLSEXT
+	{
+		data_config *dc = (data_config *)srv->config_context->data[ndx];
+		if ((ndx > 0 && (COMP_SERVER_SOCKET != dc->comp || dc->cond != CONFIG_COND_EQ))
+			|| !s->ssl_enabled) {
+			log_error_write(srv, __FILE__, __LINE__, "ss", "SSL:",
+					"ssl.pemfile only works in SSL socket binding context as openssl version does not support TLS extensions");
+			return -1;
+		}
+	}
+#endif
+
+	if (NULL == (s->ssl_pemfile_x509 = x509_load_pem_file(srv, s->ssl_pemfile->ptr))) return -1;
+	if (NULL == (s->ssl_pemfile_pkey = evp_pkey_load_pem_file(srv, s->ssl_pemfile->ptr))) return -1;
+
+	if (!X509_check_private_key(s->ssl_pemfile_x509, s->ssl_pemfile_pkey)) {
+		log_error_write(srv, __FILE__, __LINE__, "sssb", "SSL:",
+				"Private key does not match the certificate public key, reason:",
+				ERR_error_string(ERR_get_error(), NULL),
+				s->ssl_pemfile);
+		return -1;
+	}
+
+	return 0;
+}
+#endif
+
 int network_init(server *srv) {
 	buffer *b;
-	size_t i;
+	size_t i, j;
 	network_backend_t backend;
 
 #if OPENSSL_VERSION_NUMBER >= 0x0090800fL
@@ -505,7 +625,9 @@
 #endif
 
 #ifdef USE_OPENSSL
+# ifndef OPENSSL_NO_DH
 	DH *dh;
+# endif
 	BIO *bio;
 
        /* 1024-bit MODP Group with 160-bit prime order subgroup (RFC5114)
@@ -579,18 +701,7 @@
 		long ssloptions =
 			SSL_OP_ALL | SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION | SSL_OP_NO_COMPRESSION;
 
-		if (buffer_is_empty(s->ssl_pemfile)) continue;
-
-#ifdef OPENSSL_NO_TLSEXT
-		{
-			data_config *dc = (data_config *)srv->config_context->data[i];
-			if (COMP_HTTP_HOST == dc->comp) {
-			    log_error_write(srv, __FILE__, __LINE__, "ss", "SSL:",
-					    "can't use ssl.pemfile with $HTTP[\"host\"], openssl version does not support TLS extensions");
-			    return -1;
-			}
-		}
-#endif
+		if (buffer_string_is_empty(s->ssl_pemfile) && buffer_string_is_empty(s->ssl_ca_file)) continue;
 
 		if (srv->ssl_is_init == 0) {
 			SSL_load_error_strings();
@@ -605,12 +716,53 @@
 			}
 		}
 
+		if (!buffer_string_is_empty(s->ssl_pemfile)) {
+#ifdef OPENSSL_NO_TLSEXT
+			data_config *dc = (data_config *)srv->config_context->data[i];
+			if (COMP_HTTP_HOST == dc->comp) {
+				log_error_write(srv, __FILE__, __LINE__, "ss", "SSL:",
+						"can't use ssl.pemfile with $HTTP[\"host\"], openssl version does not support TLS extensions");
+				return -1;
+			}
+#endif
+			if (network_openssl_load_pemfile(srv, i)) return -1;
+		}
+
+
+		if (!buffer_string_is_empty(s->ssl_ca_file)) {
+			s->ssl_ca_file_cert_names = SSL_load_client_CA_file(s->ssl_ca_file->ptr);
+			if (NULL == s->ssl_ca_file_cert_names) {
+				log_error_write(srv, __FILE__, __LINE__, "ssb", "SSL:",
+						ERR_error_string(ERR_get_error(), NULL), s->ssl_ca_file);
+			}
+		}
+
+		if (buffer_string_is_empty(s->ssl_pemfile) || !s->ssl_enabled) continue;
+
 		if (NULL == (s->ssl_ctx = SSL_CTX_new(SSLv23_server_method()))) {
 			log_error_write(srv, __FILE__, __LINE__, "ss", "SSL:",
 					ERR_error_string(ERR_get_error(), NULL));
 			return -1;
 		}
 
+		/* completely useless identifier; required for client cert verification to work with sessions */
+		if (0 == SSL_CTX_set_session_id_context(s->ssl_ctx, (const unsigned char*) CONST_STR_LEN("lighttpd"))) {
+			log_error_write(srv, __FILE__, __LINE__, "ss:s", "SSL:",
+				"failed to set session context",
+				ERR_error_string(ERR_get_error(), NULL));
+			return -1;
+		}
+
+		if (s->ssl_empty_fragments) {
+#ifdef SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
+			ssloptions &= ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;
+#else
+			ssloptions &= ~0x00000800L; /* hardcode constant */
+			log_error_write(srv, __FILE__, __LINE__, "ss", "WARNING: SSL:",
+					"'insert empty fragments' not supported by the openssl version used to compile lighttpd with");
+#endif
+		}
+
 		SSL_CTX_set_options(s->ssl_ctx, ssloptions);
 		SSL_CTX_set_info_callback(s->ssl_ctx, ssl_info_callback);
 
@@ -632,7 +784,7 @@
 			}
 		}
 
-		if (!buffer_is_empty(s->ssl_cipher_list)) {
+		if (!buffer_string_is_empty(s->ssl_cipher_list)) {
 			/* Disable support for low encryption ciphers */
 			if (SSL_CTX_set_cipher_list(s->ssl_ctx, s->ssl_cipher_list->ptr) != 1) {
 				log_error_write(srv, __FILE__, __LINE__, "ss", "SSL:",
@@ -645,8 +797,9 @@
 			}
 		}
 
+#ifndef OPENSSL_NO_DH
 		/* Support for Diffie-Hellman key exchange */
-		if (!buffer_is_empty(s->ssl_dh_file)) {
+		if (!buffer_string_is_empty(s->ssl_dh_file)) {
 			/* DH parameters from file */
 			bio = BIO_new_file((char *) s->ssl_dh_file->ptr, "r");
 			if (bio == NULL) {
@@ -678,11 +831,16 @@
 		SSL_CTX_set_tmp_dh(s->ssl_ctx,dh);
 		SSL_CTX_set_options(s->ssl_ctx,SSL_OP_SINGLE_DH_USE);
 		DH_free(dh);
+#else
+		if (!buffer_string_is_empty(s->ssl_dh_file)) {
+			log_error_write(srv, __FILE__, __LINE__, "ss", "SSL: openssl compiled without DH support, can't load parameters from", s->ssl_dh_file->ptr);
+		}
+#endif
 
 #if OPENSSL_VERSION_NUMBER >= 0x0090800fL
 #ifndef OPENSSL_NO_ECDH
 		/* Support for Elliptic-Curve Diffie-Hellman key exchange */
-		if (!buffer_is_empty(s->ssl_ec_curve)) {
+		if (!buffer_string_is_empty(s->ssl_ec_curve)) {
 			/* OpenSSL only supports the "named curves" from RFC 4492, section 5.1.1. */
 			nid = OBJ_sn2nid((char *) s->ssl_ec_curve->ptr);
 			if (nid == 0) {
@@ -704,45 +862,42 @@
 #endif
 #endif
 
-		if (!buffer_is_empty(s->ssl_ca_file)) {
-			if (1 != SSL_CTX_load_verify_locations(s->ssl_ctx, s->ssl_ca_file->ptr, NULL)) {
-				log_error_write(srv, __FILE__, __LINE__, "ssb", "SSL:",
-						ERR_error_string(ERR_get_error(), NULL), s->ssl_ca_file);
-				return -1;
-			}
-			if (s->ssl_verifyclient) {
-				STACK_OF(X509_NAME) *certs = SSL_load_client_CA_file(s->ssl_ca_file->ptr);
-				if (!certs) {
+		/* load all ssl.ca-files specified in the config into each SSL_CTX to be prepared for SNI */
+		for (j = 0; j < srv->config_context->used; j++) {
+			specific_config *s1 = srv->config_storage[j];
+
+			if (!buffer_string_is_empty(s1->ssl_ca_file)) {
+				if (1 != SSL_CTX_load_verify_locations(s->ssl_ctx, s1->ssl_ca_file->ptr, NULL)) {
 					log_error_write(srv, __FILE__, __LINE__, "ssb", "SSL:",
-							ERR_error_string(ERR_get_error(), NULL), s->ssl_ca_file);
-				}
-				if (SSL_CTX_set_session_id_context(s->ssl_ctx, (void*) &srv, sizeof(srv)) != 1) {
-					log_error_write(srv, __FILE__, __LINE__, "ss", "SSL:",
-						ERR_error_string(ERR_get_error(), NULL));
+							ERR_error_string(ERR_get_error(), NULL), s1->ssl_ca_file);
 					return -1;
 				}
-				SSL_CTX_set_client_CA_list(s->ssl_ctx, certs);
-				SSL_CTX_set_verify(
-					s->ssl_ctx,
-					SSL_VERIFY_PEER | (s->ssl_verifyclient_enforce ? SSL_VERIFY_FAIL_IF_NO_PEER_CERT : 0),
-					NULL
+			}
+		}
+
+		if (s->ssl_verifyclient) {
+			if (NULL == s->ssl_ca_file_cert_names) {
+				log_error_write(srv, __FILE__, __LINE__, "s",
+					"SSL: You specified ssl.verifyclient.activate but no ca_file"
 				);
-				SSL_CTX_set_verify_depth(s->ssl_ctx, s->ssl_verifyclient_depth);
+				return -1;
 			}
-		} else if (s->ssl_verifyclient) {
-			log_error_write(
-				srv, __FILE__, __LINE__, "s",
-				"SSL: You specified ssl.verifyclient.activate but no ca_file"
+			SSL_CTX_set_client_CA_list(s->ssl_ctx, SSL_dup_CA_list(s->ssl_ca_file_cert_names));
+			SSL_CTX_set_verify(
+				s->ssl_ctx,
+				SSL_VERIFY_PEER | (s->ssl_verifyclient_enforce ? SSL_VERIFY_FAIL_IF_NO_PEER_CERT : 0),
+				NULL
 			);
+			SSL_CTX_set_verify_depth(s->ssl_ctx, s->ssl_verifyclient_depth);
 		}
 
-		if (SSL_CTX_use_certificate_file(s->ssl_ctx, s->ssl_pemfile->ptr, SSL_FILETYPE_PEM) < 0) {
+		if (SSL_CTX_use_certificate(s->ssl_ctx, s->ssl_pemfile_x509) < 0) {
 			log_error_write(srv, __FILE__, __LINE__, "ssb", "SSL:",
 					ERR_error_string(ERR_get_error(), NULL), s->ssl_pemfile);
 			return -1;
 		}
 
-		if (SSL_CTX_use_PrivateKey_file (s->ssl_ctx, s->ssl_pemfile->ptr, SSL_FILETYPE_PEM) < 0) {
+		if (SSL_CTX_use_PrivateKey(s->ssl_ctx, s->ssl_pemfile_pkey) < 0) {
 			log_error_write(srv, __FILE__, __LINE__, "ssb", "SSL:",
 					ERR_error_string(ERR_get_error(), NULL), s->ssl_pemfile);
 			return -1;
@@ -771,11 +926,12 @@
 
 	b = buffer_init();
 
-	buffer_copy_string_buffer(b, srv->srvconf.bindhost);
+	buffer_copy_buffer(b, srv->srvconf.bindhost);
 	buffer_append_string_len(b, CONST_STR_LEN(":"));
-	buffer_append_long(b, srv->srvconf.port);
+	buffer_append_int(b, srv->srvconf.port);
 
 	if (0 != network_server_init(srv, b, srv->config_storage[0])) {
+		buffer_free(b);
 		return -1;
 	}
 	buffer_free(b);
@@ -788,7 +944,7 @@
 	backend = network_backends[0].nb;
 
 	/* match name against known types */
-	if (!buffer_is_empty(srv->srvconf.network_backend)) {
+	if (!buffer_string_is_empty(srv->srvconf.network_backend)) {
 		for (i = 0; network_backends[i].name; i++) {
 			/**/
 			if (buffer_is_equal_string(srv->srvconf.network_backend, network_backends[i].name, strlen(network_backends[i].name))) {
@@ -839,7 +995,6 @@
 	for (i = 1; i < srv->config_context->used; i++) {
 		data_config *dc = (data_config *)srv->config_context->data[i];
 		specific_config *s = srv->config_storage[i];
-		size_t j;
 
 		/* not our stage */
 		if (COMP_SERVER_SOCKET != dc->comp) continue;
diff -u lighttpd-1.4.32/src/network_freebsd_sendfile.c lighttpd-1.4.36/src/network_freebsd_sendfile.c
--- lighttpd-1.4.32/src/network_freebsd_sendfile.c	2011-08-20 08:32:49.000000000 -0500
+++ lighttpd-1.4.36/src/network_freebsd_sendfile.c	2015-07-26 05:36:36.000000000 -0500
@@ -151,9 +151,7 @@
 					return -1;
 				}
 
-#ifdef FD_CLOEXEC
-				fcntl(c->file.fd, F_SETFD, FD_CLOEXEC);
-#endif
+				fd_close_on_exec(c->file.fd);
 			}
 
 			r = 0;
diff -u lighttpd-1.4.32/src/network_linux_sendfile.c lighttpd-1.4.36/src/network_linux_sendfile.c
--- lighttpd-1.4.32/src/network_linux_sendfile.c	2011-08-20 08:33:01.000000000 -0500
+++ lighttpd-1.4.36/src/network_linux_sendfile.c	2015-07-26 05:36:36.000000000 -0500
@@ -54,12 +54,12 @@
 			     tc = tc->next, num_chunks++);
 
 			for (tc = c, i = 0; i < num_chunks; tc = tc->next, i++) {
-				if (tc->mem->used == 0) {
+				if (buffer_string_is_empty(tc->mem)) {
 					chunks[i].iov_base = tc->mem->ptr;
 					chunks[i].iov_len  = 0;
 				} else {
 					offset = tc->mem->ptr + tc->offset;
-					toSend = tc->mem->used - 1 - tc->offset;
+					toSend = buffer_string_length(tc->mem) - tc->offset;
 
 					chunks[i].iov_base = offset;
 
@@ -141,9 +141,7 @@
 
 					return -1;
 				}
-#ifdef FD_CLOEXEC
-				fcntl(c->file.fd, F_SETFD, FD_CLOEXEC);
-#endif
+				fd_close_on_exec(c->file.fd);
 #ifdef HAVE_POSIX_FADVISE
 				/* tell the kernel that we want to stream the file */
 				if (-1 == posix_fadvise(c->file.fd, 0, 0, POSIX_FADV_SEQUENTIAL)) {
diff -u lighttpd-1.4.32/src/network_openssl.c lighttpd-1.4.36/src/network_openssl.c
--- lighttpd-1.4.32/src/network_openssl.c	2011-12-05 11:03:27.000000000 -0600
+++ lighttpd-1.4.36/src/network_openssl.c	2015-07-26 05:36:36.000000000 -0500
@@ -67,13 +67,13 @@
 			off_t toSend;
 			ssize_t r;
 
-			if (c->mem->used == 0 || c->mem->used == 1) {
+			if (buffer_string_is_empty(c->mem)) {
 				chunk_finished = 1;
 				break;
 			}
 
 			offset = c->mem->ptr + c->offset;
-			toSend = c->mem->used - 1 - c->offset;
+			toSend = buffer_string_length(c->mem) - c->offset;
 			if (toSend > max_bytes) toSend = max_bytes;
 
 			/**
@@ -90,7 +90,7 @@
 			r = SSL_write(ssl, offset, toSend);
 
 			if (con->renegotiations > 1 && con->conf.ssl_disable_client_renegotiation) {
-				log_error_write(srv, __FILE__, __LINE__, "s", "SSL: renegotiation initiated by client");
+				log_error_write(srv, __FILE__, __LINE__, "s", "SSL: renegotiation initiated by client, killing connection");
 				return -1;
 			}
 
@@ -149,7 +149,7 @@
 				max_bytes -= r;
 			}
 
-			if (c->offset == (off_t)c->mem->used - 1) {
+			if (c->offset == (off_t)buffer_string_length(c->mem)) {
 				chunk_finished = 1;
 			}
 
@@ -170,7 +170,7 @@
 
 			if (NULL == local_send_buffer) {
 				local_send_buffer = malloc(LOCAL_SEND_BUFSIZE);
-				assert(local_send_buffer);
+				force_assert(local_send_buffer);
 			}
 
 			do {
@@ -187,10 +187,14 @@
 				}
 
 
-				lseek(ifd, offset, SEEK_SET);
-				if (-1 == (toSend = read(ifd, local_send_buffer, toSend))) {
+				if (-1 == lseek(ifd, offset, SEEK_SET)) {
+					log_error_write(srv, __FILE__, __LINE__, "ss", "lseek failed:", strerror(errno));
 					close(ifd);
+					return -1;
+				}
+				if (-1 == (toSend = read(ifd, local_send_buffer, toSend))) {
 					log_error_write(srv, __FILE__, __LINE__, "ss", "read failed:", strerror(errno));
+					close(ifd);
 					return -1;
 				}
 
@@ -202,7 +206,7 @@
 				r = SSL_write(ssl, s, toSend);
 
 				if (con->renegotiations > 1 && con->conf.ssl_disable_client_renegotiation) {
-					log_error_write(srv, __FILE__, __LINE__, "s", "SSL: renegotiation initiated by client");
+					log_error_write(srv, __FILE__, __LINE__, "s", "SSL: renegotiation initiated by client, killing connection");
 					return -1;
 				}
 
diff -u lighttpd-1.4.32/src/network_write.c lighttpd-1.4.36/src/network_write.c
--- lighttpd-1.4.32/src/network_write.c	2011-08-20 08:30:11.000000000 -0500
+++ lighttpd-1.4.36/src/network_write.c	2015-07-26 05:36:36.000000000 -0500
@@ -36,13 +36,13 @@
 			off_t toSend;
 			ssize_t r;
 
-			if (c->mem->used == 0) {
+			if (buffer_string_is_empty(c->mem)) {
 				chunk_finished = 1;
 				break;
 			}
 
 			offset = c->mem->ptr + c->offset;
-			toSend = c->mem->used - 1 - c->offset;
+			toSend = buffer_string_length(c->mem) - c->offset;
 			if (toSend > max_bytes) toSend = max_bytes;
 
 #ifdef __WIN32
@@ -75,7 +75,7 @@
 			cq->bytes_out += r;
 			max_bytes -= r;
 
-			if (c->offset == (off_t)c->mem->used - 1) {
+			if (c->offset == (off_t)buffer_string_length(c->mem)) {
 				chunk_finished = 1;
 			}
 
@@ -145,13 +145,16 @@
 
 			munmap(p, sce->st.st_size);
 #else /* USE_MMAP */
-			buffer_prepare_copy(srv->tmp_buf, toSend);
+			buffer_string_prepare_copy(srv->tmp_buf, toSend);
 
-			lseek(ifd, offset, SEEK_SET);
+			if (-1 == lseek(ifd, offset, SEEK_SET)) {
+				log_error_write(srv, __FILE__, __LINE__, "ss", "lseek: ", strerror(errno));
+				close(ifd);
+				return -1;
+			}
 			if (-1 == (toSend = read(ifd, srv->tmp_buf->ptr, toSend))) {
 				log_error_write(srv, __FILE__, __LINE__, "ss", "read: ", strerror(errno));
 				close(ifd);
-
 				return -1;
 			}
 			close(ifd);
diff -u lighttpd-1.4.32/src/network_writev.c lighttpd-1.4.36/src/network_writev.c
--- lighttpd-1.4.32/src/network_writev.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.36/src/network_writev.c	2015-07-26 05:36:36.000000000 -0500
@@ -30,6 +30,18 @@
 #define LOCAL_BUFFERING 1
 #endif
 
+#if defined(UIO_MAXIOV)
+# define MAX_CHUNKS UIO_MAXIOV
+#elif defined(IOV_MAX)
+/* new name for UIO_MAXIOV since IEEE Std 1003.1-2001 */
+# define MAX_CHUNKS IOV_MAX
+#elif defined(_XOPEN_IOV_MAX)
+/* minimum value for sysconf(_SC_IOV_MAX); posix requires this to be at least 16, which is good enough - no need to call sysconf() */
+# define MAX_CHUNKS _XOPEN_IOV_MAX
+#else
+# error neither UIO_MAXIOV nor IOV_MAX nor _XOPEN_IOV_MAX are defined
+#endif
+
 int network_write_chunkqueue_writev(server *srv, connection *con, int fd, chunkqueue *cq, off_t max_bytes) {
 	chunk *c;
 
@@ -46,40 +58,23 @@
 			struct iovec *chunks;
 			chunk *tc;
 			size_t num_bytes = 0;
-#if defined(_SC_IOV_MAX) /* IRIX, MacOS X, FreeBSD, Solaris, ... */
-			const size_t max_chunks = sysconf(_SC_IOV_MAX);
-#elif defined(IOV_MAX) /* Linux x86 (glibc-2.3.6-3) */
-			const size_t max_chunks = IOV_MAX;
-#elif defined(MAX_IOVEC) /* Linux ia64 (glibc-2.3.3-98.28) */
-			const size_t max_chunks = MAX_IOVEC;
-#elif defined(UIO_MAXIOV) /* Linux x86 (glibc-2.2.5-233) */
-			const size_t max_chunks = UIO_MAXIOV;
-#elif (defined(__FreeBSD__) && __FreeBSD_version < 500000) || defined(__DragonFly__) || defined(__APPLE__) 
-			/* - FreeBSD 4.x
-			 * - MacOS X 10.3.x
-			 *   (covered in -DKERNEL)
-			 *  */
-			const size_t max_chunks = 1024; /* UIO_MAXIOV value from sys/uio.h */
-#else
-#error "sysconf() doesnt return _SC_IOV_MAX ..., check the output of 'man writev' for the EINVAL error and send the output to jan@kneschke.de"
-#endif
 
 			/* build writev list
 			 *
-			 * 1. limit: num_chunks < max_chunks
+			 * 1. limit: num_chunks < MAX_CHUNKS
 			 * 2. limit: num_bytes < max_bytes
 			 */
-			for (num_chunks = 0, tc = c; tc && tc->type == MEM_CHUNK && num_chunks < max_chunks; num_chunks++, tc = tc->next);
+			for (num_chunks = 0, tc = c; tc && tc->type == MEM_CHUNK && num_chunks < MAX_CHUNKS; num_chunks++, tc = tc->next);
 
 			chunks = calloc(num_chunks, sizeof(*chunks));
 
 			for(tc = c, i = 0; i < num_chunks; tc = tc->next, i++) {
-				if (tc->mem->used == 0) {
+				if (buffer_string_is_empty(tc->mem)) {
 					chunks[i].iov_base = tc->mem->ptr;
 					chunks[i].iov_len  = 0;
 				} else {
 					offset = tc->mem->ptr + tc->offset;
-					toSend = tc->mem->used - 1 - tc->offset;
+					toSend = buffer_string_length(tc->mem) - tc->offset;
 
 					chunks[i].iov_base = offset;
 
@@ -235,14 +230,10 @@
 
 						return -1;
 					}
-#ifdef FD_CLOEXEC
-					fcntl(c->file.fd, F_SETFD, FD_CLOEXEC);
-#endif
+					fd_close_on_exec(c->file.fd);
 				}
 
 				if (MAP_FAILED == (c->file.mmap.start = mmap(NULL, to_mmap, PROT_READ, MAP_SHARED, c->file.fd, c->file.mmap.offset))) {
-					/* close it here, otherwise we'd have to set FD_CLOEXEC */
-
 					log_error_write(srv, __FILE__, __LINE__, "ssbd", "mmap failed:",
 							strerror(errno), c->file.name, c->file.fd);
 
@@ -278,7 +269,7 @@
 						c->file.mmap.length,
 						abs_offset,
 						c->file.mmap.offset);
-				assert(toSend < 0);
+				force_assert(toSend < 0);
 			}
 
 			if (toSend > max_bytes) toSend = max_bytes;
diff -u lighttpd-1.4.32/src/plugin.c lighttpd-1.4.36/src/plugin.c
--- lighttpd-1.4.32/src/plugin.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/plugin.c	2015-07-26 05:36:36.000000000 -0500
@@ -133,7 +133,7 @@
 			}
 		}
 
-		buffer_copy_string_buffer(srv->tmp_buf, srv->srvconf.modules_dir);
+		buffer_copy_buffer(srv->tmp_buf, srv->srvconf.modules_dir);
 
 		buffer_append_string_len(srv->tmp_buf, CONST_STR_LEN("/"));
 		buffer_append_string(srv->tmp_buf, modules);
diff -u lighttpd-1.4.32/src/proc_open.c lighttpd-1.4.36/src/proc_open.c
--- lighttpd-1.4.32/src/proc_open.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.36/src/proc_open.c	2015-07-26 05:36:36.000000000 -0500
@@ -280,13 +280,12 @@
 	ssize_t s;
 
 	for (;;) {
-		buffer_prepare_append(b, 512);
-		if ((s = read(fd, (void *)(b->ptr + b->used), 512 - 1)) <= 0) {
+		buffer_string_prepare_append(b, 1024);
+		if ((s = read(fd, (void *)(b->ptr + buffer_string_length(b)), buffer_string_space(b))) <= 0) {
 			break;
 		}
-		b->used += s;
+		buffer_commit(b, s);
 	}
-	b->ptr[b->used] = '\0';
 }
 /* }}} */
 /* {{{ proc_open_buffer */
@@ -298,7 +297,7 @@
 	}
 
 	if (in) {
-		if (write(proc.in.fd, (void *)in->ptr, in->used) < 0) {
+		if (write(proc.in.fd, CONST_BUF_LEN(in)) < 0) {
 			perror("error writing pipe");
 			return -1;
 		}
@@ -315,8 +314,9 @@
 	} else {
 		buffer *tmp = buffer_init();
 		proc_read_fd_to_buffer(proc.err.fd, tmp);
-		if (tmp->used > 0 &&  write(2, (void*)tmp->ptr, tmp->used) < 0) {
+		if (!buffer_string_is_empty(tmp) &&  write(2, CONST_BUF_LEN(tmp)) < 0) {
 			perror("error writing pipe");
+			buffer_free(tmp);
 			return -1;
 		}
 		buffer_free(tmp);
diff -u lighttpd-1.4.32/src/request.c lighttpd-1.4.36/src/request.c
--- lighttpd-1.4.32/src/request.c	2012-11-20 04:09:44.000000000 -0600
+++ lighttpd-1.4.36/src/request.c	2015-07-26 05:36:36.000000000 -0500
@@ -34,16 +34,16 @@
 	 */
 
 	/* no Host: */
-	if (!host || host->used == 0) return 0;
+	if (buffer_is_empty(host)) return 0;
 
-	host_len = host->used - 1;
+	host_len = buffer_string_length(host);
 
 	/* IPv6 adress */
 	if (host->ptr[0] == '[') {
 		char *c = host->ptr + 1;
 		int colon_cnt = 0;
 
-		/* check portnumber */
+		/* check the address inside [...] */
 		for (; *c && *c != ']'; c++) {
 			if (*c == ':') {
 				if (++colon_cnt > 7) {
@@ -67,6 +67,10 @@
 				}
 			}
 		}
+		else if ('\0' != *(c+1)) {
+			/* only a port is allowed to follow [...] */
+			return -1;
+		}
 		return 0;
 	}
 
@@ -88,10 +92,9 @@
 	/* if the hostname ends in a "." strip it */
 	if (host->ptr[host_len-1] == '.') {
 		/* shift port info one left */
-		if (NULL != colon) memmove(colon-1, colon, host->used - host_len);
-		else host->ptr[host_len-1] = '\0';
+		if (NULL != colon) memmove(colon-1, colon, buffer_string_length(host) - host_len);
+		buffer_string_set_length(host, buffer_string_length(host) - 1);
 		host_len -= 1;
-		host->used -= 1;
 	}
 
 	if (host_len == 0) return -1;
@@ -209,7 +212,7 @@
 #endif
 
 static int http_request_split_value(array *vals, buffer *b) {
-	size_t i;
+	size_t i, len;
 	int state = 0;
 
 	const char *current;
@@ -222,10 +225,11 @@
 	 * into a array (more or less a explode() incl. striping of whitespaces
 	 */
 
-	if (b->used == 0) return 0;
+	if (buffer_string_is_empty(b)) return 0;
 
 	current = b->ptr;
-	for (i =  0; i < b->used; ++i, ++current) {
+	len = buffer_string_length(b);
+	for (i =  0; i <= len; ++i, ++current) {
 		data_string *ds;
 
 		switch (state) {
@@ -293,7 +297,7 @@
 	int line = 0;
 
 	int request_line_stage = 0;
-	size_t i, first;
+	size_t i, first, ilen;
 
 	int done = 0;
 
@@ -306,7 +310,7 @@
 	if (con->conf.log_request_header) {
 		log_error_write(srv, __FILE__, __LINE__, "sdsdSb",
 				"fd:", con->fd,
-				"request-len:", con->request.request->used,
+				"request-len:", buffer_string_length(con->request.request),
 				"\n", con->request.request);
 	}
 
@@ -315,10 +319,10 @@
 	    con->request.request->ptr[1] == '\n') {
 		/* we are in keep-alive and might get \r\n after a previous POST request.*/
 
-		buffer_copy_string_len(con->parse_request, con->request.request->ptr + 2, con->request.request->used - 1 - 2);
+		buffer_copy_string_len(con->parse_request, con->request.request->ptr + 2, buffer_string_length(con->request.request) - 2);
 	} else {
 		/* fill the local request buffer */
-		buffer_copy_string_buffer(con->parse_request, con->request.request);
+		buffer_copy_buffer(con->parse_request, con->request.request);
 	}
 
 	keep_alive_set = 0;
@@ -330,15 +334,14 @@
 	 *
 	 * <method> <uri> <protocol>\r\n
 	 * */
-	for (i = 0, first = 0; i < con->parse_request->used && line == 0; i++) {
-		char *cur = con->parse_request->ptr + i;
-
-		switch(*cur) {
+	ilen = buffer_string_length(con->parse_request);
+	for (i = 0, first = 0; i < ilen && line == 0; i++) {
+		switch(con->parse_request->ptr[i]) {
 		case '\r':
 			if (con->parse_request->ptr[i+1] == '\n') {
 				http_method_t r;
 				char *nuri = NULL;
-				size_t j;
+				size_t j, jlen;
 
 				/* \r\n -> \0\0 */
 				con->parse_request->ptr[i] = '\0';
@@ -366,7 +369,7 @@
 				*(proto - 1) = '\0';
 
 				/* we got the first one :) */
-				if (-1 == (r = get_http_method_key(method))) {
+				if (HTTP_METHOD_UNSET == (r = get_http_method_key(method))) {
 					con->http_status = 501;
 					con->response.keep_alive = 0;
 					con->keep_alive = 0;
@@ -472,7 +475,8 @@
 				}
 
 				/* check uri for invalid characters */
-				for (j = 0; j < con->request.uri->used - 1; j++) {
+				jlen = buffer_string_length(con->request.uri);
+				for (j = 0; j < jlen; j++) {
 					if (!request_uri_is_valid_char(con->request.uri->ptr[j])) {
 						unsigned char buf[2];
 						con->http_status = 400;
@@ -504,7 +508,7 @@
 					}
 				}
 
-				buffer_copy_string_buffer(con->request.orig_uri, con->request.uri);
+				buffer_copy_buffer(con->request.orig_uri, con->request.uri);
 
 				con->http_status = 0;
 
@@ -547,7 +551,7 @@
 
 	in_folding = 0;
 
-	if (con->request.uri->used == 1) {
+	if (buffer_string_is_empty(con->request.uri)) {
 		con->http_status = 400;
 		con->response.keep_alive = 0;
 		con->keep_alive = 0;
@@ -575,7 +579,7 @@
 		con->request.http_host = ds->value;
 	}
 
-	for (; i < con->parse_request->used && !done; i++) {
+	for (; i <= ilen && !done; i++) {
 		char *cur = con->parse_request->ptr + i;
 
 		if (is_key) {
@@ -584,7 +588,7 @@
 
 			/**
 			 * 1*<any CHAR except CTLs or separators>
-			 * CTLs == 0-31 + 127
+			 * CTLs == 0-31 + 127, CHAR = 7-bit ascii (0..127)
 			 *
 			 */
 			switch(*cur) {
@@ -619,8 +623,14 @@
 				con->keep_alive = 0;
 				con->response.keep_alive = 0;
 
-				log_error_write(srv, __FILE__, __LINE__, "sbsds",
+				if (srv->srvconf.log_request_header_on_error) {
+					log_error_write(srv, __FILE__, __LINE__, "sbsds",
 						"invalid character in key", con->request.request, cur, *cur, "-> 400");
+
+					log_error_write(srv, __FILE__, __LINE__, "Sb",
+						"request-header:\n",
+						con->request.request);
+				}
 				return 0;
 			case ' ':
 			case '\t':
@@ -678,8 +688,6 @@
 					i++;
 
 					done = 1;
-
-					break;
 				} else {
 					if (srv->srvconf.log_request_header_on_error) {
 						log_error_write(srv, __FILE__, __LINE__, "s", "CR without LF -> 400");
@@ -693,53 +701,24 @@
 					con->response.keep_alive = 0;
 					return 0;
 				}
-				/* fall thru */
-			case 0: /* illegal characters (faster than a if () :) */
-			case 1:
-			case 2:
-			case 3:
-			case 4:
-			case 5:
-			case 6:
-			case 7:
-			case 8:
-			case 10:
-			case 11:
-			case 12:
-			case 14:
-			case 15:
-			case 16:
-			case 17:
-			case 18:
-			case 19:
-			case 20:
-			case 21:
-			case 22:
-			case 23:
-			case 24:
-			case 25:
-			case 26:
-			case 27:
-			case 28:
-			case 29:
-			case 30:
-			case 31:
-			case 127:
-				con->http_status = 400;
-				con->keep_alive = 0;
-				con->response.keep_alive = 0;
+				break;
+			default:
+				if (*cur < 32 || ((unsigned char)*cur) >= 127) {
+					con->http_status = 400;
+					con->keep_alive = 0;
+					con->response.keep_alive = 0;
 
-				if (srv->srvconf.log_request_header_on_error) {
-					log_error_write(srv, __FILE__, __LINE__, "sbsds",
-						"CTL character in key", con->request.request, cur, *cur, "-> 400");
+					if (srv->srvconf.log_request_header_on_error) {
+						log_error_write(srv, __FILE__, __LINE__, "sbsds",
+							"invalid character in key", con->request.request, cur, *cur, "-> 400");
 
-					log_error_write(srv, __FILE__, __LINE__, "Sb",
-						"request-header:\n",
-						con->request.request);
-				}
+						log_error_write(srv, __FILE__, __LINE__, "Sb",
+							"request-header:\n",
+							con->request.request);
+					}
 
-				return 0;
-			default:
+					return 0;
+				}
 				/* ok */
 				break;
 			}
@@ -846,7 +825,7 @@
 							} else if (cmp > 0 && 0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN("Content-Length")))) {
 								char *err;
 								unsigned long int r;
-								size_t j;
+								size_t j, jlen;
 
 								if (con_length_set) {
 									con->http_status = 400;
@@ -863,9 +842,8 @@
 									return 0;
 								}
 
-								if (ds->value->used == 0) SEGFAULT();
-
-								for (j = 0; j < ds->value->used - 1; j++) {
+								jlen = buffer_string_length(ds->value);
+								for (j = 0; j < jlen; j++) {
 									char c = ds->value->ptr[j];
 									if (!isdigit((unsigned char)c)) {
 										log_error_write(srv, __FILE__, __LINE__, "sbs",
@@ -1048,6 +1026,7 @@
 			case '\t':
 				/* strip leading WS */
 				if (value == cur) value = cur+1;
+				/* fallthrough */
 			default:
 				if (*cur >= 0 && *cur < 32 && *cur != '\t') {
 					if (srv->srvconf.log_request_header_on_error) {
@@ -1081,7 +1060,7 @@
 
 		/* RFC 2616, 14.23 */
 		if (con->request.http_host == NULL ||
-		    buffer_is_empty(con->request.http_host)) {
+		    buffer_string_is_empty(con->request.http_host)) {
 			con->http_status = 400;
 			con->response.keep_alive = 0;
 			con->keep_alive = 0;
@@ -1197,9 +1176,9 @@
 int http_request_header_finished(server *srv, connection *con) {
 	UNUSED(srv);
 
-	if (con->request.request->used < 5) return 0;
+	if (buffer_string_length(con->request.request) < 4) return 0;
 
-	if (0 == memcmp(con->request.request->ptr + con->request.request->used - 5, "\r\n\r\n", 4)) return 1;
+	if (0 == memcmp(con->request.request->ptr + buffer_string_length(con->request.request) - 4, CONST_STR_LEN("\r\n\r\n"))) return 1;
 	if (NULL != strstr(con->request.request->ptr, "\r\n\r\n")) return 1;
 
 	return 0;
diff -u lighttpd-1.4.32/src/response.c lighttpd-1.4.36/src/response.c
--- lighttpd-1.4.32/src/response.c	2012-11-07 06:31:42.000000000 -0600
+++ lighttpd-1.4.36/src/response.c	2015-07-26 05:36:36.000000000 -0500
@@ -33,14 +33,14 @@
 	int have_date = 0;
 	int have_server = 0;
 
-	b = chunkqueue_get_prepend_buffer(con->write_queue);
+	b = buffer_init();
 
 	if (con->request.http_version == HTTP_VERSION_1_1) {
 		buffer_copy_string_len(b, CONST_STR_LEN("HTTP/1.1 "));
 	} else {
 		buffer_copy_string_len(b, CONST_STR_LEN("HTTP/1.0 "));
 	}
-	buffer_append_long(b, con->http_status);
+	buffer_append_int(b, con->http_status);
 	buffer_append_string_len(b, CONST_STR_LEN(" "));
 	buffer_append_string(b, get_http_status_name(con->http_status));
 
@@ -70,7 +70,7 @@
 
 		ds = (data_string *)con->response.headers->data[i];
 
-		if (ds->value->used && ds->key->used &&
+		if (!buffer_is_empty(ds->value) && !buffer_is_empty(ds->key) &&
 		    0 != strncasecmp(ds->key->ptr, CONST_STR_LEN("X-LIGHTTPD-")) &&
 			0 != strncasecmp(ds->key->ptr, CONST_STR_LEN("X-Sendfile"))) {
 			if (0 == strcasecmp(ds->key->ptr, "Date")) have_date = 1;
@@ -97,12 +97,9 @@
 
 		/* cache the generated timestamp */
 		if (srv->cur_ts != srv->last_generated_date_ts) {
-			buffer_prepare_copy(srv->ts_date_str, 255);
+			buffer_string_prepare_copy(srv->ts_date_str, 255);
 
-			strftime(srv->ts_date_str->ptr, srv->ts_date_str->size - 1,
-				 "%a, %d %b %Y %H:%M:%S GMT", gmtime(&(srv->cur_ts)));
-
-			srv->ts_date_str->used = strlen(srv->ts_date_str->ptr) + 1;
+			buffer_append_strftime(srv->ts_date_str, "%a, %d %b %Y %H:%M:%S GMT", gmtime(&(srv->cur_ts)));
 
 			srv->last_generated_date_ts = srv->cur_ts;
 		}
@@ -113,7 +110,7 @@
 	if (!have_server) {
 		if (buffer_is_empty(con->conf.server_tag)) {
 			buffer_append_string_len(b, CONST_STR_LEN("\r\nServer: " PACKAGE_DESC));
-		} else if (con->conf.server_tag->used > 1) {
+		} else if (!buffer_string_is_empty(con->conf.server_tag)) {
 			buffer_append_string_len(b, CONST_STR_LEN("\r\nServer: "));
 			buffer_append_string_encoded(b, CONST_BUF_LEN(con->conf.server_tag), ENCODING_HTTP_HEADER);
 		}
@@ -121,13 +118,15 @@
 
 	buffer_append_string_len(b, CONST_STR_LEN("\r\n\r\n"));
 
-
-	con->bytes_header = b->used - 1;
+	con->bytes_header = buffer_string_length(b);
 
 	if (con->conf.log_response_header) {
 		log_error_write(srv, __FILE__, __LINE__, "sSb", "Response-Header:", "\n", b);
 	}
 
+	chunkqueue_prepend_buffer(con->write_queue, b);
+	buffer_free(b);
+
 	return 0;
 }
 
@@ -169,11 +168,19 @@
 			envds->value,
 			(const char *)xe->value->data, xe->value->length
 		);
-		/* pick one of the exported values as "authed user", for example
+		/* pick one of the exported values as "REMOTE_USER", for example
 		 * ssl.verifyclient.username   = "SSL_CLIENT_S_DN_UID" or "SSL_CLIENT_S_DN_emailAddress"
 		 */
 		if (buffer_is_equal(con->conf.ssl_verifyclient_username, envds->key)) {
-			buffer_copy_string_buffer(con->authed_user, envds->value);
+			data_string *ds;
+			if (NULL == (ds = (data_string *)array_get_element(con->environment, "REMOTE_USER"))) {
+				if (NULL == (ds = (data_string *)array_get_unused_element(con->environment, TYPE_STRING))) {
+					ds = data_string_init();
+				}
+				buffer_copy_string(ds->key, "REMOTE_USER");
+				array_insert_unique(con->environment, (data_unset *)ds);
+			}
+			buffer_copy_buffer(ds->value, envds->value);
 		}
 		array_insert_unique(con->environment, (data_unset *)envds);
 	}
@@ -191,11 +198,10 @@
 			}
 
 			buffer_copy_string_len(envds->key, CONST_STR_LEN("SSL_CLIENT_CERT"));
-			buffer_prepare_copy(envds->value, n+1);
+			buffer_string_prepare_copy(envds->value, n);
 			BIO_read(bio, envds->value->ptr, n);
 			BIO_free(bio);
-			envds->value->ptr[n] = '\0';
-			envds->value->used = n+1;
+			buffer_commit(envds->value, n);
 			array_insert_unique(con->environment, (data_unset *)envds);
 		}
 	}
@@ -219,7 +225,7 @@
 	}
 
 	/* no decision yet, build conf->filename */
-	if (con->mode == DIRECT && con->physical.path->used == 0) {
+	if (con->mode == DIRECT && buffer_is_empty(con->physical.path)) {
 		char *qstr;
 
 		/* we only come here when we have the parse the full request again
@@ -264,12 +270,13 @@
 		 *
 		 */
 
-		if (con->conf.is_ssl) {
+		/* initial scheme value. can be overwritten for example by mod_extforward later */
+		if (con->srv_socket->is_ssl) {
 			buffer_copy_string_len(con->uri.scheme, CONST_STR_LEN("https"));
 		} else {
 			buffer_copy_string_len(con->uri.scheme, CONST_STR_LEN("http"));
 		}
-		buffer_copy_string_buffer(con->uri.authority, con->request.http_host);
+		buffer_copy_buffer(con->uri.authority, con->request.http_host);
 		buffer_to_lower(con->uri.authority);
 
 		config_patch_connection(srv, con, COMP_HTTP_SCHEME);    /* Scheme:      */
@@ -283,8 +290,7 @@
 
 		/** their might be a fragment which has to be cut away */
 		if (NULL != (qstr = strchr(con->request.uri->ptr, '#'))) {
-			con->request.uri->used = qstr - con->request.uri->ptr;
-			con->request.uri->ptr[con->request.uri->used++] = '\0';
+			buffer_string_set_length(con->request.uri, qstr - con->request.uri->ptr);
 		}
 
 		/** extract query string from request.uri */
@@ -293,16 +299,47 @@
 			buffer_copy_string_len(con->uri.path_raw, con->request.uri->ptr, qstr - con->request.uri->ptr);
 		} else {
 			buffer_reset     (con->uri.query);
-			buffer_copy_string_buffer(con->uri.path_raw, con->request.uri);
+			buffer_copy_buffer(con->uri.path_raw, con->request.uri);
+		}
+
+		/* decode url to path
+		 *
+		 * - decode url-encodings  (e.g. %20 -> ' ')
+		 * - remove path-modifiers (e.g. /../)
+		 */
+
+		if (con->request.http_method == HTTP_METHOD_OPTIONS &&
+		    con->uri.path_raw->ptr[0] == '*' && con->uri.path_raw->ptr[1] == '\0') {
+			/* OPTIONS * ... */
+			buffer_copy_buffer(con->uri.path, con->uri.path_raw);
+		} else {
+			buffer_copy_buffer(srv->tmp_buf, con->uri.path_raw);
+			buffer_urldecode_path(srv->tmp_buf);
+			buffer_path_simplify(con->uri.path, srv->tmp_buf);
+		}
+
+		config_patch_connection(srv, con, COMP_HTTP_URL); /* HTTPurl */
+		config_patch_connection(srv, con, COMP_HTTP_QUERY_STRING); /* HTTPqs */
+
+#ifdef USE_OPENSSL
+		if (con->srv_socket->is_ssl && con->conf.ssl_verifyclient) {
+			https_add_ssl_entries(con);
+		}
+#endif
+
+		/* do we have to downgrade to 1.0 ? */
+		if (!con->conf.allow_http11) {
+			con->request.http_version = HTTP_VERSION_1_0;
 		}
 
 		if (con->conf.log_request_handling) {
 			log_error_write(srv, __FILE__, __LINE__,  "s",  "-- splitting Request-URI");
-			log_error_write(srv, __FILE__, __LINE__,  "sb", "Request-URI  : ", con->request.uri);
-			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-scheme   : ", con->uri.scheme);
-			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-authority: ", con->uri.authority);
-			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-path     : ", con->uri.path_raw);
-			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-query    : ", con->uri.query);
+			log_error_write(srv, __FILE__, __LINE__,  "sb", "Request-URI     : ", con->request.uri);
+			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-scheme      : ", con->uri.scheme);
+			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-authority   : ", con->uri.authority);
+			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-path (raw)  : ", con->uri.path_raw);
+			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-path (clean): ", con->uri.path);
+			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-query       : ", con->uri.query);
 		}
 
 
@@ -327,35 +364,6 @@
 			break;
 		}
 
-		/* build filename
-		 *
-		 * - decode url-encodings  (e.g. %20 -> ' ')
-		 * - remove path-modifiers (e.g. /../)
-		 */
-
-
-
-		if (con->request.http_method == HTTP_METHOD_OPTIONS &&
-		    con->uri.path_raw->ptr[0] == '*' && con->uri.path_raw->ptr[1] == '\0') {
-			/* OPTIONS * ... */
-			buffer_copy_string_buffer(con->uri.path, con->uri.path_raw);
-		} else {
-			buffer_copy_string_buffer(srv->tmp_buf, con->uri.path_raw);
-			buffer_urldecode_path(srv->tmp_buf);
-			buffer_path_simplify(con->uri.path, srv->tmp_buf);
-		}
-
-		if (con->conf.log_request_handling) {
-			log_error_write(srv, __FILE__, __LINE__,  "s",  "-- sanatising URI");
-			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-path     : ", con->uri.path);
-		}
-
-#ifdef USE_OPENSSL
-		if (con->conf.is_ssl && con->conf.ssl_verifyclient) {
-			https_add_ssl_entries(con);
-		}
-#endif
-
 		/**
 		 *
 		 * call plugins
@@ -364,14 +372,6 @@
 		 *
 		 */
 
-		config_patch_connection(srv, con, COMP_HTTP_URL); /* HTTPurl */
-		config_patch_connection(srv, con, COMP_HTTP_QUERY_STRING); /* HTTPqs */
-
-		/* do we have to downgrade to 1.0 ? */
-		if (!con->conf.allow_http11) {
-			con->request.http_version = HTTP_VERSION_1_0;
-		}
-
 		switch(r = plugins_call_handle_uri_clean(srv, con)) {
 		case HANDLER_GO_ON:
 			break;
@@ -427,8 +427,8 @@
 
 		/* set a default */
 
-		buffer_copy_string_buffer(con->physical.doc_root, con->conf.document_root);
-		buffer_copy_string_buffer(con->physical.rel_path, con->uri.path);
+		buffer_copy_buffer(con->physical.doc_root, con->conf.document_root);
+		buffer_copy_buffer(con->physical.rel_path, con->uri.path);
 
 #if defined(__WIN32) || defined(__CYGWIN__)
 		/* strip dots from the end and spaces
@@ -446,23 +446,18 @@
 
 		if (con->physical.rel_path->used > 1) {
 			buffer *b = con->physical.rel_path;
+			size_t len = buffer_string_length(b);
 			size_t i;
 
-			if (b->used > 2 &&
-			    b->ptr[b->used-2] == '/' &&
-			    (b->ptr[b->used-3] == ' ' ||
-			     b->ptr[b->used-3] == '.')) {
-				b->ptr[b->used--] = '\0';
-			}
-
-			for (i = b->used - 2; b->used > 1; i--) {
-				if (b->ptr[i] == ' ' ||
-				    b->ptr[i] == '.') {
-					b->ptr[b->used--] = '\0';
-				} else {
-					break;
-				}
-			}
+			/* strip trailing " /" or "./" once */
+			if (len > 1 &&
+			    b->ptr[len - 1] == '/' &&
+			    (b->ptr[len - 2] == ' ' || b->ptr[len - 2] == '.')) {
+				len -= 2;
+			}
+			/* strip all trailing " " and "." */
+			while (len > 0 &&  ( ' ' == b->ptr[len-1] || '.' == b->ptr[len-1] ) ) --len;
+			buffer_string_set_length(b, len);
 		}
 #endif
 
@@ -497,8 +492,8 @@
 		}
 
 		/* the docroot plugins might set the servername, if they don't we take http-host */
-		if (buffer_is_empty(con->server_name)) {
-			buffer_copy_string_buffer(con->server_name, con->uri.authority);
+		if (buffer_string_is_empty(con->server_name)) {
+			buffer_copy_buffer(con->server_name, con->uri.authority);
 		}
 
 		/**
@@ -507,12 +502,12 @@
 		 *
 		 */
 
-		buffer_copy_string_buffer(con->physical.path, con->physical.doc_root);
-		BUFFER_APPEND_SLASH(con->physical.path);
-		buffer_copy_string_buffer(con->physical.basedir, con->physical.path);
-		if (con->physical.rel_path->used &&
+		buffer_copy_buffer(con->physical.basedir, con->physical.doc_root);
+		buffer_copy_buffer(con->physical.path, con->physical.doc_root);
+		buffer_append_slash(con->physical.path);
+		if (!buffer_string_is_empty(con->physical.rel_path) &&
 		    con->physical.rel_path->ptr[0] == '/') {
-			buffer_append_string_len(con->physical.path, con->physical.rel_path->ptr + 1, con->physical.rel_path->used - 2);
+			buffer_append_string_len(con->physical.path, con->physical.rel_path->ptr + 1, buffer_string_length(con->physical.rel_path) - 1);
 		} else {
 			buffer_append_string_buffer(con->physical.path, con->physical.rel_path);
 		}
@@ -540,6 +535,7 @@
 		if (con->conf.log_request_handling) {
 			log_error_write(srv, __FILE__, __LINE__,  "s",  "-- logical -> physical");
 			log_error_write(srv, __FILE__, __LINE__,  "sb", "Doc-Root     :", con->physical.doc_root);
+			log_error_write(srv, __FILE__, __LINE__,  "sb", "Basedir      :", con->physical.basedir);
 			log_error_write(srv, __FILE__, __LINE__,  "sb", "Rel-Path     :", con->physical.rel_path);
 			log_error_write(srv, __FILE__, __LINE__,  "sb", "Path         :", con->physical.path);
 		}
@@ -583,7 +579,7 @@
 			};
 #endif
 			if (S_ISDIR(sce->st.st_mode)) {
-				if (con->uri.path->ptr[con->uri.path->used - 2] != '/') {
+				if (con->uri.path->ptr[buffer_string_length(con->uri.path) - 1] != '/') {
 					/* redirect to .../ */
 
 					http_response_redirect_to_directory(srv, con);
@@ -641,13 +637,13 @@
 
 			/* not found, perhaps PATHINFO */
 
-			buffer_copy_string_buffer(srv->tmp_buf, con->physical.path);
+			buffer_copy_buffer(srv->tmp_buf, con->physical.path);
 
 			do {
 				if (slash) {
 					buffer_copy_string_len(con->physical.path, srv->tmp_buf->ptr, slash - srv->tmp_buf->ptr);
 				} else {
-					buffer_copy_string_buffer(con->physical.path, srv->tmp_buf);
+					buffer_copy_buffer(con->physical.path, srv->tmp_buf);
 				}
 
 				if (HANDLER_ERROR != stat_cache_get_entry(srv, con, con->physical.path, &sce)) {
@@ -666,7 +662,7 @@
 				}
 
 				if (slash) pathinfo = slash;
-			} while ((found == 0) && (slash != NULL) && ((size_t)(slash - srv->tmp_buf->ptr) > (con->physical.basedir->used - 2)));
+			} while ((found == 0) && (slash != NULL) && ((size_t)(slash - srv->tmp_buf->ptr) > (buffer_string_length(con->physical.basedir) - 1)));
 
 			if (found == 0) {
 				/* no it really doesn't exists */
@@ -705,8 +701,7 @@
 				 * shorten uri.path
 				 */
 
-				con->uri.path->used -= strlen(pathinfo);
-				con->uri.path->ptr[con->uri.path->used - 1] = '\0';
+				buffer_string_set_length(con->uri.path, buffer_string_length(con->uri.path) - strlen(pathinfo));
 			}
 
 			if (con->conf.log_request_handling) {
diff -u lighttpd-1.4.32/src/SConscript lighttpd-1.4.36/src/SConscript
--- lighttpd-1.4.32/src/SConscript	2011-07-30 04:04:50.000000000 -0500
+++ lighttpd-1.4.36/src/SConscript	2015-07-26 05:36:36.000000000 -0500
@@ -14,7 +14,7 @@
       fdevent_poll.c fdevent_linux_sysepoll.c \
       fdevent_solaris_devpoll.c fdevent_solaris_port.c \
       fdevent_freebsd_kqueue.c \
-      data_config.c bitset.c \
+      data_config.c \
       inet_ntop_cache.c crc32.c \
       connections-glue.c \
       configfile-glue.c \
diff -u lighttpd-1.4.32/src/server.c lighttpd-1.4.36/src/server.c
--- lighttpd-1.4.32/src/server.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.36/src/server.c	2015-07-26 05:36:36.000000000 -0500
@@ -172,7 +172,7 @@
 	FILE *frandom = NULL;
 
 	server *srv = calloc(1, sizeof(*srv));
-	assert(srv);
+	force_assert(srv);
 #define CLEAN(x) \
 	srv->x = buffer_init();
 
@@ -230,13 +230,13 @@
 	srv->startup_ts = srv->cur_ts;
 
 	srv->conns = calloc(1, sizeof(*srv->conns));
-	assert(srv->conns);
+	force_assert(srv->conns);
 
 	srv->joblist = calloc(1, sizeof(*srv->joblist));
-	assert(srv->joblist);
+	force_assert(srv->joblist);
 
 	srv->fdwaitqueue = calloc(1, sizeof(*srv->fdwaitqueue));
-	assert(srv->fdwaitqueue);
+	force_assert(srv->fdwaitqueue);
 
 	srv->srvconf.modules = array_init();
 	srv->srvconf.modules_dir = buffer_init_string(LIBRARY_DIR);
@@ -314,6 +314,9 @@
 			buffer_free(s->ssl_verifyclient_username);
 #ifdef USE_OPENSSL
 			SSL_CTX_free(s->ssl_ctx);
+			EVP_PKEY_free(s->ssl_pemfile_pkey);
+			X509_free(s->ssl_pemfile_x509);
+			if (NULL != s->ssl_ca_file_cert_names) sk_X509_NAME_pop_free(s->ssl_ca_file_cert_names, X509_NAME_free);
 #endif
 			free(s);
 		}
@@ -663,7 +666,7 @@
 #endif
 
 	/* check document-root */
-	if (srv->config_storage[0]->document_root->used <= 1) {
+	if (buffer_string_is_empty(srv->config_storage[0]->document_root)) {
 		log_error_write(srv, __FILE__, __LINE__, "s",
 				"document-root is not set\n");
 
@@ -683,7 +686,7 @@
 	}
 
 	/* open pid file BEFORE chroot */
-	if (srv->srvconf.pid_file->used) {
+	if (!buffer_string_is_empty(srv->srvconf.pid_file)) {
 		if (-1 == (pid_fd = open(srv->srvconf.pid_file->ptr, O_WRONLY | O_CREAT | O_EXCL | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH))) {
 			struct stat st;
 			if (errno != EEXIST) {
@@ -777,7 +780,7 @@
 
 #ifdef HAVE_PWD_H
 		/* set user and group */
-		if (srv->srvconf.username->used) {
+		if (!buffer_string_is_empty(srv->srvconf.username)) {
 			if (NULL == (pwd = getpwnam(srv->srvconf.username->ptr))) {
 				log_error_write(srv, __FILE__, __LINE__, "sb",
 						"can't find username", srv->srvconf.username);
@@ -791,7 +794,7 @@
 			}
 		}
 
-		if (srv->srvconf.groupname->used) {
+		if (!buffer_string_is_empty(srv->srvconf.groupname)) {
 			if (NULL == (grp = getgrnam(srv->srvconf.groupname->ptr))) {
 				log_error_write(srv, __FILE__, __LINE__, "sb",
 					"can't find groupname", srv->srvconf.groupname);
@@ -817,15 +820,21 @@
 		 * to /etc/group
 		 * */
 		if (NULL != grp) {
-			setgid(grp->gr_gid);
-			setgroups(0, NULL);
-			if (srv->srvconf.username->used) {
+			if (-1 == setgid(grp->gr_gid)) {
+				log_error_write(srv, __FILE__, __LINE__, "ss", "setgid failed: ", strerror(errno));
+				return -1;
+			}
+			if (-1 == setgroups(0, NULL)) {
+				log_error_write(srv, __FILE__, __LINE__, "ss", "setgroups failed: ", strerror(errno));
+				return -1;
+			}
+			if (!buffer_string_is_empty(srv->srvconf.username)) {
 				initgroups(srv->srvconf.username->ptr, grp->gr_gid);
 			}
 		}
 #endif
 #ifdef HAVE_CHROOT
-		if (srv->srvconf.changeroot->used) {
+		if (!buffer_string_is_empty(srv->srvconf.changeroot)) {
 			tzset();
 
 			if (-1 == chroot(srv->srvconf.changeroot->ptr)) {
@@ -841,7 +850,10 @@
 #ifdef HAVE_PWD_H
 		/* drop root privs */
 		if (NULL != pwd) {
-			setuid(pwd->pw_uid);
+			if (-1 == setuid(pwd->pw_uid)) {
+				log_error_write(srv, __FILE__, __LINE__, "ss", "setuid failed: ", strerror(errno));
+				return -1;
+			}
 		}
 #endif
 #if defined(HAVE_SYS_PRCTL_H) && defined(PR_SET_DUMPABLE)
@@ -937,14 +949,59 @@
 	if (srv->srvconf.dont_daemonize == 0) daemonize();
 #endif
 
+
+#ifdef HAVE_SIGACTION
+	memset(&act, 0, sizeof(act));
+	act.sa_handler = SIG_IGN;
+	sigaction(SIGPIPE, &act, NULL);
+	sigaction(SIGUSR1, &act, NULL);
+# if defined(SA_SIGINFO)
+	act.sa_sigaction = sigaction_handler;
+	sigemptyset(&act.sa_mask);
+	act.sa_flags = SA_SIGINFO;
+# else
+	act.sa_handler = signal_handler;
+	sigemptyset(&act.sa_mask);
+	act.sa_flags = 0;
+# endif
+	sigaction(SIGINT,  &act, NULL);
+	sigaction(SIGTERM, &act, NULL);
+	sigaction(SIGHUP,  &act, NULL);
+	sigaction(SIGALRM, &act, NULL);
+	sigaction(SIGCHLD, &act, NULL);
+
+#elif defined(HAVE_SIGNAL)
+	/* ignore the SIGPIPE from sendfile() */
+	signal(SIGPIPE, SIG_IGN);
+	signal(SIGUSR1, SIG_IGN);
+	signal(SIGALRM, signal_handler);
+	signal(SIGTERM, signal_handler);
+	signal(SIGHUP,  signal_handler);
+	signal(SIGCHLD,  signal_handler);
+	signal(SIGINT,  signal_handler);
+#endif
+
+#ifdef USE_ALARM
+	signal(SIGALRM, signal_handler);
+
+	/* setup periodic timer (1 second) */
+	if (setitimer(ITIMER_REAL, &interval, NULL)) {
+		log_error_write(srv, __FILE__, __LINE__, "s", "setting timer failed");
+		return -1;
+	}
+
+	getitimer(ITIMER_REAL, &interval);
+#endif
+
+
 	srv->gid = getgid();
 	srv->uid = getuid();
 
 	/* write pid file */
 	if (pid_fd != -1) {
-		buffer_copy_long(srv->tmp_buf, getpid());
+		buffer_copy_int(srv->tmp_buf, getpid());
 		buffer_append_string_len(srv->tmp_buf, CONST_STR_LEN("\n"));
-		write(pid_fd, srv->tmp_buf->ptr, srv->tmp_buf->used - 1);
+		write(pid_fd, CONST_BUF_LEN(srv->tmp_buf));
 		close(pid_fd);
 		pid_fd = -1;
 	}
@@ -1011,51 +1068,6 @@
 	}
 
 
-
-
-#ifdef HAVE_SIGACTION
-	memset(&act, 0, sizeof(act));
-	act.sa_handler = SIG_IGN;
-	sigaction(SIGPIPE, &act, NULL);
-	sigaction(SIGUSR1, &act, NULL);
-# if defined(SA_SIGINFO)
-	act.sa_sigaction = sigaction_handler;
-	sigemptyset(&act.sa_mask);
-	act.sa_flags = SA_SIGINFO;
-# else
-	act.sa_handler = signal_handler;
-	sigemptyset(&act.sa_mask);
-	act.sa_flags = 0;
-# endif
-	sigaction(SIGINT,  &act, NULL);
-	sigaction(SIGTERM, &act, NULL);
-	sigaction(SIGHUP,  &act, NULL);
-	sigaction(SIGALRM, &act, NULL);
-	sigaction(SIGCHLD, &act, NULL);
-
-#elif defined(HAVE_SIGNAL)
-	/* ignore the SIGPIPE from sendfile() */
-	signal(SIGPIPE, SIG_IGN);
-	signal(SIGUSR1, SIG_IGN);
-	signal(SIGALRM, signal_handler);
-	signal(SIGTERM, signal_handler);
-	signal(SIGHUP,  signal_handler);
-	signal(SIGCHLD,  signal_handler);
-	signal(SIGINT,  signal_handler);
-#endif
-
-#ifdef USE_ALARM
-	signal(SIGALRM, signal_handler);
-
-	/* setup periodic timer (1 second) */
-	if (setitimer(ITIMER_REAL, &interval, NULL)) {
-		log_error_write(srv, __FILE__, __LINE__, "s", "setting timer failed");
-		return -1;
-	}
-
-	getitimer(ITIMER_REAL, &interval);
-#endif
-
 #ifdef HAVE_FORK
 	/* start watcher and workers */
 	num_childs = srv->srvconf.max_worker;
@@ -1170,18 +1182,17 @@
 #ifdef HAVE_FAM_H
 	/* setup FAM */
 	if (srv->srvconf.stat_cache_engine == STAT_CACHE_ENGINE_FAM) {
-		if (0 != FAMOpen2(srv->stat_cache->fam, "lighttpd")) {
+		if (0 != FAMOpen2(&srv->stat_cache->fam, "lighttpd")) {
 			log_error_write(srv, __FILE__, __LINE__, "s",
 					 "could not open a fam connection, dieing.");
 			return -1;
 		}
 #ifdef HAVE_FAMNOEXISTS
-		FAMNoExists(srv->stat_cache->fam);
+		FAMNoExists(&srv->stat_cache->fam);
 #endif
 
-		srv->stat_cache->fam_fcce_ndx = -1;
-		fdevent_register(srv->ev, FAMCONNECTION_GETFD(srv->stat_cache->fam), stat_cache_handle_fdevent, NULL);
-		fdevent_event_set(srv->ev, &(srv->stat_cache->fam_fcce_ndx), FAMCONNECTION_GETFD(srv->stat_cache->fam), FDEVENT_IN);
+		fdevent_register(srv->ev, FAMCONNECTION_GETFD(&srv->stat_cache->fam), stat_cache_handle_fdevent, NULL);
+		fdevent_event_set(srv->ev, &(srv->stat_cache->fam_fcce_ndx), FAMCONNECTION_GETFD(&srv->stat_cache->fam), FDEVENT_IN);
 	}
 #endif
 
@@ -1251,7 +1262,9 @@
 			min_ts = time(NULL);
 
 			if (min_ts != srv->cur_ts) {
+#ifdef DEBUG_CONNECTION_STATES
 				int cs = 0;
+#endif
 				connections *conns = srv->conns;
 				handler_t r;
 
@@ -1284,23 +1297,25 @@
 
 					if (con->state == CON_STATE_READ ||
 					    con->state == CON_STATE_READ_POST) {
-						if (con->request_count == 1) {
+						if (con->request_count == 1 || con->state == CON_STATE_READ_POST) {
 							if (srv->cur_ts - con->read_idle_ts > con->conf.max_read_idle) {
 								/* time - out */
-#if 0
-								log_error_write(srv, __FILE__, __LINE__, "sd",
-										"connection closed - read-timeout:", con->fd);
-#endif
+								if (con->conf.log_request_handling) {
+									log_error_write(srv, __FILE__, __LINE__, "sd",
+										"connection closed - read timeout:", con->fd);
+								}
+
 								connection_set_state(srv, con, CON_STATE_ERROR);
 								changed = 1;
 							}
 						} else {
 							if (srv->cur_ts - con->read_idle_ts > con->keep_alive_idle) {
 								/* time - out */
-#if 0
-								log_error_write(srv, __FILE__, __LINE__, "sd",
-										"connection closed - read-timeout:", con->fd);
-#endif
+								if (con->conf.log_request_handling) {
+									log_error_write(srv, __FILE__, __LINE__, "sd",
+										"connection closed - keep-alive timeout:", con->fd);
+								}
+
 								connection_set_state(srv, con, CON_STATE_ERROR);
 								changed = 1;
 							}
@@ -1355,7 +1370,7 @@
 					con->bytes_written_cur_second = 0;
 					*(con->conf.global_bytes_per_second_cnt_ptr) = 0;
 
-#if 0
+#if DEBUG_CONNECTION_STATES
 					if (cs == 0) {
 						fprintf(stderr, "connection-state: ");
 						cs = 1;
@@ -1368,7 +1383,9 @@
 #endif
 				}
 
+#ifdef DEBUG_CONNECTION_STATES
 				if (cs == 1) fprintf(stderr, "\n");
+#endif
 			}
 		}
 
@@ -1411,8 +1428,8 @@
 
 						/* network_close() will cleanup after us */
 
-						if (srv->srvconf.pid_file->used &&
-						    srv->srvconf.changeroot->used == 0) {
+						if (!buffer_string_is_empty(srv->srvconf.pid_file) &&
+						    buffer_string_is_empty(srv->srvconf.changeroot)) {
 							if (0 != unlink(srv->srvconf.pid_file->ptr)) {
 								if (errno != EACCES && errno != EPERM) {
 									log_error_write(srv, __FILE__, __LINE__, "sbds",
@@ -1528,8 +1545,8 @@
 		srv->joblist->used = 0;
 	}
 
-	if (srv->srvconf.pid_file->used &&
-	    srv->srvconf.changeroot->used == 0 &&
+	if (!buffer_string_is_empty(srv->srvconf.pid_file) &&
+	    buffer_string_is_empty(srv->srvconf.changeroot) &&
 	    0 == graceful_shutdown) {
 		if (0 != unlink(srv->srvconf.pid_file->ptr)) {
 			if (errno != EACCES && errno != EPERM) {
diff -u lighttpd-1.4.32/src/server.h lighttpd-1.4.36/src/server.h
--- lighttpd-1.4.32/src/server.h	2009-09-01 13:34:54.000000000 -0500
+++ lighttpd-1.4.36/src/server.h	2015-07-26 05:36:36.000000000 -0500
@@ -3,15 +3,7 @@
 
 #include "base.h"
 
-typedef struct {
-	char *key;
-	char *value;
-} two_strings;
-
-typedef enum { CONFIG_UNSET, CONFIG_DOCUMENT_ROOT } config_var_t;
-
 int config_read(server *srv, const char *fn);
 int config_set_defaults(server *srv);
-buffer *config_get_value_buffer(server *srv, connection *con, config_var_t field);
 
 #endif
diff -u lighttpd-1.4.32/src/settings.h lighttpd-1.4.36/src/settings.h
--- lighttpd-1.4.32/src/settings.h	2011-08-20 08:07:05.000000000 -0500
+++ lighttpd-1.4.36/src/settings.h	2015-07-26 05:36:36.000000000 -0500
@@ -9,6 +9,12 @@
 # define __USE_GNU /* a hack in my eyes, <fcntl.h> F_SETSIG should work with _GNU_SOURCE */
 #endif
 
+#ifdef __GNUC__
+# define LI_NORETURN __attribute__((noreturn))
+#else
+# define LI_NORETURN
+#endif
+
 #define BV(x) (1 << x)
 
 #define INET_NTOP_CACHE_MAX 4
diff -u lighttpd-1.4.32/src/stat_cache.c lighttpd-1.4.36/src/stat_cache.c
--- lighttpd-1.4.32/src/stat_cache.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.36/src/stat_cache.c	2015-07-26 05:36:36.000000000 -0500
@@ -18,6 +18,10 @@
 # include <attr/attributes.h>
 #endif
 
+#ifdef HAVE_SYS_EXTATTR_H
+# include <sys/extattr.h>
+#endif
+
 #ifdef HAVE_FAM_H
 # include <fam.h>
 #endif
@@ -69,7 +73,6 @@
 #ifdef HAVE_FAM_H
 typedef struct {
 	FAMRequest *req;
-	FAMConnection *fc;
 
 	buffer *name;
 
@@ -102,21 +105,22 @@
 #endif
 
 stat_cache *stat_cache_init(void) {
-	stat_cache *fc = NULL;
+	stat_cache *sc = NULL;
+
+	sc = calloc(1, sizeof(*sc));
 
-	fc = calloc(1, sizeof(*fc));
+	sc->dir_name = buffer_init();
+	sc->hash_key = buffer_init();
 
-	fc->dir_name = buffer_init();
-	fc->hash_key = buffer_init();
 #ifdef HAVE_FAM_H
-	fc->fam = calloc(1, sizeof(*fc->fam));
+	sc->fam_fcce_ndx = -1;
 #endif
 
 #ifdef DEBUG_STAT_CACHE
 	ctrl.size = 0;
 #endif
 
-	return fc;
+	return sc;
 }
 
 static stat_cache_entry * stat_cache_entry_init(void) {
@@ -153,12 +157,12 @@
 	return fam_dir;
 }
 
-static void fam_dir_entry_free(void *data) {
+static void fam_dir_entry_free(FAMConnection *fc, void *data) {
 	fam_dir_entry *fam_dir = data;
 
 	if (!fam_dir) return;
 
-	FAMCancelMonitor(fam_dir->fc, fam_dir->req);
+	FAMCancelMonitor(fc, fam_dir->req);
 
 	buffer_free(fam_dir->name);
 	free(fam_dir->req);
@@ -177,7 +181,7 @@
 		stat_cache_entry_free(node->data);
 		sc->files = splaytree_delete(sc->files, node->key);
 
-		assert(osize - 1 == splaytree_size(sc->files));
+		force_assert(osize - 1 == splaytree_size(sc->files));
 	}
 
 	buffer_free(sc->dir_name);
@@ -190,37 +194,50 @@
 
 		osize = sc->dirs->size;
 
-		fam_dir_entry_free(node->data);
+		fam_dir_entry_free(&sc->fam, node->data);
 		sc->dirs = splaytree_delete(sc->dirs, node->key);
 
 		if (osize == 1) {
-			assert(NULL == sc->dirs);
+			force_assert(NULL == sc->dirs);
 		} else {
-			assert(osize == (sc->dirs->size + 1));
+			force_assert(osize == (sc->dirs->size + 1));
 		}
 	}
 
-	if (sc->fam) {
-		FAMClose(sc->fam);
-		free(sc->fam);
+	if (-1 != sc->fam_fcce_ndx) {
+		/* fd events already gone */
+		sc->fam_fcce_ndx = -1;
+
+		FAMClose(&sc->fam);
 	}
 #endif
 	free(sc);
 }
 
-#ifdef HAVE_XATTR
+#if defined(HAVE_XATTR)
 static int stat_cache_attr_get(buffer *buf, char *name) {
 	int attrlen;
 	int ret;
 
-	attrlen = 1024;
-	buffer_prepare_copy(buf, attrlen);
-	attrlen--;
+	buffer_string_prepare_copy(buf, 1023);
+	attrlen = buf->size - 1;
 	if(0 == (ret = attr_get(name, "Content-Type", buf->ptr, &attrlen, 0))) {
+		buffer_commit(buf, attrlen);
+	}
+	return ret;
+}
+#elif defined(HAVE_EXTATTR)
+static int stat_cache_attr_get(buffer *buf, char *name) {
+	ssize_t attrlen;
+
+	buffer_prepare_copy(buf, 1023);
+
+	if (-1 != (attrlen = extattr_get_file(name, EXTATTR_NAMESPACE_USER, "Content-Type", buf->ptr, buf->size - 1))) {
 		buf->used = attrlen + 1;
 		buf->ptr[attrlen] = '\0';
+		return 0;
 	}
-	return ret;
+	return -1;
 }
 #endif
 
@@ -246,10 +263,8 @@
 	UNUSED(_fce);
 	/* */
 
-	if ((revent & FDEVENT_IN) &&
-	    sc->fam) {
-
-		events = FAMPending(sc->fam);
+	if (revent & FDEVENT_IN) {
+		events = FAMPending(&sc->fam);
 
 		for (i = 0; i < events; i++) {
 			FAMEvent fe;
@@ -257,7 +272,7 @@
 			splay_tree *node;
 			int ndx, j;
 
-			FAMNextEvent(sc->fam, &fe);
+			FAMNextEvent(&sc->fam, &fe);
 
 			/* handle event */
 
@@ -277,7 +292,7 @@
 
 				for (j = 0; j < 2; j++) {
 					buffer_copy_string(sc->hash_key, fe.filename);
-					buffer_append_long(sc->hash_key, j);
+					buffer_append_int(sc->hash_key, j);
 
 					ndx = hashme(sc->hash_key);
 
@@ -287,10 +302,10 @@
 					if (node && (node->key == ndx)) {
 						int osize = splaytree_size(sc->dirs);
 
-						fam_dir_entry_free(node->data);
+						fam_dir_entry_free(&sc->fam, node->data);
 						sc->dirs = splaytree_delete(sc->dirs, ndx);
 
-						assert(osize - 1 == splaytree_size(sc->dirs));
+						force_assert(osize - 1 == splaytree_size(sc->dirs));
 					}
 				}
 				break;
@@ -302,15 +317,10 @@
 
 	if (revent & FDEVENT_HUP) {
 		/* fam closed the connection */
-		srv->stat_cache->fam_fcce_ndx = -1;
+		fdevent_event_del(srv->ev, &(sc->fam_fcce_ndx), FAMCONNECTION_GETFD(&sc->fam));
+		fdevent_unregister(srv->ev, FAMCONNECTION_GETFD(&sc->fam));
 
-		fdevent_event_del(srv->ev, &(sc->fam_fcce_ndx), FAMCONNECTION_GETFD(sc->fam));
-		fdevent_unregister(srv->ev, FAMCONNECTION_GETFD(sc->fam));
-
-		FAMClose(sc->fam);
-		free(sc->fam);
-
-		sc->fam = NULL;
+		FAMClose(&sc->fam);
 	}
 
 	return HANDLER_GO_ON;
@@ -319,9 +329,9 @@
 static int buffer_copy_dirname(buffer *dst, buffer *file) {
 	size_t i;
 
-	if (buffer_is_empty(file)) return -1;
+	if (buffer_string_is_empty(file)) return -1;
 
-	for (i = file->used - 1; i+1 > 0; i--) {
+	for (i = buffer_string_length(file); i > 0; i--) {
 		if (file->ptr[i] == '/') {
 			buffer_copy_string_len(dst, file->ptr, i);
 			return 0;
@@ -382,8 +392,8 @@
 
 	sc = srv->stat_cache;
 
-	buffer_copy_string_buffer(sc->hash_key, name);
-	buffer_append_long(sc->hash_key, con->conf.follow_symlink);
+	buffer_copy_buffer(sc->hash_key, name);
+	buffer_append_int(sc->hash_key, con->conf.follow_symlink);
 
 	file_ndx = hashme(sc->hash_key);
 	sc->files = splaytree_splay(sc->files, file_ndx);
@@ -397,7 +407,7 @@
 	if (sc->files && (sc->files->key == file_ndx)) {
 #ifdef DEBUG_STAT_CACHE
 		/* it was in the cache */
-		assert(i < ctrl.used);
+		force_assert(i < ctrl.used);
 #endif
 
 		/* we have seen this file already and
@@ -435,7 +445,7 @@
 			log_error_write(srv, __FILE__, __LINE__, "xSB",
 				file_ndx, "was already inserted but not found in cache, ", name);
 		}
-		assert(i == ctrl.used);
+		force_assert(i == ctrl.used);
 #endif
 	}
 
@@ -448,8 +458,8 @@
 			return HANDLER_ERROR;
 		}
 
-		buffer_copy_string_buffer(sc->hash_key, sc->dir_name);
-		buffer_append_long(sc->hash_key, con->conf.follow_symlink);
+		buffer_copy_buffer(sc->hash_key, sc->dir_name);
+		buffer_append_int(sc->hash_key, con->conf.follow_symlink);
 
 		dir_ndx = hashme(sc->hash_key);
 
@@ -488,7 +498,7 @@
 
 	if (S_ISREG(st.st_mode)) {
 		/* fix broken stat/open for symlinks to reg files with appended slash on freebsd,osx */
-		if (name->ptr[name->used-2] == '/') {
+		if (name->ptr[buffer_string_length(name) - 1] == '/') {
 			errno = ENOTDIR;
 			return HANDLER_ERROR;
 		}
@@ -506,7 +516,7 @@
 #endif
 
 		sce = stat_cache_entry_init();
-		buffer_copy_string_buffer(sce->name, name);
+		buffer_copy_buffer(sce->name, name);
 
 		sc->files = splaytree_insert(sc->files, file_ndx, sce);
 #ifdef DEBUG_STAT_CACHE
@@ -521,9 +531,9 @@
 
 		ctrl.ptr[ctrl.used++] = file_ndx;
 
-		assert(sc->files);
-		assert(sc->files->data == sce);
-		assert(osize + 1 == splaytree_size(sc->files));
+		force_assert(sc->files);
+		force_assert(sc->files->data == sce);
+		force_assert(osize + 1 == splaytree_size(sc->files));
 #endif
 	}
 
@@ -560,16 +570,15 @@
 		 * we assume "/" can not be symlink, so
 		 * skip the symlink stuff if our path is /
 		 **/
-		else if ((name->used > 2)) {
+		else if (buffer_string_length(name) > 1) {
 			buffer *dname;
 			char *s_cur;
 
 			dname = buffer_init();
-			buffer_copy_string_buffer(dname, name);
+			buffer_copy_buffer(dname, name);
 
-			while ((s_cur = strrchr(dname->ptr,'/'))) {
-				*s_cur = '\0';
-				dname->used = s_cur - dname->ptr + 1;
+			while ((s_cur = strrchr(dname->ptr, '/'))) {
+				buffer_string_set_length(dname, s_cur - dname->ptr);
 				if (dname->ptr == s_cur) {
 #ifdef DEBUG_STAT_CACHE
 					log_error_write(srv, __FILE__, __LINE__, "s", "reached /");
@@ -597,24 +606,27 @@
 	if (S_ISREG(st.st_mode)) {
 		/* determine mimetype */
 		buffer_reset(sce->content_type);
-#ifdef HAVE_XATTR
+#if defined(HAVE_XATTR) || defined(HAVE_EXTATTR)
 		if (con->conf.use_xattr) {
 			stat_cache_attr_get(sce->content_type, name->ptr);
 		}
 #endif
 		/* xattr did not set a content-type. ask the config */
-		if (buffer_is_empty(sce->content_type)) {
+		if (buffer_string_is_empty(sce->content_type)) {
+			size_t namelen = buffer_string_length(name);
+
 			for (k = 0; k < con->conf.mimetypes->used; k++) {
 				data_string *ds = (data_string *)con->conf.mimetypes->data[k];
 				buffer *type = ds->key;
+				size_t typelen = buffer_string_length(type);
 
-				if (type->used == 0) continue;
+				if (buffer_is_empty(type)) continue;
 
 				/* check if the right side is the same */
-				if (type->used > name->used) continue;
+				if (typelen > namelen) continue;
 
-				if (0 == strncasecmp(name->ptr + name->used - type->used, type->ptr, type->used - 1)) {
-					buffer_copy_string_buffer(sce->content_type, ds->value);
+				if (0 == strncasecmp(name->ptr + namelen - typelen, type->ptr, typelen)) {
+					buffer_copy_buffer(sce->content_type, ds->value);
 					break;
 				}
 			}
@@ -625,20 +637,18 @@
 	}
 
 #ifdef HAVE_FAM_H
-	if (sc->fam &&
-	    (srv->srvconf.stat_cache_engine == STAT_CACHE_ENGINE_FAM)) {
+	if (srv->srvconf.stat_cache_engine == STAT_CACHE_ENGINE_FAM) {
 		/* is this directory already registered ? */
 		if (!dir_node) {
 			fam_dir = fam_dir_entry_init();
-			fam_dir->fc = sc->fam;
 
-			buffer_copy_string_buffer(fam_dir->name, sc->dir_name);
+			buffer_copy_buffer(fam_dir->name, sc->dir_name);
 
 			fam_dir->version = 1;
 
 			fam_dir->req = calloc(1, sizeof(FAMRequest));
 
-			if (0 != FAMMonitorDirectory(sc->fam, fam_dir->name->ptr,
+			if (0 != FAMMonitorDirectory(&sc->fam, fam_dir->name->ptr,
 						     fam_dir->req, fam_dir)) {
 
 				log_error_write(srv, __FILE__, __LINE__, "sbsbs",
@@ -647,18 +657,19 @@
 						"file:", name,
 						FamErrlist[FAMErrno]);
 
-				fam_dir_entry_free(fam_dir);
+				fam_dir_entry_free(&sc->fam, fam_dir);
+				fam_dir = NULL;
 			} else {
 				int osize = 0;
 
-			       	if (sc->dirs) {
+				if (sc->dirs) {
 					osize = sc->dirs->size;
 				}
 
 				sc->dirs = splaytree_insert(sc->dirs, dir_ndx, fam_dir);
-				assert(sc->dirs);
-				assert(sc->dirs->data == fam_dir);
-				assert(osize == (sc->dirs->size - 1));
+				force_assert(sc->dirs);
+				force_assert(sc->dirs->data == fam_dir);
+				force_assert(osize == (sc->dirs->size - 1));
 			}
 		} else {
 			fam_dir = dir_node->data;
@@ -668,7 +679,6 @@
 
 		if (fam_dir) {
 			sce->dir_version = fam_dir->version;
-			sce->dir_ndx     = dir_ndx;
 		}
 	}
 #endif
@@ -713,7 +723,7 @@
 
 	if (!sc->files) return 0;
 
-	keys = calloc(1, sizeof(size_t) * sc->files->size);
+	keys = calloc(1, sizeof(int) * sc->files->size);
 
 	stat_cache_tag_old_entries(srv, sc->files, keys, &max_ndx);
 
@@ -742,7 +752,7 @@
 				}
 			}
 
-			assert(osize - 1 == splaytree_size(sc->files));
+			force_assert(osize - 1 == splaytree_size(sc->files));
 #endif
 		}
 	}
diff -u lighttpd-1.4.32/src/stream.c lighttpd-1.4.36/src/stream.c
--- lighttpd-1.4.32/src/stream.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.36/src/stream.c	2015-07-26 05:36:36.000000000 -0500
@@ -22,23 +22,28 @@
 #endif
 
 	f->start = NULL;
+	f->size = 0;
 
 	if (-1 == stat(fn->ptr, &st)) {
 		return -1;
 	}
 
-	f->size = st.st_size;
+	if (0 == st.st_size) {
+		/* empty file doesn't need a mapping */
+		return 0;
+	}
 
 #ifdef HAVE_MMAP
 	if (-1 == (fd = open(fn->ptr, O_RDONLY | O_BINARY))) {
 		return -1;
 	}
 
-	f->start = mmap(NULL, f->size, PROT_READ, MAP_SHARED, fd, 0);
+	f->start = mmap(NULL, st.st_size, PROT_READ, MAP_SHARED, fd, 0);
 
 	close(fd);
 
 	if (MAP_FAILED == f->start) {
+		f->start = NULL;
 		return -1;
 	}
 
@@ -56,8 +61,8 @@
 	mh = CreateFileMapping( fh,
 			NULL,
 			PAGE_READONLY,
-			(sizeof(off_t) > 4) ? f->size >> 32 : 0,
-			f->size & 0xffffffff,
+			(sizeof(off_t) > 4) ? st.st_size >> 32 : 0,
+			st.st_size & 0xffffffff,
 			NULL);
 
 	if (!mh) {
@@ -88,6 +93,8 @@
 # error no mmap found
 #endif
 
+	f->size = st.st_size;
+
 	return 0;
 }
 
@@ -99,6 +106,7 @@
 #endif
 
 	f->start = NULL;
+	f->size = 0;
 
 	return 0;
 }
