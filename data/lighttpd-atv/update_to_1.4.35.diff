diff -u lighttpd-1.4.32/src/array.c lighttpd-1.4.35/src/array.c
--- lighttpd-1.4.32/src/array.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/array.c	2014-03-06 08:08:00.000000000 -0600
@@ -13,7 +13,7 @@
 	array *a;
 
 	a = calloc(1, sizeof(*a));
-	assert(a);
+	force_assert(a);
 
 	a->next_power_of_2 = 1;
 
@@ -24,6 +24,8 @@
 	size_t i;
 	array *a = array_init();
 
+	if (0 == src->size) return a;
+
 	a->used = src->used;
 	a->size = src->size;
 	a->next_power_of_2 = src->next_power_of_2;
@@ -72,7 +74,7 @@
 data_unset *array_pop(array *a) {
 	data_unset *du;
 
-	assert(a->used != 0);
+	force_assert(a->used != 0);
 
 	a->used --;
 	du = a->data[a->used];
@@ -168,6 +170,7 @@
 data_unset *array_replace(array *a, data_unset *du) {
 	int ndx;
 
+	force_assert(NULL != du);
 	if (-1 == (ndx = array_get_index(a, du->key->ptr, du->key->used, NULL))) {
 		array_insert_unique(a, du);
 		return NULL;
@@ -211,15 +214,15 @@
 		a->size   = 16;
 		a->data   = malloc(sizeof(*a->data)     * a->size);
 		a->sorted = malloc(sizeof(*a->sorted)   * a->size);
-		assert(a->data);
-		assert(a->sorted);
+		force_assert(a->data);
+		force_assert(a->sorted);
 		for (j = a->used; j < a->size; j++) a->data[j] = NULL;
 	} else if (a->size == a->used) {
 		a->size  += 16;
 		a->data   = realloc(a->data,   sizeof(*a->data)   * a->size);
 		a->sorted = realloc(a->sorted, sizeof(*a->sorted) * a->size);
-		assert(a->data);
-		assert(a->sorted);
+		force_assert(a->data);
+		force_assert(a->sorted);
 		for (j = a->used; j < a->size; j++) a->data[j] = NULL;
 	}
 
diff -u lighttpd-1.4.32/src/base.h lighttpd-1.4.35/src/base.h
--- lighttpd-1.4.32/src/base.h	2011-11-30 13:43:35.000000000 -0600
+++ lighttpd-1.4.35/src/base.h	2014-03-06 08:08:00.000000000 -0600
@@ -222,7 +222,6 @@
 
 #ifdef HAVE_FAM_H
 	int    dir_version;
-	int    dir_ndx;
 #endif
 
 	buffer *content_type;
@@ -235,7 +234,7 @@
 #ifdef HAVE_FAM_H
 	splay_tree *dirs; /* the nodes of the tree are fam_dir_entry */
 
-	FAMConnection *fam;
+	FAMConnection fam;
 	int    fam_fcce_ndx;
 #endif
 	buffer *hash_key;  /* temp-store for the hash-key */
@@ -278,6 +277,7 @@
 	buffer *ssl_dh_file;
 	buffer *ssl_ec_curve;
 	unsigned short ssl_honor_cipher_order; /* determine SSL cipher in server-preferred order, not client-order */
+	unsigned short ssl_empty_fragments; /* whether to not set SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS */
 	unsigned short ssl_use_sslv2;
 	unsigned short ssl_use_sslv3;
 	unsigned short ssl_verifyclient;
@@ -289,7 +289,7 @@
 
 	unsigned short use_ipv6, set_v6only; /* set_v6only is only a temporary option */
 	unsigned short defer_accept;
-	unsigned short is_ssl;
+	unsigned short ssl_enabled; /* only interesting for setting up listening sockets. don't use at runtime */
 	unsigned short allow_http11;
 	unsigned short etag_use_inode;
 	unsigned short etag_use_mtime;
@@ -319,7 +319,11 @@
 	off_t *global_bytes_per_second_cnt_ptr; /*  */
 
 #ifdef USE_OPENSSL
-	SSL_CTX *ssl_ctx;
+	SSL_CTX *ssl_ctx; /* not patched */
+	/* SNI per host: with COMP_SERVER_SOCKET, COMP_HTTP_SCHEME, COMP_HTTP_HOST */
+	EVP_PKEY *ssl_pemfile_pkey;
+	X509 *ssl_pemfile_x509;
+	STACK_OF(X509_NAME) *ssl_ca_file_cert_names;
 #endif
 } specific_config;
 
@@ -410,7 +414,6 @@
 
 	size_t header_len;
 
-	buffer *authed_user;
 	array  *environment; /* used to pass lighttpd internal stuff to the FastCGI/CGI apps, setenv does that */
 
 	/* response */
@@ -432,7 +435,7 @@
 	int error_handler_saved_status;
 	int in_error_handler;
 
-	void *srv_socket;   /* reference to the server-socket (typecast to server_socket) */
+	struct server_socket *srv_socket;   /* reference to the server-socket */
 
 #ifdef USE_OPENSSL
 	SSL *ssl;
@@ -525,19 +528,11 @@
 	unsigned short reject_expect_100_with_417;
 } server_config;
 
-typedef struct {
+typedef struct server_socket {
 	sock_addr addr;
 	int       fd;
 	int       fde_ndx;
 
-	buffer *ssl_pemfile;
-	buffer *ssl_ca_file;
-	buffer *ssl_cipher_list;
-	buffer *ssl_dh_file;
-	buffer *ssl_ec_curve;
-	unsigned short ssl_use_sslv2;
-	unsigned short ssl_use_sslv3;
-	unsigned short use_ipv6;
 	unsigned short is_ssl;
 
 	buffer *srv_token;
@@ -545,7 +540,6 @@
 #ifdef USE_OPENSSL
 	SSL_CTX *ssl_ctx;
 #endif
-       unsigned short is_proxy_ssl;
 } server_socket;
 
 typedef struct {
diff -u lighttpd-1.4.32/src/bitset.c lighttpd-1.4.35/src/bitset.c
--- lighttpd-1.4.32/src/bitset.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/bitset.c	2014-03-06 08:08:00.000000000 -0600
@@ -23,12 +23,12 @@
 	bitset *set;
 
 	set = malloc(sizeof(*set));
-	assert(set);
+	force_assert(set);
 
 	set->bits = calloc(BITSET_USED(nbits), sizeof(*set->bits));
 	set->nbits = nbits;
 
-	assert(set->bits);
+	force_assert(set->bits);
 
 	return set;
 }
diff -u lighttpd-1.4.32/src/buffer.c lighttpd-1.4.35/src/buffer.c
--- lighttpd-1.4.32/src/buffer.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.35/src/buffer.c	2014-03-06 08:08:00.000000000 -0600
@@ -7,6 +7,11 @@
 #include <assert.h>
 #include <ctype.h>
 
+#if defined HAVE_STDINT_H
+# include <stdint.h>
+#elif defined HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
 
 static const char hex_chars[] = "0123456789abcdef";
 
@@ -20,7 +25,7 @@
 	buffer *b;
 
 	b = malloc(sizeof(*b));
-	assert(b);
+	force_assert(b);
 
 	b->ptr = NULL;
 	b->size = 0;
@@ -85,7 +90,7 @@
 		b->size += BUFFER_PIECE_SIZE - (b->size % BUFFER_PIECE_SIZE);
 
 		b->ptr = malloc(b->size);
-		assert(b->ptr);
+		force_assert(b->ptr);
 	}
 	b->used = 0;
 	return 0;
@@ -109,7 +114,7 @@
 
 		b->ptr = malloc(b->size);
 		b->used = 0;
-		assert(b->ptr);
+		force_assert(b->ptr);
 	} else if (b->used + size > b->size) {
 		b->size += size;
 
@@ -117,7 +122,7 @@
 		b->size += BUFFER_PIECE_SIZE - (b->size % BUFFER_PIECE_SIZE);
 
 		b->ptr = realloc(b->ptr, b->size);
-		assert(b->ptr);
+		force_assert(b->ptr);
 	}
 	return 0;
 }
@@ -414,7 +419,7 @@
 
 	b = malloc(sizeof(*b));
 
-	assert(b);
+	force_assert(b);
 	b->ptr = NULL;
 	b->size = 0;
 	b->used = 0;
@@ -458,14 +463,14 @@
 	if (b->size == 0) {
 		b->size = 16;
 		b->ptr = malloc(sizeof(*b->ptr) * b->size);
-		assert(b->ptr);
+		force_assert(b->ptr);
 		for (i = 0; i < b->size; i++) {
 			b->ptr[i] = NULL;
 		}
 	} else if (b->size == b->used) {
 		b->size += 16;
 		b->ptr = realloc(b->ptr, sizeof(*b->ptr) * b->size);
-		assert(b->ptr);
+		force_assert(b->ptr);
 		for (i = b->used; i < b->size; i++) {
 			b->ptr[i] = NULL;
 		}
@@ -533,60 +538,38 @@
 	return buffer_is_equal(a, &b);
 }
 
-/* simple-assumption:
- *
- * most parts are equal and doing a case conversion needs time
- *
- */
-int buffer_caseless_compare(const char *a, size_t a_len, const char *b, size_t b_len) {
-	size_t ndx = 0, max_ndx;
-	size_t *al, *bl;
-	size_t mask = sizeof(*al) - 1;
-
-	al = (size_t *)a;
-	bl = (size_t *)b;
-
-	/* is the alignment correct ? */
-	if ( ((size_t)al & mask) == 0 &&
-	     ((size_t)bl & mask) == 0 ) {
-
-		max_ndx = ((a_len < b_len) ? a_len : b_len) & ~mask;
-
-		for (; ndx < max_ndx; ndx += sizeof(*al)) {
-			if (*al != *bl) break;
-			al++; bl++;
+/* buffer_is_equal_caseless_string(b, CONST_STR_LEN("value")) */
+int buffer_is_equal_caseless_string(buffer *a, const char *s, size_t b_len) {
+	if (a->used != b_len + 1) return 0;
 
-		}
-
-	}
-
-	a = (char *)al;
-	b = (char *)bl;
-
-	max_ndx = ((a_len < b_len) ? a_len : b_len);
+	return (0 == strcasecmp(a->ptr, s));
+}
 
-	for (; ndx < max_ndx; ndx++) {
-		int a1 = *a++, b1 = *b++;
+int buffer_caseless_compare(const char *a, size_t a_len, const char *b, size_t b_len) {
+	size_t const len = (a_len < b_len) ? a_len : b_len;
+	size_t i;
 
-		if (a1 != b1) {
-			/* always lowercase for transitive results */
-			if (a1 >= 'A' && a1 <= 'Z') a1 |= 32;
-			if (b1 >= 'A' && b1 <= 'Z') b1 |= 32;
+	for (i = 0; i < len; ++i) {
+		unsigned char ca = a[i], cb = b[i];
+		if (ca == cb) continue;
+
+		/* always lowercase for transitive results */
+#if 1
+		if (ca >= 'A' && ca <= 'Z') ca |= 32;
+		if (cb >= 'A' && cb <= 'Z') cb |= 32;
+#else
+		/* try to produce code without branching (jumps) */
+		ca |= ((unsigned char)(ca - (unsigned char)'A') <= (unsigned char)('Z' - 'A')) ? 32 : 0;
+		cb |= ((unsigned char)(cb - (unsigned char)'A') <= (unsigned char)('Z' - 'A')) ? 32 : 0;
+#endif
 
-			if ((a1 - b1) != 0) return (a1 - b1);
-		}
+		if (ca == cb) continue;
+		return ca - cb;
 	}
-
-	/* all chars are the same, and the length match too
-	 *
-	 * they are the same */
 	if (a_len == b_len) return 0;
-
-	/* if a is shorter then b, then b is larger */
-	return (a_len - b_len);
+	return a_len - b_len;
 }
 
-
 /**
  * check if the rightmost bytes of the string are equal.
  *
@@ -601,7 +584,7 @@
 	if (b1->used == 0 || b2->used == 0) return 0;
 
 	/* buffers too small -> not equal */
-	if (b1->used - 1 < len || b1->used - 1 < len) return 0;
+	if (b1->used - 1 < len || b2->used - 1 < len) return 0;
 
 	if (0 == strncmp(b1->ptr + b1->used - 1 - len,
 			 b2->ptr + b2->used - 1 - len, len)) {
@@ -800,7 +783,7 @@
 		break;
 	}
 
-	assert(map != NULL);
+	force_assert(map != NULL);
 
 	/* count to-be-encoded-characters */
 	for (ds = (unsigned char *)s, d_len = 0, ndx = 0; ndx < s_len; ds++, ndx++) {
@@ -1075,3 +1058,10 @@
 
 	return 0;
 }
+
+void log_failed_assert(const char *filename, unsigned int line, const char *msg) {
+	/* can't use buffer here; could lead to recursive assertions */
+	fprintf(stderr, "%s.%d: %s\n", filename, line, msg);
+	fflush(stderr);
+	abort();
+}
diff -u lighttpd-1.4.32/src/buffer.h lighttpd-1.4.35/src/buffer.h
--- lighttpd-1.4.32/src/buffer.h	2010-08-22 06:28:46.000000000 -0500
+++ lighttpd-1.4.35/src/buffer.h	2014-03-06 08:08:00.000000000 -0600
@@ -9,7 +9,6 @@
 
 #include <stdlib.h>
 #include <sys/types.h>
-#include <stdio.h>
 
 typedef struct {
 	char *ptr;
@@ -82,6 +81,7 @@
 int buffer_is_equal(buffer *a, buffer *b);
 int buffer_is_equal_right_len(buffer *a, buffer *b, size_t len);
 int buffer_is_equal_string(buffer *a, const char *s, size_t b_len);
+int buffer_is_equal_caseless_string(buffer *a, const char *s, size_t b_len);
 int buffer_caseless_compare(const char *a, size_t a_len, const char *b, size_t b_len);
 
 typedef enum {
@@ -126,7 +126,10 @@
 #define CONST_BUF_LEN(x) x->ptr, x->used ? x->used - 1 : 0
 
 
-#define SEGFAULT() do { fprintf(stderr, "%s.%d: aborted\n", __FILE__, __LINE__); abort(); } while(0)
 #define UNUSED(x) ( (void)(x) )
 
+void log_failed_assert(const char *filename, unsigned int line, const char *msg) LI_NORETURN;
+#define force_assert(x) do { if (!(x)) log_failed_assert(__FILE__, __LINE__, "assertion failed: " #x); } while(0)
+#define SEGFAULT() log_failed_assert(__FILE__, __LINE__, "aborted");
+
 #endif
diff -u lighttpd-1.4.32/src/configfile.c lighttpd-1.4.35/src/configfile.c
--- lighttpd-1.4.32/src/configfile.c	2012-11-07 08:50:29.000000000 -0600
+++ lighttpd-1.4.35/src/configfile.c	2014-03-06 08:08:00.000000000 -0600
@@ -107,6 +107,7 @@
 		{ "ssl.ec-curve",                NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_SERVER },      /* 64 */
 		{ "ssl.disable-client-renegotiation", NULL, T_CONFIG_BOOLEAN, T_CONFIG_SCOPE_SERVER },/* 65 */
 		{ "ssl.honor-cipher-order",      NULL, T_CONFIG_BOOLEAN, T_CONFIG_SCOPE_SERVER },     /* 66 */
+		{ "ssl.empty-fragments",         NULL, T_CONFIG_BOOLEAN, T_CONFIG_SCOPE_SERVER },     /* 67 */
 
 		{ "server.host",                 "use server.bind instead", T_CONFIG_DEPRECATED, T_CONFIG_SCOPE_UNSET },
 		{ "server.docroot",              "use server.document-root instead", T_CONFIG_DEPRECATED, T_CONFIG_SCOPE_UNSET },
@@ -154,13 +155,13 @@
 
 	srv->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
 
-	assert(srv->config_storage);
+	force_assert(srv->config_storage);
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		specific_config *s;
 
 		s = calloc(1, sizeof(specific_config));
-		assert(s);
+		force_assert(s);
 		s->document_root = buffer_init();
 		s->mimetypes     = array_init();
 		s->server_name   = buffer_init();
@@ -177,8 +178,9 @@
 		s->max_read_idle = 60;
 		s->max_write_idle = 360;
 		s->use_xattr     = 0;
-		s->is_ssl        = 0;
+		s->ssl_enabled   = 0;
 		s->ssl_honor_cipher_order = 1;
+		s->ssl_empty_fragments = 0;
 		s->ssl_use_sslv2 = 0;
 		s->ssl_use_sslv3 = 1;
 		s->use_ipv6      = 0;
@@ -231,7 +233,7 @@
 		cv[27].destination = &(s->use_xattr);
 		cv[28].destination = s->mimetypes;
 		cv[29].destination = s->ssl_pemfile;
-		cv[30].destination = &(s->is_ssl);
+		cv[30].destination = &(s->ssl_enabled);
 
 		cv[31].destination = &(s->log_file_not_found);
 		cv[32].destination = &(s->log_request_handling);
@@ -250,6 +252,7 @@
 		cv[63].destination = s->ssl_dh_file;
 		cv[64].destination = s->ssl_ec_curve;
 		cv[66].destination = &(s->ssl_honor_cipher_order);
+		cv[67].destination = &(s->ssl_empty_fragments);
 
 		cv[49].destination = &(s->etag_use_inode);
 		cv[50].destination = &(s->etag_use_mtime);
@@ -332,17 +335,22 @@
 
 	PATCH(range_requests);
 	PATCH(force_lowercase_filenames);
-	PATCH(is_ssl);
+	PATCH(ssl_enabled);
 
 	PATCH(ssl_pemfile);
 #ifdef USE_OPENSSL
-	PATCH(ssl_ctx);
+	PATCH(ssl_pemfile_x509);
+	PATCH(ssl_pemfile_pkey);
 #endif
 	PATCH(ssl_ca_file);
+#ifdef USE_OPENSSL
+	PATCH(ssl_ca_file_cert_names);
+#endif
 	PATCH(ssl_cipher_list);
 	PATCH(ssl_dh_file);
 	PATCH(ssl_ec_curve);
 	PATCH(ssl_honor_cipher_order);
+	PATCH(ssl_empty_fragments);
 	PATCH(ssl_use_sslv2);
 	PATCH(ssl_use_sslv3);
 	PATCH(etag_use_inode);
@@ -405,12 +413,18 @@
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.pemfile"))) {
 				PATCH(ssl_pemfile);
 #ifdef USE_OPENSSL
-				PATCH(ssl_ctx);
+				PATCH(ssl_pemfile_x509);
+				PATCH(ssl_pemfile_pkey);
 #endif
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.ca-file"))) {
 				PATCH(ssl_ca_file);
+#ifdef USE_OPENSSL
+				PATCH(ssl_ca_file_cert_names);
+#endif
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.honor-cipher-order"))) {
 				PATCH(ssl_honor_cipher_order);
+			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.empty-fragments"))) {
+				PATCH(ssl_empty_fragments);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.use-sslv2"))) {
 				PATCH(ssl_use_sslv2);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.use-sslv3"))) {
@@ -418,7 +432,7 @@
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.cipher-list"))) {
 				PATCH(ssl_cipher_list);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.engine"))) {
-				PATCH(is_ssl);
+				PATCH(ssl_enabled);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.dh-file"))) {
 				PATCH(ssl_dh_file);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("ssl.ec-curve"))) {
@@ -535,7 +549,7 @@
 #endif
 static int config_skip_newline(tokenizer_t *t) {
 	int skipped = 1;
-	assert(t->input[t->offset] == '\r' || t->input[t->offset] == '\n');
+	force_assert(t->input[t->offset] == '\r' || t->input[t->offset] == '\n');
 	if (t->input[t->offset] == '\r' && t->input[t->offset + 1] == '\n') {
 		skipped ++;
 		t->offset ++;
@@ -546,7 +560,7 @@
 
 static int config_skip_comment(tokenizer_t *t) {
 	int i;
-	assert(t->input[t->offset] == '#');
+	force_assert(t->input[t->offset] == '#');
 	for (i = 1; t->input[t->offset + i] &&
 	     (t->input[t->offset + i] != '\n' && t->input[t->offset + i] != '\r');
 	     i++);
@@ -1012,7 +1026,10 @@
 	s = malloc(len);
 	if (!s) return NULL;
 	while (NULL == getcwd(s, len)) {
-		if (errno != ERANGE || SSIZE_MAX - len < len) return NULL;
+		if (errno != ERANGE || SSIZE_MAX - len < len) {
+			free(s);
+			return NULL;
+		}
 		len *= 2;
 		s1 = realloc(s, len);
 		if (!s1) {
@@ -1098,7 +1115,7 @@
 	dc = data_config_init();
 	buffer_copy_string_len(dc->key, CONST_STR_LEN("global"));
 
-	assert(context.all_configs->used == 0);
+	force_assert(context.all_configs->used == 0);
 	dc->context_ndx = context.all_configs->used;
 	array_insert_unique(context.all_configs, (data_unset *)dc);
 	context.current = dc;
@@ -1116,12 +1133,14 @@
 		dcwd->value->used = strlen(dcwd->value->ptr) + 1;
 		buffer_copy_string_len(dcwd->key, CONST_STR_LEN("var.CWD"));
 		array_insert_unique(srv->config, (data_unset *)dcwd);
+	} else {
+		dcwd->free((data_unset*) dcwd);
 	}
 
 	ret = config_parse_file(srv, &context, fn);
 
 	/* remains nothing if parser is ok */
-	assert(!(0 == ret && context.ok && 0 != context.configs_stack->used));
+	force_assert(!(0 == ret && context.ok && 0 != context.configs_stack->used));
 	context_free(&context);
 
 	if (0 != ret) {
@@ -1153,6 +1172,7 @@
 		}
 
 		prepends = (data_array *)configparser_merge_data((data_unset *)prepends, (data_unset *)modules);
+		force_assert(NULL != prepends);
 		buffer_copy_string_buffer(prepends->key, modules->key);
 		array_replace(srv->config, (data_unset *)prepends);
 		modules->free((data_unset *)modules);
@@ -1235,33 +1255,24 @@
 		{ FDEVENT_HANDLER_UNSET,          NULL }
 	};
 
-
-	if (buffer_is_empty(s->document_root)) {
-		log_error_write(srv, __FILE__, __LINE__, "s",
-				"a default document-root has to be set");
-
-		return -1;
-	}
-
-	if (buffer_is_empty(srv->srvconf.changeroot)) {
-		if (-1 == stat(s->document_root->ptr, &st1)) {
+	if (!buffer_is_empty(srv->srvconf.changeroot)) {
+		if (-1 == stat(srv->srvconf.changeroot->ptr, &st1)) {
 			log_error_write(srv, __FILE__, __LINE__, "sb",
-					"base-docroot doesn't exist:",
-					s->document_root);
+					"server.chroot doesn't exist:", srv->srvconf.changeroot);
 			return -1;
 		}
-
-	} else {
-		buffer_copy_string_buffer(srv->tmp_buf, srv->srvconf.changeroot);
-		buffer_append_string_buffer(srv->tmp_buf, s->document_root);
-
-		if (-1 == stat(srv->tmp_buf->ptr, &st1)) {
+		if (!S_ISDIR(st1.st_mode)) {
 			log_error_write(srv, __FILE__, __LINE__, "sb",
-					"base-docroot doesn't exist:",
-					srv->tmp_buf);
+					"server.chroot isn't a directory:", srv->srvconf.changeroot);
 			return -1;
 		}
+	}
+
+	if (buffer_is_empty(s->document_root)) {
+		log_error_write(srv, __FILE__, __LINE__, "s",
+				"a default document-root has to be set");
 
+		return -1;
 	}
 
 	buffer_copy_string_buffer(srv->tmp_buf, s->document_root);
@@ -1306,7 +1317,7 @@
 	}
 
 	if (srv->srvconf.port == 0) {
-		srv->srvconf.port = s->is_ssl ? 443 : 80;
+		srv->srvconf.port = s->ssl_enabled ? 443 : 80;
 	}
 
 	if (srv->srvconf.event_handler->used == 0) {
@@ -1344,7 +1355,7 @@
 		}
 	}
 
-	if (s->is_ssl) {
+	if (s->ssl_enabled) {
 		if (buffer_is_empty(s->ssl_pemfile)) {
 			/* PEM file is require */
 
diff -u lighttpd-1.4.32/src/configparser.c lighttpd-1.4.35/src/configparser.c
--- lighttpd-1.4.32/src/configparser.c	2012-11-20 04:56:43.000000000 -0600
+++ lighttpd-1.4.35/src/configparser.c	2014-03-11 06:57:41.000000000 -0500
@@ -17,7 +17,7 @@
 static void configparser_push(config_t *ctx, data_config *dc, int isnew) {
   if (isnew) {
     dc->context_ndx = ctx->all_configs->used;
-    assert(dc->context_ndx > ctx->current->context_ndx);
+    force_assert(dc->context_ndx > ctx->current->context_ndx);
     array_insert_unique(ctx->all_configs, (data_unset *)dc);
     dc->parent = ctx->current;
     array_insert_unique(dc->parent->childs, (data_unset *)dc);
@@ -99,7 +99,7 @@
       }
       break;
     default:
-      assert(0);
+      force_assert(0);
       break;
     }
   }
@@ -1094,7 +1094,7 @@
 {
   data_config *dc;
   dc = (data_config *)array_get_element(ctx->srv->config_context, "global");
-  assert(dc);
+  force_assert(dc);
   configparser_push(ctx, dc, 0);
 }
 #line 1100 "configparser.c"
@@ -1108,7 +1108,7 @@
   cur = ctx->current;
   configparser_pop(ctx);
 
-  assert(cur && ctx->current);
+  force_assert(cur && ctx->current);
 
   yygotominor.yy78 = cur;
 }
@@ -1151,7 +1151,7 @@
   cur = ctx->current;
   configparser_pop(ctx);
 
-  assert(cur && ctx->current);
+  force_assert(cur && ctx->current);
 
   yygotominor.yy78 = cur;
 }
@@ -1186,7 +1186,7 @@
     op = buffer_init_string("=~");
     break;
   default:
-    assert(0);
+    force_assert(0);
     return;
   }
 
diff -u lighttpd-1.4.32/src/configparser.y lighttpd-1.4.35/src/configparser.y
--- lighttpd-1.4.32/src/configparser.y	2012-04-08 02:57:56.000000000 -0500
+++ lighttpd-1.4.35/src/configparser.y	2014-03-06 08:08:00.000000000 -0600
@@ -14,7 +14,7 @@
 static void configparser_push(config_t *ctx, data_config *dc, int isnew) {
   if (isnew) {
     dc->context_ndx = ctx->all_configs->used;
-    assert(dc->context_ndx > ctx->current->context_ndx);
+    force_assert(dc->context_ndx > ctx->current->context_ndx);
     array_insert_unique(ctx->all_configs, (data_unset *)dc);
     dc->parent = ctx->current;
     array_insert_unique(dc->parent->childs, (data_unset *)dc);
@@ -96,7 +96,7 @@
       }
       break;
     default:
-      assert(0);
+      force_assert(0);
       break;
     }
   }
@@ -334,7 +334,7 @@
 globalstart ::= GLOBAL. {
   data_config *dc;
   dc = (data_config *)array_get_element(ctx->srv->config_context, "global");
-  assert(dc);
+  force_assert(dc);
   configparser_push(ctx, dc, 0);
 }
 
@@ -344,7 +344,7 @@
   cur = ctx->current;
   configparser_pop(ctx);
 
-  assert(cur && ctx->current);
+  force_assert(cur && ctx->current);
 
   A = cur;
 }
@@ -372,7 +372,7 @@
   cur = ctx->current;
   configparser_pop(ctx);
 
-  assert(cur && ctx->current);
+  force_assert(cur && ctx->current);
 
   A = cur;
 }
@@ -400,7 +400,7 @@
     op = buffer_init_string("=~");
     break;
   default:
-    assert(0);
+    force_assert(0);
     return;
   }
 
diff -u lighttpd-1.4.32/src/connections.c lighttpd-1.4.35/src/connections.c
--- lighttpd-1.4.32/src/connections.c	2012-11-07 07:16:36.000000000 -0600
+++ lighttpd-1.4.35/src/connections.c	2014-03-06 08:08:00.000000000 -0600
@@ -200,7 +200,7 @@
 	int r, ssl_err, len, count = 0, read_offset, toread;
 	buffer *b = NULL;
 
-	if (!con->conf.is_ssl) return -1;
+	if (!con->srv_socket->is_ssl) return -1;
 
 	ERR_clear_error();
 	do {
@@ -224,8 +224,8 @@
 		len = SSL_read(con->ssl, b->ptr + read_offset, toread);
 
 		if (con->renegotiations > 1 && con->conf.ssl_disable_client_renegotiation) {
+			log_error_write(srv, __FILE__, __LINE__, "s", "SSL: renegotiation initiated by client, killing connection");
 			connection_set_state(srv, con, CON_STATE_ERROR);
-			log_error_write(srv, __FILE__, __LINE__, "s", "SSL: renegotiation initiated by client");
 			return -1;
 		}
 
@@ -334,7 +334,7 @@
 	buffer *b;
 	int toread, read_offset;
 
-	if (con->conf.is_ssl) {
+	if (con->srv_socket->is_ssl) {
 		return connection_handle_read_ssl(srv, con);
 	}
 
@@ -419,16 +419,6 @@
 		case HTTP_METHOD_GET:
 		case HTTP_METHOD_POST:
 		case HTTP_METHOD_HEAD:
-		case HTTP_METHOD_PUT:
-		case HTTP_METHOD_PATCH:
-		case HTTP_METHOD_MKCOL:
-		case HTTP_METHOD_DELETE:
-		case HTTP_METHOD_COPY:
-		case HTTP_METHOD_MOVE:
-		case HTTP_METHOD_PROPFIND:
-		case HTTP_METHOD_PROPPATCH:
-		case HTTP_METHOD_LOCK:
-		case HTTP_METHOD_UNLOCK:
 			break;
 		case HTTP_METHOD_OPTIONS:
 			/*
@@ -450,16 +440,8 @@
 			}
 			break;
 		default:
-			switch(con->http_status) {
-			case 400: /* bad request */
-			case 401: /* authorization required */
-			case 414: /* overload request header */
-			case 505: /* unknown protocol */
-			case 207: /* this was webdav */
-				break;
-			default:
+			if (0 == con->http_status) {
 				con->http_status = 501;
-				break;
 			}
 			break;
 		}
@@ -694,7 +676,6 @@
 	CLEAN(physical.etag);
 	CLEAN(parse_request);
 
-	CLEAN(authed_user);
 	CLEAN(server_name);
 	CLEAN(error_handler);
 	CLEAN(dst_addr_buf);
@@ -761,7 +742,6 @@
 		CLEAN(physical.rel_path);
 		CLEAN(parse_request);
 
-		CLEAN(authed_user);
 		CLEAN(server_name);
 		CLEAN(error_handler);
 		CLEAN(dst_addr_buf);
@@ -835,7 +815,6 @@
 
 	CLEAN(parse_request);
 
-	CLEAN(authed_user);
 	CLEAN(server_name);
 	CLEAN(error_handler);
 #if defined USE_OPENSSL && ! defined OPENSSL_NO_TLSEXT
@@ -1055,7 +1034,7 @@
 
 			weWant = con->request.content_length - dst_cq->bytes_in;
 
-			assert(c->mem->used);
+			force_assert(c->mem->used);
 
 			weHave = c->mem->used - c->offset - 1;
 
@@ -1088,9 +1067,7 @@
 						if (dst_c->file.fd == -1) {
 							/* this should not happen as we cache the fd, but you never know */
 							dst_c->file.fd = open(dst_c->file.name->ptr, O_WRONLY | O_APPEND);
-#ifdef FD_CLOEXEC
-							fcntl(dst_c->file.fd, F_SETFD, FD_CLOEXEC);
-#endif
+							fd_close_on_exec(dst_c->file.fd);
 						}
 					} else {
 						/* the chunk is too large now, close it */
@@ -1192,7 +1169,7 @@
 
 	joblist_append(srv, con);
 
-	if (con->conf.is_ssl) {
+	if (con->srv_socket->is_ssl) {
 		/* ssl may read and write for both reads and writes */
 		if (revents & (FDEVENT_IN | FDEVENT_OUT)) {
 			con->is_readable = 1;
@@ -1363,7 +1340,6 @@
 			con->renegotiations = 0;
 			SSL_set_app_data(con->ssl, con);
 			SSL_set_accept_state(con->ssl);
-			con->conf.is_ssl=1;
 
 			if (1 != (SSL_set_fd(con->ssl, cnt))) {
 				log_error_write(srv, __FILE__, __LINE__, "ss", "SSL:",
@@ -1408,12 +1384,6 @@
 
 			connection_set_state(srv, con, CON_STATE_READ);
 
-			/* patch con->conf.is_ssl if the connection is a ssl-socket already */
-
-#ifdef USE_OPENSSL
-			con->conf.is_ssl = srv_sock->is_ssl;
-#endif
-
 			break;
 		case CON_STATE_REQUEST_END: /* transient */
 			if (srv->srvconf.log_state_handling) {
@@ -1505,6 +1475,7 @@
 				break;
 			case HANDLER_COMEBACK:
 				done = -1;
+				/* fallthrough */
 			case HANDLER_WAIT_FOR_EVENT:
 				/* come back here */
 				connection_set_state(srv, con, CON_STATE_HANDLE_REQUEST);
@@ -1736,8 +1707,8 @@
 						break;
 					}
 				}
+				ERR_clear_error();
 			}
-			ERR_clear_error();
 #endif
 
 			switch(con->mode) {
diff -u lighttpd-1.4.32/src/data_string.c lighttpd-1.4.35/src/data_string.c
--- lighttpd-1.4.32/src/data_string.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/data_string.c	2014-03-06 08:08:00.000000000 -0600
@@ -96,7 +96,7 @@
 	data_string *ds;
 
 	ds = calloc(1, sizeof(*ds));
-	assert(ds);
+	force_assert(ds);
 
 	ds->key = buffer_init();
 	ds->value = buffer_init();
diff -u lighttpd-1.4.32/src/fdevent.c lighttpd-1.4.35/src/fdevent.c
--- lighttpd-1.4.32/src/fdevent.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.35/src/fdevent.c	2014-02-25 16:47:55.000000000 -0600
@@ -23,59 +23,62 @@
 	switch(type) {
 	case FDEVENT_HANDLER_POLL:
 		if (0 != fdevent_poll_init(ev)) {
-			log_error_write(ev->srv, __FILE__, __LINE__, "S",
+			log_error_write(srv, __FILE__, __LINE__, "S",
 				"event-handler poll failed");
-
-			return NULL;
+			goto error;
 		}
 		return ev;
 	case FDEVENT_HANDLER_SELECT:
 		if (0 != fdevent_select_init(ev)) {
-			log_error_write(ev->srv, __FILE__, __LINE__, "S",
+			log_error_write(srv, __FILE__, __LINE__, "S",
 				"event-handler select failed");
-			return NULL;
+			goto error;
 		}
 		return ev;
 	case FDEVENT_HANDLER_LINUX_SYSEPOLL:
 		if (0 != fdevent_linux_sysepoll_init(ev)) {
-			log_error_write(ev->srv, __FILE__, __LINE__, "S",
+			log_error_write(srv, __FILE__, __LINE__, "S",
 				"event-handler linux-sysepoll failed, try to set server.event-handler = \"poll\" or \"select\"");
-			return NULL;
+			goto error;
 		}
 		return ev;
 	case FDEVENT_HANDLER_SOLARIS_DEVPOLL:
 		if (0 != fdevent_solaris_devpoll_init(ev)) {
-			log_error_write(ev->srv, __FILE__, __LINE__, "S",
+			log_error_write(srv, __FILE__, __LINE__, "S",
 				"event-handler solaris-devpoll failed, try to set server.event-handler = \"poll\" or \"select\"");
-			return NULL;
+			goto error;
 		}
 		return ev;
 	case FDEVENT_HANDLER_SOLARIS_PORT:
 		if (0 != fdevent_solaris_port_init(ev)) {
-			log_error_write(ev->srv, __FILE__, __LINE__, "S",
+			log_error_write(srv, __FILE__, __LINE__, "S",
 				"event-handler solaris-eventports failed, try to set server.event-handler = \"poll\" or \"select\"");
-			return NULL;
+			goto error;
 		}
 		return ev;
 	case FDEVENT_HANDLER_FREEBSD_KQUEUE:
 		if (0 != fdevent_freebsd_kqueue_init(ev)) {
-			log_error_write(ev->srv, __FILE__, __LINE__, "S",
+			log_error_write(srv, __FILE__, __LINE__, "S",
 				"event-handler freebsd-kqueue failed, try to set server.event-handler = \"poll\" or \"select\"");
-			return NULL;
+			goto error;
 		}
 		return ev;
 	case FDEVENT_HANDLER_LIBEV:
 		if (0 != fdevent_libev_init(ev)) {
-			log_error_write(ev->srv, __FILE__, __LINE__, "S",
+			log_error_write(srv, __FILE__, __LINE__, "S",
 				"event-handler libev failed, try to set server.event-handler = \"poll\" or \"select\"");
-			return NULL;
+			goto error;
 		}
 		return ev;
 	case FDEVENT_HANDLER_UNSET:
 		break;
 	}
 
-	log_error_write(ev->srv, __FILE__, __LINE__, "S",
+error:
+	free(ev->fdarray);
+	free(ev);
+
+	log_error_write(srv, __FILE__, __LINE__, "S",
 		"event-handler is unknown, try to set server.event-handler = \"poll\" or \"select\"");
 	return NULL;
 }
@@ -133,7 +136,7 @@
 	if (!ev) return 0;
 	fdn = ev->fdarray[fd];
 
-	assert(fdn->events == 0);
+	force_assert(fdn->events == 0);
 
 	fdnode_free(fdn);
 
@@ -197,11 +200,17 @@
 	return ev->fdarray[fd]->ctx;
 }
 
-int fdevent_fcntl_set(fdevents *ev, int fd) {
+void fd_close_on_exec(int fd) {
 #ifdef FD_CLOEXEC
-	/* close fd on exec (cgi) */
-	fcntl(fd, F_SETFD, FD_CLOEXEC);
+	if (fd < 0) return;
+	force_assert(-1 != fcntl(fd, F_SETFD, FD_CLOEXEC));
+#else
+	UNUSED(fd);
 #endif
+}
+
+int fdevent_fcntl_set(fdevents *ev, int fd) {
+	fd_close_on_exec(fd);
 	if ((ev) && (ev->fcntl_set)) return ev->fcntl_set(ev, fd);
 #ifdef O_NONBLOCK
 	return fcntl(fd, F_SETFL, O_NONBLOCK | O_RDWR);
diff -u lighttpd-1.4.32/src/fdevent.h lighttpd-1.4.35/src/fdevent.h
--- lighttpd-1.4.32/src/fdevent.h	2011-12-25 09:20:30.000000000 -0600
+++ lighttpd-1.4.35/src/fdevent.h	2014-03-06 08:08:00.000000000 -0600
@@ -191,6 +191,7 @@
 int fdevent_register(fdevents *ev, int fd, fdevent_handler handler, void *ctx);
 int fdevent_unregister(fdevents *ev, int fd);
 
+void fd_close_on_exec(int fd);
 int fdevent_fcntl_set(fdevents *ev, int fd);
 
 int fdevent_select_init(fdevents *ev);
diff -u lighttpd-1.4.32/src/fdevent_libev.c lighttpd-1.4.35/src/fdevent_libev.c
--- lighttpd-1.4.32/src/fdevent_libev.c	2011-12-25 09:19:29.000000000 -0600
+++ lighttpd-1.4.35/src/fdevent_libev.c	2014-02-25 16:47:55.000000000 -0600
@@ -67,7 +67,7 @@
 
 	if (!watcher) {
 		fdn->handler_ctx = watcher = calloc(1, sizeof(ev_io));
-		assert(watcher);
+		force_assert(watcher);
 
 		ev_io_init(watcher, io_watcher_cb, fd, ev_events);
 		watcher->data = ev;
@@ -87,19 +87,28 @@
 	UNUSED(loop);
 	UNUSED(w);
 	UNUSED(revents);
+
+	ev_timer_stop(loop, w);
 }
 
 
 static int fdevent_libev_poll(fdevents *ev, int timeout_ms) {
-	ev_timer timeout_watcher;
-
-	ev_init(&timeout_watcher, timeout_watcher_cb);
-	ev_timer_set(&timeout_watcher, ((ev_tstamp) timeout_ms)/1000.0, 0.0);
-	ev_timer_start(ev->libev_loop, &timeout_watcher);
+	union {
+		struct ev_watcher w;
+		struct ev_timer timer;
+	} timeout_watcher;
+
+	if (!timeout_ms) timeout_ms = 1;
+
+	ev_init(&timeout_watcher.w, NULL);
+	ev_set_cb(&timeout_watcher.timer, timeout_watcher_cb);
+	timeout_watcher.timer.repeat = ((ev_tstamp) timeout_ms)/1000.0;
+	force_assert(timeout_watcher.timer.repeat);
+	ev_timer_again(ev->libev_loop, &timeout_watcher.timer);
 
 	ev_loop(ev->libev_loop, EVLOOP_ONESHOT);
 
-	ev_timer_stop(ev->libev_loop, &timeout_watcher);
+	ev_timer_stop(ev->libev_loop, &timeout_watcher.timer);
 
 	return 0;
 }
diff -u lighttpd-1.4.32/src/fdevent_linux_sysepoll.c lighttpd-1.4.35/src/fdevent_linux_sysepoll.c
--- lighttpd-1.4.32/src/fdevent_linux_sysepoll.c	2011-12-25 09:19:23.000000000 -0600
+++ lighttpd-1.4.35/src/fdevent_linux_sysepoll.c	2014-02-25 16:47:55.000000000 -0600
@@ -140,14 +140,7 @@
 		return -1;
 	}
 
-	if (-1 == fcntl(ev->epoll_fd, F_SETFD, FD_CLOEXEC)) {
-		log_error_write(ev->srv, __FILE__, __LINE__, "SSS",
-			"fcntl on epoll-fd failed (", strerror(errno), "), try to set server.event-handler = \"poll\" or \"select\"");
-
-		close(ev->epoll_fd);
-
-		return -1;
-	}
+	fd_close_on_exec(ev->epoll_fd);
 
 	ev->epoll_events = malloc(ev->maxfds * sizeof(*ev->epoll_events));
 
diff -u lighttpd-1.4.32/src/fdevent_select.c lighttpd-1.4.35/src/fdevent_select.c
--- lighttpd-1.4.32/src/fdevent_select.c	2010-08-17 04:06:03.000000000 -0500
+++ lighttpd-1.4.35/src/fdevent_select.c	2014-02-25 16:47:55.000000000 -0600
@@ -38,7 +38,7 @@
 	UNUSED(fde_ndx);
 
 	/* we should be protected by max-fds, but you never know */
-	assert(fd < ((int)FD_SETSIZE));
+	force_assert(fd < ((int)FD_SETSIZE));
 
 	if (events & FDEVENT_IN) {
 		FD_SET(fd, &(ev->select_set_read));
diff -u lighttpd-1.4.32/src/fdevent_solaris_devpoll.c lighttpd-1.4.35/src/fdevent_solaris_devpoll.c
--- lighttpd-1.4.32/src/fdevent_solaris_devpoll.c	2011-12-25 09:20:19.000000000 -0600
+++ lighttpd-1.4.35/src/fdevent_solaris_devpoll.c	2014-02-25 16:47:55.000000000 -0600
@@ -121,14 +121,7 @@
 		return -1;
 	}
 
-	if (fcntl(ev->devpoll_fd, F_SETFD, FD_CLOEXEC) < 0) {
-		log_error_write(ev->srv, __FILE__, __LINE__, "SSS",
-			"fcntl /dev/poll fd failed (", strerror(errno), "), try to set server.event-handler = \"poll\" or \"select\"");
-
-		close(ev->devpoll_fd);
-
-		return -1;
-	}
+	fd_close_on_exec(ev->devpoll_fd);
 	return 0;
 }
 int fdevent_solaris_devpoll_init(fdevents *ev) {
diff -u lighttpd-1.4.32/src/http_auth.c lighttpd-1.4.35/src/http_auth.c
--- lighttpd-1.4.32/src/http_auth.c	2012-05-17 04:29:24.000000000 -0500
+++ lighttpd-1.4.35/src/http_auth.c	2014-03-06 08:08:00.000000000 -0600
@@ -29,6 +29,10 @@
 
 #include "md5.h"
 
+#ifdef USE_OPENSSL
+#include <openssl/sha.h>
+#endif
+
 #define HASHLEN 16
 #define HASHHEXLEN 32
 typedef unsigned char HASH[HASHLEN];
@@ -87,7 +91,8 @@
 
 static unsigned char * base64_decode(buffer *out, const char *in) {
 	unsigned char *result;
-	int ch, j = 0, k;
+	unsigned int j = 0; /* current output character (position) that is decoded. can contain partial result */
+	unsigned int group = 0; /* how many base64 digits in the current group were decoded already. each group has up to 4 digits */
 	size_t i;
 
 	size_t in_len = strlen(in);
@@ -96,51 +101,64 @@
 
 	result = (unsigned char *)out->ptr;
 
-	ch = in[0];
 	/* run through the whole string, converting as we go */
 	for (i = 0; i < in_len; i++) {
-		ch = (unsigned char) in[i];
+		unsigned char c = (unsigned char) in[i];
+		short ch;
 
-		if (ch == '\0') break;
+		if (c == '\0') break;
 
-		if (ch == base64_pad) break;
+		if (c == base64_pad) {
+			/* pad character can only come after 2 base64 digits in a group */
+			if (group < 2) return NULL;
+			break;
+		}
 
-		ch = base64_reverse_table[ch];
-		if (ch < 0) continue;
+		ch = base64_reverse_table[c];
+		if (ch < 0) continue; /* skip invalid characters */
 
-		switch(i % 4) {
+		switch(group) {
 		case 0:
 			result[j] = ch << 2;
+			group = 1;
 			break;
 		case 1:
 			result[j++] |= ch >> 4;
 			result[j] = (ch & 0x0f) << 4;
+			group = 2;
 			break;
 		case 2:
 			result[j++] |= ch >>2;
 			result[j] = (ch & 0x03) << 6;
+			group = 3;
 			break;
 		case 3:
 			result[j++] |= ch;
+			group = 0;
 			break;
 		}
 	}
-	k = j;
-	/* mop things up if we ended on a boundary */
-	if (ch == base64_pad) {
-		switch(i % 4) {
-		case 0:
-		case 1:
-			return NULL;
-		case 2:
-			k++;
-		case 3:
-			result[k++] = 0;
-		}
+
+	switch(group) {
+	case 0:
+		/* ended on boundary */
+		break;
+	case 1:
+		/* need at least 2 base64 digits per group */
+		return NULL;
+	case 2:
+		/* have 2 base64 digits in last group => one real octect, two zeroes padded */
+	case 3:
+		/* have 3 base64 digits in last group => two real octects, one zero padded */
+
+		/* for both cases the current index already is on the first zero padded octet
+		 * - check it really is zero (overlapping bits) */
+		if (0 != result[j]) return NULL;
+		break;
 	}
-	result[k] = '\0';
 
-	out->used = k;
+	result[j] = '\0';
+	out->used = j;
 
 	return result;
 }
@@ -304,32 +322,14 @@
 	return ret;
 }
 
-static int http_auth_match_rules(server *srv, mod_auth_plugin_data *p, const char *url, const char *username, const char *group, const char *host) {
+int http_auth_match_rules(server *srv, array *req, const char *username, const char *group, const char *host) {
 	const char *r = NULL, *rules = NULL;
-	size_t i;
 	int username_len;
 	data_string *require;
-	array *req;
 
 	UNUSED(group);
 	UNUSED(host);
 
-	/* check what has to be match to fullfil the request */
-	/* search auth-directives for path */
-	for (i = 0; i < p->conf.auth_require->used; i++) {
-		if (p->conf.auth_require->data[i]->key->used == 0) continue;
-
-		if (0 == strncmp(url, p->conf.auth_require->data[i]->key->ptr, p->conf.auth_require->data[i]->key->used - 1)) {
-			break;
-		}
-	}
-
-	if (i == p->conf.auth_require->used) {
-		return -1;
-	}
-
-	req = ((data_array *)(p->conf.auth_require->data[i]))->value;
-
 	require = (data_string *)array_get_element(req, "require");
 
 	/* if we get here, the user we got a authed user */
@@ -599,6 +599,35 @@
     apr_cpystrn(result, passwd, nbytes - 1);
 }
 
+#ifdef USE_OPENSSL
+static void apr_sha_encode(const char *pw, char *result, size_t nbytes) {
+	static const unsigned char base64_data[65] =
+		"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+	unsigned char digest[21]; /* multiple of 3 for base64 encoding */
+	int i;
+
+	memset(result, 0, nbytes);
+
+	/* need 5 bytes for "{SHA}", 28 for base64 (3 bytes -> 4 bytes) of SHA1 (20 bytes), 1 terminating */
+	if (nbytes < 5 + 28 + 1) return;
+
+	SHA1((const unsigned char*) pw, strlen(pw), digest);
+	digest[20] = 0;
+
+	strcpy(result, "{SHA}");
+	result = result + 5;
+	for (i = 0; i < 21; i += 3) {
+		unsigned int v = (digest[i] << 16) | (digest[i+1] << 8) | digest[i+2];
+		result[3] = base64_data[v & 0x3f]; v >>= 6;
+		result[2] = base64_data[v & 0x3f]; v >>= 6;
+		result[1] = base64_data[v & 0x3f]; v >>= 6;
+		result[0] = base64_data[v & 0x3f];
+		result += 4;
+	}
+	result[-1] = '='; /* last digest character was already end of string, pad it */
+	*result = '\0';
+}
+#endif
 
 /**
  *
@@ -643,58 +672,30 @@
 			 */
 			apr_md5_encode(pw, password->ptr, sample, sizeof(sample));
 			return (strcmp(sample, password->ptr) == 0) ? 0 : 1;
+#ifdef USE_OPENSSL
+		} else if (0 == strncmp(password->ptr, "{SHA}", 5)) {
+			apr_sha_encode(pw, sample, sizeof(sample));
+			return (strcmp(sample, password->ptr) == 0) ? 0 : 1;
+#endif
 		} else {
 #ifdef HAVE_CRYPT
-		char salt[32];
-		char *crypted;
-		size_t salt_len = 0;
-		/*
-		 * htpasswd format
-		 *
-		 * user:crypted password
-		 */
-
-		/*
-		 *  Algorithm      Salt
-		 *  CRYPT_STD_DES   2-character (Default)
-		 *  CRYPT_EXT_DES   9-character
-		 *  CRYPT_MD5       12-character beginning with $1$
-		 *  CRYPT_BLOWFISH  16-character beginning with $2$
-		 */
-
-		if (password->used < 13 + 1) {
-			return -1;
-		}
-
-		if (password->used == 13 + 1) {
-			/* a simple DES password is 2 + 11 characters */
-			salt_len = 2;
-		} else if (password->ptr[0] == '$' && password->ptr[2] == '$') {
-			char *dollar = NULL;
+			char *crypted;
 
-			if (NULL == (dollar = strchr(password->ptr + 3, '$'))) {
+			/* a simple DES password is 2 + 11 characters. everything else should be longer. */
+			if (password->used < 13 + 1) {
 				return -1;
 			}
 
-			salt_len = dollar - password->ptr;
-		}
-
-		if (salt_len > sizeof(salt) - 1) {
-			return -1;
-		}
-
-		strncpy(salt, password->ptr, salt_len);
-
-		salt[salt_len] = '\0';
-
-		crypted = crypt(pw, salt);
-
-		if (0 == strcmp(password->ptr, crypted)) {
-			return 0;
-		}
+			if (0 == (crypted = crypt(pw, password->ptr))) {
+				/* crypt failed. */
+				return -1;
+			}
 
+			if (0 == strcmp(password->ptr, crypted)) {
+				return 0;
+			}
 #endif
-	}
+		}
 	} else if (p->conf.auth_backend == AUTH_BACKEND_PLAIN) {
 		if (0 == strcmp(password->ptr, pw)) {
 			return 0;
@@ -763,8 +764,9 @@
 				if (auth_ldap_init(srv, p->anon_conf) != HANDLER_GO_ON)
 					return -1;
 
-				if (p->anon_conf->ldap == NULL ||
-				    LDAP_SUCCESS != (ret = ldap_search_s(p->anon_conf->ldap, p->conf.auth_ldap_basedn->ptr, LDAP_SCOPE_SUBTREE, p->ldap_filter->ptr, attrs, 0, &lm))) {
+				if (NULL == p->anon_conf->ldap) return -1;
+
+				if (LDAP_SUCCESS != (ret = ldap_search_s(p->anon_conf->ldap, p->conf.auth_ldap_basedn->ptr, LDAP_SCOPE_SUBTREE, p->ldap_filter->ptr, attrs, 0, &lm))) {
 					log_error_write(srv, __FILE__, __LINE__, "sssb",
 							"ldap:", ldap_err2string(ret), "filter:", p->ldap_filter);
 					return -1;
@@ -836,7 +838,7 @@
 	return -1;
 }
 
-int http_auth_basic_check(server *srv, connection *con, mod_auth_plugin_data *p, array *req, buffer *url, const char *realm_str) {
+int http_auth_basic_check(server *srv, connection *con, mod_auth_plugin_data *p, array *req, const char *realm_str) {
 	buffer *username, *password;
 	char *pw;
 
@@ -891,7 +893,7 @@
 	}
 
 	/* value is our allow-rules */
-	if (http_auth_match_rules(srv, p, url->ptr, username->ptr, NULL, NULL)) {
+	if (http_auth_match_rules(srv, req, username->ptr, NULL, NULL)) {
 		buffer_free(username);
 		buffer_free(password);
 
@@ -915,7 +917,8 @@
 	char **ptr;
 } digest_kv;
 
-int http_auth_digest_check(server *srv, connection *con, mod_auth_plugin_data *p, array *req, buffer *url, const char *realm_str) {
+/* return values: -1: error/bad request, 0: failed, 1: success */
+int http_auth_digest_check(server *srv, connection *con, mod_auth_plugin_data *p, array *req, const char *realm_str) {
 	char a1[256];
 	char a2[256];
 
@@ -1052,6 +1055,14 @@
 		return -1;
 	}
 
+	if (qop && strcasecmp(qop, "auth-int") == 0) {
+		log_error_write(srv, __FILE__, __LINE__, "s",
+				"digest: qop=auth-int not supported");
+
+		buffer_free(b);
+		return -1;
+	}
+
 	m = get_http_method_name(con->request.http_method);
 
 	/* password-string == HA1 */
@@ -1112,10 +1123,13 @@
 	li_MD5_Update(&Md5Ctx, (unsigned char *)m, strlen(m));
 	li_MD5_Update(&Md5Ctx, (unsigned char *)":", 1);
 	li_MD5_Update(&Md5Ctx, (unsigned char *)uri, strlen(uri));
+	/* qop=auth-int not supported, already checked above */
+/*
 	if (qop && strcasecmp(qop, "auth-int") == 0) {
 		li_MD5_Update(&Md5Ctx, (unsigned char *)":", 1);
-		li_MD5_Update(&Md5Ctx, (unsigned char *)"", HASHHEXLEN);
+		li_MD5_Update(&Md5Ctx, (unsigned char *) [body checksum], HASHHEXLEN);
 	}
+*/
 	li_MD5_Final(HA2, &Md5Ctx);
 	CvtHex(HA2, HA2Hex);
 
@@ -1153,7 +1167,7 @@
 	}
 
 	/* value is our allow-rules */
-	if (http_auth_match_rules(srv, p, url->ptr, username, NULL, NULL)) {
+	if (http_auth_match_rules(srv, req, username, NULL, NULL)) {
 		buffer_free(b);
 
 		log_error_write(srv, __FILE__, __LINE__, "s",
diff -u lighttpd-1.4.32/src/http_auth.h lighttpd-1.4.35/src/http_auth.h
--- lighttpd-1.4.32/src/http_auth.h	2010-02-01 17:28:20.000000000 -0600
+++ lighttpd-1.4.35/src/http_auth.h	2013-11-13 11:06:41.000000000 -0600
@@ -66,8 +66,9 @@
 	mod_auth_plugin_config conf, *anon_conf; /* this is only used as long as no handler_ctx is setup */
 } mod_auth_plugin_data;
 
-int http_auth_basic_check(server *srv, connection *con, mod_auth_plugin_data *p, array *req, buffer *url, const char *realm_str);
-int http_auth_digest_check(server *srv, connection *con, mod_auth_plugin_data *p, array *req, buffer *url, const char *realm_str);
+int http_auth_basic_check(server *srv, connection *con, mod_auth_plugin_data *p, array *req, const char *realm_str);
+int http_auth_digest_check(server *srv, connection *con, mod_auth_plugin_data *p, array *req, const char *realm_str);
 int http_auth_digest_generate_nonce(server *srv, mod_auth_plugin_data *p, buffer *fn, char hh[33]);
+int http_auth_match_rules(server *srv, array *req, const char *username, const char *group, const char *host);
 
 #endif
diff -u lighttpd-1.4.32/src/http-header-glue.c lighttpd-1.4.35/src/http-header-glue.c
--- lighttpd-1.4.32/src/http-header-glue.c	2012-11-17 11:32:01.000000000 -0600
+++ lighttpd-1.4.35/src/http-header-glue.c	2014-03-06 08:08:00.000000000 -0600
@@ -123,11 +123,8 @@
 
 	o = buffer_init();
 
-	if (con->conf.is_ssl) {
-		buffer_copy_string_len(o, CONST_STR_LEN("https://"));
-	} else {
-		buffer_copy_string_len(o, CONST_STR_LEN("http://"));
-	}
+	buffer_copy_string_buffer(o, con->uri.scheme);
+	buffer_append_string_len(o, CONST_STR_LEN("://"));
 	if (con->uri.authority->used) {
 		buffer_append_string_buffer(o, con->uri.authority);
 	} else {
@@ -193,10 +190,15 @@
 			return -1;
 		}
 
-		if (!((con->conf.is_ssl == 0 && srv->srvconf.port == 80) ||
-		      (con->conf.is_ssl == 1 && srv->srvconf.port == 443))) {
-			buffer_append_string_len(o, CONST_STR_LEN(":"));
-			buffer_append_long(o, srv->srvconf.port);
+		{
+			unsigned short default_port = 80;
+			if (buffer_is_equal_caseless_string(con->uri.scheme, CONST_STR_LEN("https"))) {
+				default_port = 443;
+			}
+			if (default_port != srv->srvconf.port) {
+				buffer_append_string_len(o, CONST_STR_LEN(":"));
+				buffer_append_long(o, srv->srvconf.port);
+			}
 		}
 	}
 	buffer_append_string_buffer(o, con->uri.path);
@@ -245,6 +247,7 @@
 
 
 int http_response_handle_cachable(server *srv, connection *con, buffer *mtime) {
+	UNUSED(srv);
 	/*
 	 * 14.26 If-None-Match
 	 *    [...]
@@ -261,68 +264,17 @@
 			if (con->request.http_method == HTTP_METHOD_GET ||
 			    con->request.http_method == HTTP_METHOD_HEAD) {
 
-				/* check if etag + last-modified */
-				if (con->request.http_if_modified_since) {
-					size_t used_len;
-					char *semicolon;
-
-					if (NULL == (semicolon = strchr(con->request.http_if_modified_since, ';'))) {
-						used_len = strlen(con->request.http_if_modified_since);
-					} else {
-						used_len = semicolon - con->request.http_if_modified_since;
-					}
-
-					if (0 == strncmp(con->request.http_if_modified_since, mtime->ptr, used_len)) {
-						if ('\0' == mtime->ptr[used_len]) con->http_status = 304;
-						return HANDLER_FINISHED;
-					} else {
-						char buf[sizeof("Sat, 23 Jul 2005 21:20:01 GMT")];
-						time_t t_header, t_file;
-						struct tm tm;
-
-						/* check if we can safely copy the string */
-						if (used_len >= sizeof(buf)) {
-							log_error_write(srv, __FILE__, __LINE__, "ssdd",
-									"DEBUG: Last-Modified check failed as the received timestamp was too long:",
-									con->request.http_if_modified_since, used_len, sizeof(buf) - 1);
-
-							con->http_status = 412;
-							con->mode = DIRECT;
-							return HANDLER_FINISHED;
-						}
-
-
-						strncpy(buf, con->request.http_if_modified_since, used_len);
-						buf[used_len] = '\0';
-
-						if (NULL == strptime(buf, "%a, %d %b %Y %H:%M:%S GMT", &tm)) {
-							con->http_status = 412;
-							con->mode = DIRECT;
-							return HANDLER_FINISHED;
-						}
-						tm.tm_isdst = 0;
-						t_header = mktime(&tm);
-
-						strptime(mtime->ptr, "%a, %d %b %Y %H:%M:%S GMT", &tm);
-						tm.tm_isdst = 0;
-						t_file = mktime(&tm);
-
-						if (t_file > t_header) return HANDLER_GO_ON;
-
-						con->http_status = 304;
-						return HANDLER_FINISHED;
-					}
-				} else {
-					con->http_status = 304;
-					return HANDLER_FINISHED;
-				}
+				con->http_status = 304;
+				return HANDLER_FINISHED;
 			} else {
 				con->http_status = 412;
 				con->mode = DIRECT;
 				return HANDLER_FINISHED;
 			}
 		}
-	} else if (con->request.http_if_modified_since) {
+	} else if (con->request.http_if_modified_since &&
+	           (con->request.http_method == HTTP_METHOD_GET ||
+	            con->request.http_method == HTTP_METHOD_HEAD)) {
 		size_t used_len;
 		char *semicolon;
 
diff -u lighttpd-1.4.32/src/keyvalue.c lighttpd-1.4.35/src/keyvalue.c
--- lighttpd-1.4.32/src/keyvalue.c	2012-11-07 07:16:36.000000000 -0600
+++ lighttpd-1.4.35/src/keyvalue.c	2013-11-13 11:06:41.000000000 -0600
@@ -13,29 +13,44 @@
 };
 
 static keyvalue http_methods[] = {
-	{ HTTP_METHOD_GET,  "GET" },
-	{ HTTP_METHOD_POST, "POST" },
+	{ HTTP_METHOD_GET, "GET" },
 	{ HTTP_METHOD_HEAD, "HEAD" },
-	{ HTTP_METHOD_PROPFIND, "PROPFIND" },
-	{ HTTP_METHOD_PROPPATCH, "PROPPATCH" },
-	{ HTTP_METHOD_REPORT, "REPORT" },
-	{ HTTP_METHOD_OPTIONS, "OPTIONS" },
-	{ HTTP_METHOD_MKCOL, "MKCOL" },
+	{ HTTP_METHOD_POST, "POST" },
 	{ HTTP_METHOD_PUT, "PUT" },
-	{ HTTP_METHOD_PATCH, "PATCH" },
 	{ HTTP_METHOD_DELETE, "DELETE" },
+	{ HTTP_METHOD_CONNECT, "CONNECT" },
+	{ HTTP_METHOD_OPTIONS, "OPTIONS" },
+	{ HTTP_METHOD_TRACE, "TRACE" },
+	{ HTTP_METHOD_ACL, "ACL" },
+	{ HTTP_METHOD_BASELINE_CONTROL, "BASELINE-CONTROL" },
+	{ HTTP_METHOD_BIND, "BIND" },
+	{ HTTP_METHOD_CHECKIN, "CHECKIN" },
+	{ HTTP_METHOD_CHECKOUT, "CHECKOUT" },
 	{ HTTP_METHOD_COPY, "COPY" },
-	{ HTTP_METHOD_MOVE, "MOVE" },
 	{ HTTP_METHOD_LABEL, "LABEL" },
-	{ HTTP_METHOD_CHECKOUT, "CHECKOUT" },
-	{ HTTP_METHOD_CHECKIN, "CHECKIN" },
-	{ HTTP_METHOD_MERGE, "MERGE" },
+	{ HTTP_METHOD_LINK, "LINK" },
 	{ HTTP_METHOD_LOCK, "LOCK" },
-	{ HTTP_METHOD_UNLOCK, "UNLOCK" },
+	{ HTTP_METHOD_MERGE, "MERGE" },
 	{ HTTP_METHOD_MKACTIVITY, "MKACTIVITY" },
+	{ HTTP_METHOD_MKCALENDAR, "MKCALENDAR" },
+	{ HTTP_METHOD_MKCOL, "MKCOL" },
+	{ HTTP_METHOD_MKREDIRECTREF, "MKREDIRECTREF" },
+	{ HTTP_METHOD_MKWORKSPACE, "MKWORKSPACE" },
+	{ HTTP_METHOD_MOVE, "MOVE" },
+	{ HTTP_METHOD_ORDERPATCH, "ORDERPATCH" },
+	{ HTTP_METHOD_PATCH, "PATCH" },
+	{ HTTP_METHOD_PROPFIND, "PROPFIND" },
+	{ HTTP_METHOD_PROPPATCH, "PROPPATCH" },
+	{ HTTP_METHOD_REBIND, "REBIND" },
+	{ HTTP_METHOD_REPORT, "REPORT" },
+	{ HTTP_METHOD_SEARCH, "SEARCH" },
+	{ HTTP_METHOD_UNBIND, "UNBIND" },
 	{ HTTP_METHOD_UNCHECKOUT, "UNCHECKOUT" },
+	{ HTTP_METHOD_UNLINK, "UNLINK" },
+	{ HTTP_METHOD_UNLOCK, "UNLOCK" },
+	{ HTTP_METHOD_UPDATE, "UPDATE" },
+	{ HTTP_METHOD_UPDATEREDIRECTREF, "UPDATEREDIRECTREF" },
 	{ HTTP_METHOD_VERSION_CONTROL, "VERSION-CONTROL" },
-	{ HTTP_METHOD_CONNECT, "CONNECT" },
 
 	{ HTTP_METHOD_UNSET, NULL }
 };
diff -u lighttpd-1.4.32/src/keyvalue.h lighttpd-1.4.35/src/keyvalue.h
--- lighttpd-1.4.32/src/keyvalue.h	2012-11-07 07:16:36.000000000 -0600
+++ lighttpd-1.4.35/src/keyvalue.h	2013-11-13 11:06:41.000000000 -0600
@@ -11,31 +11,56 @@
 
 struct server;
 
+/* sources:
+ * - [RFC2616], Section 9
+ *   (or http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22)
+ * - http://tools.ietf.org/html/draft-ietf-httpbis-method-registrations-11, Appendix A
+ *
+ * http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22, Section 8.1 defines
+ * a new registry (not available yet):
+ *   http://www.iana.org/assignments/http-methods
+ */
+
 typedef enum {
 	HTTP_METHOD_UNSET = -1,
-	HTTP_METHOD_GET,
-	HTTP_METHOD_POST,
-	HTTP_METHOD_HEAD,
-	HTTP_METHOD_OPTIONS,
-	HTTP_METHOD_PROPFIND,  /* WebDAV */
-	HTTP_METHOD_MKCOL,
-	HTTP_METHOD_PUT,
-	HTTP_METHOD_PATCH,
-	HTTP_METHOD_DELETE,
-	HTTP_METHOD_COPY,
-	HTTP_METHOD_MOVE,
-	HTTP_METHOD_PROPPATCH,
-	HTTP_METHOD_REPORT, /* DeltaV */
-	HTTP_METHOD_CHECKOUT,
-	HTTP_METHOD_CHECKIN,
-	HTTP_METHOD_VERSION_CONTROL,
-	HTTP_METHOD_UNCHECKOUT,
-	HTTP_METHOD_MKACTIVITY,
-	HTTP_METHOD_MERGE,
-	HTTP_METHOD_LOCK,
-	HTTP_METHOD_UNLOCK,
-	HTTP_METHOD_LABEL,
-	HTTP_METHOD_CONNECT
+	HTTP_METHOD_GET,               /* [RFC2616], Section 9.3 */
+	HTTP_METHOD_HEAD,              /* [RFC2616], Section 9.4 */
+	HTTP_METHOD_POST,              /* [RFC2616], Section 9.5 */
+	HTTP_METHOD_PUT,               /* [RFC2616], Section 9.6 */
+	HTTP_METHOD_DELETE,            /* [RFC2616], Section 9.7 */
+	HTTP_METHOD_CONNECT,           /* [RFC2616], Section 9.9 */
+	HTTP_METHOD_OPTIONS,           /* [RFC2616], Section 9.2 */
+	HTTP_METHOD_TRACE,             /* [RFC2616], Section 9.8 */
+	HTTP_METHOD_ACL,               /* [RFC3744], Section 8.1 */
+	HTTP_METHOD_BASELINE_CONTROL,  /* [RFC3253], Section 12.6 */
+	HTTP_METHOD_BIND,              /* [RFC5842], Section 4 */
+	HTTP_METHOD_CHECKIN,           /* [RFC3253], Section 4.4 and [RFC3253], Section 9.4 */
+	HTTP_METHOD_CHECKOUT,          /* [RFC3253], Section 4.3 and [RFC3253], Section 8.8 */
+	HTTP_METHOD_COPY,              /* [RFC4918], Section 9.8 */
+	HTTP_METHOD_LABEL,             /* [RFC3253], Section 8.2 */
+	HTTP_METHOD_LINK,              /* [RFC2068], Section 19.6.1.2 */
+	HTTP_METHOD_LOCK,              /* [RFC4918], Section 9.10 */
+	HTTP_METHOD_MERGE,             /* [RFC3253], Section 11.2 */
+	HTTP_METHOD_MKACTIVITY,        /* [RFC3253], Section 13.5 */
+	HTTP_METHOD_MKCALENDAR,        /* [RFC4791], Section 5.3.1 */
+	HTTP_METHOD_MKCOL,             /* [RFC4918], Section 9.3 */
+	HTTP_METHOD_MKREDIRECTREF,     /* [RFC4437], Section 6 */
+	HTTP_METHOD_MKWORKSPACE,       /* [RFC3253], Section 6.3 */
+	HTTP_METHOD_MOVE,              /* [RFC4918], Section 9.9 */
+	HTTP_METHOD_ORDERPATCH,        /* [RFC3648], Section 7 */
+	HTTP_METHOD_PATCH,             /* [RFC5789], Section 2 */
+	HTTP_METHOD_PROPFIND,          /* [RFC4918], Section 9.1 */
+	HTTP_METHOD_PROPPATCH,         /* [RFC4918], Section 9.2 */
+	HTTP_METHOD_REBIND,            /* [RFC5842], Section 6 */
+	HTTP_METHOD_REPORT,            /* [RFC3253], Section 3.6 */
+	HTTP_METHOD_SEARCH,            /* [RFC5323], Section 2 */
+	HTTP_METHOD_UNBIND,            /* [RFC5842], Section 5 */
+	HTTP_METHOD_UNCHECKOUT,        /* [RFC3253], Section 4.5 */
+	HTTP_METHOD_UNLINK,            /* [RFC2068], Section 19.6.1.3 */
+	HTTP_METHOD_UNLOCK,            /* [RFC4918], Section 9.11 */
+	HTTP_METHOD_UPDATE,            /* [RFC3253], Section 7.1 */
+	HTTP_METHOD_UPDATEREDIRECTREF, /* [RFC4437], Section 7 */
+	HTTP_METHOD_VERSION_CONTROL    /* [RFC3253], Section 3.5 */
 } http_method_t;
 
 typedef enum { HTTP_VERSION_UNSET = -1, HTTP_VERSION_1_0, HTTP_VERSION_1_1 } http_version_t;
diff -u lighttpd-1.4.32/src/lemon.c lighttpd-1.4.35/src/lemon.c
--- lighttpd-1.4.32/src/lemon.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.35/src/lemon.c	2014-02-15 05:33:16.000000000 -0600
@@ -1613,12 +1613,14 @@
 int k;
 FILE *err;
 {
-  int spcnt, i;
-  if( argv[0] ) fprintf(err,"%s",argv[0]);
-  spcnt = strlen(argv[0]) + 1;
+  int spcnt = 0, i;
+  if( argv[0] ) {
+    fprintf(err,"%s",argv[0]);
+    spcnt += strlen(argv[0]) + 1;
+  }
   for(i=1; i<n && argv[i]; i++){
     fprintf(err," %s",argv[i]);
-    spcnt += strlen(argv[i]+1);
+    spcnt += strlen(argv[i]) + 1;
   }
   spcnt += k;
   for(; argv[i]; i++) fprintf(err," %s",argv[i]);
@@ -3105,7 +3107,7 @@
     stddt[j] = 0;
     hash = 0;
     for(j=0; stddt[j]; j++){
-      hash = hash*53 + stddt[j];
+      hash = (unsigned int)hash*53u + (unsigned int) stddt[j];
     }
     hash = (hash & 0x7fffffff)%arraysize;
     while( types[hash] ){
@@ -3751,8 +3753,8 @@
 PRIVATE int strhash(x)
 char *x;
 {
-  int h = 0;
-  while( *x) h = h*13 + *(x++);
+  unsigned int h = 0;
+  while( *x) h = h*13u + (unsigned int) *(x++);
   return h;
 }
 
@@ -4124,9 +4126,9 @@
 PRIVATE int statehash(a)
 struct config *a;
 {
-  int h=0;
+  unsigned int h=0;
   while( a ){
-    h = h*571 + a->rp->index*37 + a->dot;
+    h = h*571u + (unsigned int)a->rp->index*37u + (unsigned int)a->dot;
     a = a->bp;
   }
   return h;
diff -u lighttpd-1.4.32/src/log.c lighttpd-1.4.35/src/log.c
--- lighttpd-1.4.32/src/log.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/log.c	2014-03-06 08:08:00.000000000 -0600
@@ -122,9 +122,7 @@
 		return -1;
 	}
 
-#ifdef FD_CLOEXEC
-	fcntl(fd, F_SETFD, FD_CLOEXEC);
-#endif
+	fd_close_on_exec(fd);
 
 	return fd;
 }
@@ -178,9 +176,7 @@
 
 		if (srv->errorlog_mode == ERRORLOG_FD) {
 			srv->errorlog_fd = dup(STDERR_FILENO);
-#ifdef FD_CLOEXEC
-			fcntl(srv->errorlog_fd, F_SETFD, FD_CLOEXEC);
-#endif
+			fd_close_on_exec(srv->errorlog_fd);
 		}
 
 		if (-1 == (breakage_fd = open_logfile_or_pipe(srv, logfile))) {
@@ -231,10 +227,7 @@
 			/* ok, new log is open, close the old one */
 			close(srv->errorlog_fd);
 			srv->errorlog_fd = new_fd;
-#ifdef FD_CLOEXEC
-			/* close fd on exec (cgi) */
-			fcntl(srv->errorlog_fd, F_SETFD, FD_CLOEXEC);
-#endif
+			fd_close_on_exec(srv->errorlog_fd);
 		}
 	}
 
@@ -263,39 +256,9 @@
 	return 0;
 }
 
-int log_error_write(server *srv, const char *filename, unsigned int line, const char *fmt, ...) {
-	va_list ap;
-
-	switch(srv->errorlog_mode) {
-	case ERRORLOG_PIPE:
-	case ERRORLOG_FILE:
-	case ERRORLOG_FD:
-		if (-1 == srv->errorlog_fd) return 0;
-		/* cache the generated timestamp */
-		if (srv->cur_ts != srv->last_generated_debug_ts) {
-			buffer_prepare_copy(srv->ts_debug_str, 255);
-			strftime(srv->ts_debug_str->ptr, srv->ts_debug_str->size - 1, "%Y-%m-%d %H:%M:%S", localtime(&(srv->cur_ts)));
-			srv->ts_debug_str->used = strlen(srv->ts_debug_str->ptr) + 1;
-
-			srv->last_generated_debug_ts = srv->cur_ts;
-		}
-
-		buffer_copy_string_buffer(srv->errorlog_buf, srv->ts_debug_str);
-		buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN(": ("));
-		break;
-	case ERRORLOG_SYSLOG:
-		/* syslog is generating its own timestamps */
-		buffer_copy_string_len(srv->errorlog_buf, CONST_STR_LEN("("));
-		break;
-	}
-
-	buffer_append_string(srv->errorlog_buf, filename);
-	buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN("."));
-	buffer_append_long(srv->errorlog_buf, line);
-	buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN(") "));
-
-
-	for(va_start(ap, fmt); *fmt; fmt++) {
+/* lowercase: append space, uppercase: don't */
+static void log_buffer_append_printf(buffer *out, const char *fmt, va_list ap) {
+	for(; *fmt; fmt++) {
 		int d;
 		char *s;
 		buffer *b;
@@ -304,50 +267,50 @@
 		switch(*fmt) {
 		case 's':           /* string */
 			s = va_arg(ap, char *);
-			buffer_append_string(srv->errorlog_buf, s);
-			buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN(" "));
+			buffer_append_string(out, s);
+			buffer_append_string_len(out, CONST_STR_LEN(" "));
 			break;
 		case 'b':           /* buffer */
 			b = va_arg(ap, buffer *);
-			buffer_append_string_buffer(srv->errorlog_buf, b);
-			buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN(" "));
+			buffer_append_string_buffer(out, b);
+			buffer_append_string_len(out, CONST_STR_LEN(" "));
 			break;
 		case 'd':           /* int */
 			d = va_arg(ap, int);
-			buffer_append_long(srv->errorlog_buf, d);
-			buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN(" "));
+			buffer_append_long(out, d);
+			buffer_append_string_len(out, CONST_STR_LEN(" "));
 			break;
 		case 'o':           /* off_t */
 			o = va_arg(ap, off_t);
-			buffer_append_off_t(srv->errorlog_buf, o);
-			buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN(" "));
+			buffer_append_off_t(out, o);
+			buffer_append_string_len(out, CONST_STR_LEN(" "));
 			break;
 		case 'x':           /* int (hex) */
 			d = va_arg(ap, int);
-			buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN("0x"));
-			buffer_append_long_hex(srv->errorlog_buf, d);
-			buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN(" "));
+			buffer_append_string_len(out, CONST_STR_LEN("0x"));
+			buffer_append_long_hex(out, d);
+			buffer_append_string_len(out, CONST_STR_LEN(" "));
 			break;
 		case 'S':           /* string */
 			s = va_arg(ap, char *);
-			buffer_append_string(srv->errorlog_buf, s);
+			buffer_append_string(out, s);
 			break;
 		case 'B':           /* buffer */
 			b = va_arg(ap, buffer *);
-			buffer_append_string_buffer(srv->errorlog_buf, b);
+			buffer_append_string_buffer(out, b);
 			break;
 		case 'D':           /* int */
 			d = va_arg(ap, int);
-			buffer_append_long(srv->errorlog_buf, d);
+			buffer_append_long(out, d);
 			break;
 		case 'O':           /* off_t */
 			o = va_arg(ap, off_t);
-			buffer_append_off_t(srv->errorlog_buf, o);
+			buffer_append_off_t(out, o);
 			break;
 		case 'X':           /* int (hex) */
 			d = va_arg(ap, int);
-			buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN("0x"));
-			buffer_append_long_hex(srv->errorlog_buf, d);
+			buffer_append_string_len(out, CONST_STR_LEN("0x"));
+			buffer_append_long_hex(out, d);
 			break;
 		case '(':
 		case ')':
@@ -355,24 +318,111 @@
 		case '>':
 		case ',':
 		case ' ':
-			buffer_append_string_len(srv->errorlog_buf, fmt, 1);
+			buffer_append_string_len(out, fmt, 1);
 			break;
 		}
 	}
-	va_end(ap);
+}
 
+static int log_buffer_prepare(buffer *b, server *srv, const char *filename, unsigned int line) {
 	switch(srv->errorlog_mode) {
 	case ERRORLOG_PIPE:
 	case ERRORLOG_FILE:
 	case ERRORLOG_FD:
-		buffer_append_string_len(srv->errorlog_buf, CONST_STR_LEN("\n"));
-		write(srv->errorlog_fd, srv->errorlog_buf->ptr, srv->errorlog_buf->used - 1);
+		if (-1 == srv->errorlog_fd) return -1;
+		/* cache the generated timestamp */
+		if (srv->cur_ts != srv->last_generated_debug_ts) {
+			buffer_prepare_copy(srv->ts_debug_str, 255);
+			strftime(srv->ts_debug_str->ptr, srv->ts_debug_str->size - 1, "%Y-%m-%d %H:%M:%S", localtime(&(srv->cur_ts)));
+			srv->ts_debug_str->used = strlen(srv->ts_debug_str->ptr) + 1;
+
+			srv->last_generated_debug_ts = srv->cur_ts;
+		}
+
+		buffer_copy_string_buffer(b, srv->ts_debug_str);
+		buffer_append_string_len(b, CONST_STR_LEN(": ("));
 		break;
 	case ERRORLOG_SYSLOG:
-		syslog(LOG_ERR, "%s", srv->errorlog_buf->ptr);
+		/* syslog is generating its own timestamps */
+		buffer_copy_string_len(b, CONST_STR_LEN("("));
 		break;
 	}
 
+	buffer_append_string(b, filename);
+	buffer_append_string_len(b, CONST_STR_LEN("."));
+	buffer_append_long(b, line);
+	buffer_append_string_len(b, CONST_STR_LEN(") "));
+
 	return 0;
 }
 
+static void log_write(server *srv, buffer *b) {
+	switch(srv->errorlog_mode) {
+	case ERRORLOG_PIPE:
+	case ERRORLOG_FILE:
+	case ERRORLOG_FD:
+		buffer_append_string_len(b, CONST_STR_LEN("\n"));
+		force_assert(b->used > 0);
+		write(srv->errorlog_fd, b->ptr, b->used - 1);
+		break;
+	case ERRORLOG_SYSLOG:
+		syslog(LOG_ERR, "%s", b->ptr);
+		break;
+	}
+}
+
+int log_error_write(server *srv, const char *filename, unsigned int line, const char *fmt, ...) {
+	va_list ap;
+
+	if (-1 == log_buffer_prepare(srv->errorlog_buf, srv, filename, line)) return 0;
+
+	va_start(ap, fmt);
+	log_buffer_append_printf(srv->errorlog_buf, fmt, ap);
+	va_end(ap);
+
+	log_write(srv, srv->errorlog_buf);
+
+	return 0;
+}
+
+int log_error_write_multiline_buffer(server *srv, const char *filename, unsigned int line, buffer *multiline, const char *fmt, ...) {
+	va_list ap;
+	size_t prefix_used;
+	buffer *b = srv->errorlog_buf;
+	char *pos, *end, *current_line;
+
+	if (multiline->used < 2) return 0;
+
+	if (-1 == log_buffer_prepare(b, srv, filename, line)) return 0;
+
+	va_start(ap, fmt);
+	log_buffer_append_printf(b, fmt, ap);
+	va_end(ap);
+
+	prefix_used = b->used;
+
+	current_line = pos = multiline->ptr;
+	end = multiline->ptr + multiline->used;
+
+	for ( ; pos < end ; ++pos) {
+		switch (*pos) {
+		case '\n':
+		case '\r':
+		case '\0': /* handles end of string */
+			if (current_line < pos) {
+				/* truncate to prefix */
+				b->used = prefix_used;
+				b->ptr[b->used - 1] = '\0';
+
+				buffer_append_string_len(b, current_line, pos - current_line);
+				log_write(srv, b);
+			}
+			current_line = pos + 1;
+			break;
+		default:
+			break;
+		}
+	}
+
+	return 0;
+}
diff -u lighttpd-1.4.32/src/log.h lighttpd-1.4.35/src/log.h
--- lighttpd-1.4.32/src/log.h	2010-02-01 17:28:20.000000000 -0600
+++ lighttpd-1.4.35/src/log.h	2014-02-25 16:47:55.000000000 -0600
@@ -8,13 +8,12 @@
  */
 int openDevNull(int fd);
 
-#define WP() log_error_write(srv, __FILE__, __LINE__, "");
-
 int open_logfile_or_pipe(server *srv, const char* logfile);
 
 int log_error_open(server *srv);
 int log_error_close(server *srv);
 int log_error_write(server *srv, const char *filename, unsigned int line, const char *fmt, ...);
+int log_error_write_multiline_buffer(server *srv, const char *filename, unsigned int line, buffer *multiline, const char *fmt, ...);
 int log_error_cycle(server *srv);
 
 #endif
diff -u lighttpd-1.4.32/src/Makefile.am lighttpd-1.4.35/src/Makefile.am
--- lighttpd-1.4.32/src/Makefile.am	2012-11-17 11:32:01.000000000 -0600
+++ lighttpd-1.4.35/src/Makefile.am	2014-03-06 08:08:00.000000000 -0600
@@ -98,171 +98,171 @@
 
 lib_LTLIBRARIES += mod_flv_streaming.la
 mod_flv_streaming_la_SOURCES = mod_flv_streaming.c
-mod_flv_streaming_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_flv_streaming_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_flv_streaming_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_evasive.la
 mod_evasive_la_SOURCES = mod_evasive.c
-mod_evasive_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_evasive_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_evasive_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_webdav.la
 mod_webdav_la_SOURCES = mod_webdav.c
 mod_webdav_la_CFLAGS = $(AM_CFLAGS) $(XML_CFLAGS) $(SQLITE_CFLAGS) 
-mod_webdav_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_webdav_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_webdav_la_LIBADD = $(common_libadd) $(XML_LIBS) $(SQLITE_LIBS) $(UUID_LIBS)
 
 lib_LTLIBRARIES += mod_magnet.la
 mod_magnet_la_SOURCES = mod_magnet.c mod_magnet_cache.c
 mod_magnet_la_CFLAGS = $(AM_CFLAGS) $(LUA_CFLAGS)
-mod_magnet_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_magnet_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_magnet_la_LIBADD = $(common_libadd) $(LUA_LIBS) -lm
 
 lib_LTLIBRARIES += mod_cml.la
 mod_cml_la_SOURCES = mod_cml.c mod_cml_lua.c mod_cml_funcs.c
 mod_cml_la_CFLAGS = $(AM_CFLAGS) $(LUA_CFLAGS)
-mod_cml_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_cml_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_cml_la_LIBADD = $(MEMCACHE_LIB) $(common_libadd) $(LUA_LIBS) -lm
 
 lib_LTLIBRARIES += mod_trigger_b4_dl.la
 mod_trigger_b4_dl_la_SOURCES = mod_trigger_b4_dl.c
-mod_trigger_b4_dl_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_trigger_b4_dl_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_trigger_b4_dl_la_LIBADD = $(GDBM_LIB) $(MEMCACHE_LIB) $(PCRE_LIB) $(common_libadd)
 
 lib_LTLIBRARIES += mod_mysql_vhost.la
 mod_mysql_vhost_la_SOURCES = mod_mysql_vhost.c
-mod_mysql_vhost_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_mysql_vhost_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_mysql_vhost_la_LIBADD = $(MYSQL_LIBS) $(common_libadd)
 mod_mysql_vhost_la_CPPFLAGS = $(MYSQL_INCLUDE)
 
 lib_LTLIBRARIES += mod_cgi.la
 mod_cgi_la_SOURCES = mod_cgi.c
-mod_cgi_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_cgi_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_cgi_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_scgi.la
 mod_scgi_la_SOURCES = mod_scgi.c
-mod_scgi_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_scgi_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_scgi_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_staticfile.la
 mod_staticfile_la_SOURCES = mod_staticfile.c
-mod_staticfile_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_staticfile_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_staticfile_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_dirlisting.la
 mod_dirlisting_la_SOURCES = mod_dirlisting.c
-mod_dirlisting_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_dirlisting_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_dirlisting_la_LIBADD = $(common_libadd) $(PCRE_LIB)
 
 lib_LTLIBRARIES += mod_indexfile.la
 mod_indexfile_la_SOURCES = mod_indexfile.c
-mod_indexfile_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_indexfile_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_indexfile_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_setenv.la
 mod_setenv_la_SOURCES = mod_setenv.c
-mod_setenv_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_setenv_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_setenv_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_alias.la
 mod_alias_la_SOURCES = mod_alias.c
-mod_alias_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_alias_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_alias_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_userdir.la
 mod_userdir_la_SOURCES = mod_userdir.c
-mod_userdir_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_userdir_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_userdir_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_rrdtool.la
 mod_rrdtool_la_SOURCES = mod_rrdtool.c
-mod_rrdtool_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_rrdtool_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_rrdtool_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_usertrack.la
 mod_usertrack_la_SOURCES = mod_usertrack.c
-mod_usertrack_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_usertrack_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_usertrack_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_proxy.la
 mod_proxy_la_SOURCES = mod_proxy.c
-mod_proxy_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_proxy_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_proxy_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_ssi.la
 mod_ssi_la_SOURCES = mod_ssi_exprparser.c mod_ssi_expr.c mod_ssi.c
-mod_ssi_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_ssi_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_ssi_la_LIBADD = $(common_libadd) $(PCRE_LIB)
 
 lib_LTLIBRARIES += mod_secdownload.la
 mod_secdownload_la_SOURCES = mod_secure_download.c
-mod_secdownload_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_secdownload_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_secdownload_la_LIBADD = $(common_libadd)
 
 #lib_LTLIBRARIES += mod_httptls.la
 #mod_httptls_la_SOURCES = mod_httptls.c
-#mod_httptls_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+#mod_httptls_la_LDFLAGS = -module -export-dynamic -avoid-version
 #mod_httptls_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_expire.la
 mod_expire_la_SOURCES = mod_expire.c
-mod_expire_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_expire_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_expire_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_evhost.la
 mod_evhost_la_SOURCES = mod_evhost.c
-mod_evhost_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_evhost_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_evhost_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_simple_vhost.la
 mod_simple_vhost_la_SOURCES = mod_simple_vhost.c
-mod_simple_vhost_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_simple_vhost_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_simple_vhost_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_fastcgi.la
 mod_fastcgi_la_SOURCES = mod_fastcgi.c
-mod_fastcgi_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_fastcgi_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_fastcgi_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_extforward.la
 mod_extforward_la_SOURCES = mod_extforward.c
-mod_extforward_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_extforward_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_extforward_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_access.la
 mod_access_la_SOURCES = mod_access.c
-mod_access_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_access_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_access_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_compress.la
 mod_compress_la_SOURCES = mod_compress.c
-mod_compress_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_compress_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_compress_la_LIBADD = $(Z_LIB) $(BZ_LIB) $(common_libadd)
 
 lib_LTLIBRARIES += mod_auth.la
 mod_auth_la_SOURCES = mod_auth.c http_auth.c
-mod_auth_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
-mod_auth_la_LIBADD = $(CRYPT_LIB) $(LDAP_LIB) $(LBER_LIB) $(common_libadd)
+mod_auth_la_LDFLAGS = -module -export-dynamic -avoid-version
+mod_auth_la_LIBADD = $(CRYPT_LIB) $(SSL_LIB) $(LDAP_LIB) $(LBER_LIB) $(common_libadd)
 
 lib_LTLIBRARIES += mod_rewrite.la
 mod_rewrite_la_SOURCES = mod_rewrite.c
-mod_rewrite_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_rewrite_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_rewrite_la_LIBADD = $(PCRE_LIB) $(common_libadd)
 
 lib_LTLIBRARIES += mod_redirect.la
 mod_redirect_la_SOURCES = mod_redirect.c
-mod_redirect_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_redirect_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_redirect_la_LIBADD = $(PCRE_LIB) $(common_libadd)
 
 lib_LTLIBRARIES += mod_status.la
 mod_status_la_SOURCES = mod_status.c
-mod_status_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_status_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_status_la_LIBADD = $(common_libadd)
 
 lib_LTLIBRARIES += mod_accesslog.la
 mod_accesslog_la_SOURCES = mod_accesslog.c
-mod_accesslog_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_accesslog_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_accesslog_la_LIBADD = $(common_libadd)
 
 
diff -u lighttpd-1.4.32/src/Makefile.in lighttpd-1.4.35/src/Makefile.in
--- lighttpd-1.4.32/src/Makefile.in	2012-11-20 04:56:23.000000000 -0600
+++ lighttpd-1.4.35/src/Makefile.in	2014-03-11 06:57:30.000000000 -0500
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.6 from Makefile.am.
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -18,23 +17,51 @@
 
 
 VPATH = @srcdir@
-am__make_dryrun = \
-  { \
-    am__dry=no; \
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
     case $$MAKEFLAGS in \
       *\\[\ \	]*) \
-        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
-          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
-      *) \
-        for am__flg in $$MAKEFLAGS; do \
-          case $$am__flg in \
-            *=*|--*) ;; \
-            *n*) am__dry=yes; break;; \
-          esac; \
-        done;; \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
     esac; \
-    test $$am__dry = yes; \
-  }
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -63,8 +90,8 @@
 @NO_RDYNAMIC_TRUE@am__append_1 = liblightcomp.la
 @NO_RDYNAMIC_FALSE@am__append_2 = $(common_src)
 subdir = src
-DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
-	$(srcdir)/Makefile.in
+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
+	$(top_srcdir)/depcomp $(noinst_HEADERS)
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
 	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
@@ -154,6 +181,7 @@
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
+am__v_lt_1 = 
 liblightcomp_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
 	$(liblightcomp_la_CFLAGS) $(CFLAGS) $(liblightcomp_la_LDFLAGS) \
@@ -180,7 +208,8 @@
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(mod_alias_la_LDFLAGS) $(LDFLAGS) -o $@
 mod_auth_la_DEPENDENCIES = $(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_2)
+	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_2)
 am_mod_auth_la_OBJECTS = mod_auth.lo http_auth.lo
 mod_auth_la_OBJECTS = $(am_mod_auth_la_OBJECTS)
 mod_auth_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
@@ -442,6 +471,18 @@
 	proc_open-buffer.$(OBJEXT)
 proc_open_OBJECTS = $(am_proc_open_OBJECTS)
 proc_open_LDADD = $(LDADD)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
@@ -454,20 +495,16 @@
 	$(AM_CFLAGS) $(CFLAGS)
 AM_V_CC = $(am__v_CC_@AM_V@)
 am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
-am__v_CC_0 = @echo "  CC    " $@;
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
 LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(AM_LDFLAGS) $(LDFLAGS) -o $@
 AM_V_CCLD = $(am__v_CCLD_@AM_V@)
 am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
-am__v_CCLD_0 = @echo "  CCLD  " $@;
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN   " $@;
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(liblightcomp_la_SOURCES) $(mod_access_la_SOURCES) \
 	$(mod_accesslog_la_SOURCES) $(mod_alias_la_SOURCES) \
 	$(mod_auth_la_SOURCES) $(mod_cgi_la_SOURCES) \
@@ -511,6 +548,23 @@
     *) (install-info --version) >/dev/null 2>&1;; \
   esac
 HEADERS = $(noinst_HEADERS)
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
@@ -694,7 +748,7 @@
 
 #lib_LTLIBRARIES += mod_httptls.la
 #mod_httptls_la_SOURCES = mod_httptls.c
-#mod_httptls_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+#mod_httptls_la_LDFLAGS = -module -export-dynamic -avoid-version
 #mod_httptls_la_LIBADD = $(common_libadd)
 lib_LTLIBRARIES = $(am__append_1) mod_flv_streaming.la mod_evasive.la \
 	mod_webdav.la mod_magnet.la mod_cml.la mod_trigger_b4_dl.la \
@@ -712,104 +766,104 @@
 @NO_RDYNAMIC_FALSE@common_libadd = 
 @NO_RDYNAMIC_TRUE@common_libadd = liblightcomp.la
 mod_flv_streaming_la_SOURCES = mod_flv_streaming.c
-mod_flv_streaming_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_flv_streaming_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_flv_streaming_la_LIBADD = $(common_libadd)
 mod_evasive_la_SOURCES = mod_evasive.c
-mod_evasive_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_evasive_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_evasive_la_LIBADD = $(common_libadd)
 mod_webdav_la_SOURCES = mod_webdav.c
 mod_webdav_la_CFLAGS = $(AM_CFLAGS) $(XML_CFLAGS) $(SQLITE_CFLAGS) 
-mod_webdav_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_webdav_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_webdav_la_LIBADD = $(common_libadd) $(XML_LIBS) $(SQLITE_LIBS) $(UUID_LIBS)
 mod_magnet_la_SOURCES = mod_magnet.c mod_magnet_cache.c
 mod_magnet_la_CFLAGS = $(AM_CFLAGS) $(LUA_CFLAGS)
-mod_magnet_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_magnet_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_magnet_la_LIBADD = $(common_libadd) $(LUA_LIBS) -lm
 mod_cml_la_SOURCES = mod_cml.c mod_cml_lua.c mod_cml_funcs.c
 mod_cml_la_CFLAGS = $(AM_CFLAGS) $(LUA_CFLAGS)
-mod_cml_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_cml_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_cml_la_LIBADD = $(MEMCACHE_LIB) $(common_libadd) $(LUA_LIBS) -lm
 mod_trigger_b4_dl_la_SOURCES = mod_trigger_b4_dl.c
-mod_trigger_b4_dl_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_trigger_b4_dl_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_trigger_b4_dl_la_LIBADD = $(GDBM_LIB) $(MEMCACHE_LIB) $(PCRE_LIB) $(common_libadd)
 mod_mysql_vhost_la_SOURCES = mod_mysql_vhost.c
-mod_mysql_vhost_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_mysql_vhost_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_mysql_vhost_la_LIBADD = $(MYSQL_LIBS) $(common_libadd)
 mod_mysql_vhost_la_CPPFLAGS = $(MYSQL_INCLUDE)
 mod_cgi_la_SOURCES = mod_cgi.c
-mod_cgi_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_cgi_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_cgi_la_LIBADD = $(common_libadd)
 mod_scgi_la_SOURCES = mod_scgi.c
-mod_scgi_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_scgi_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_scgi_la_LIBADD = $(common_libadd)
 mod_staticfile_la_SOURCES = mod_staticfile.c
-mod_staticfile_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_staticfile_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_staticfile_la_LIBADD = $(common_libadd)
 mod_dirlisting_la_SOURCES = mod_dirlisting.c
-mod_dirlisting_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_dirlisting_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_dirlisting_la_LIBADD = $(common_libadd) $(PCRE_LIB)
 mod_indexfile_la_SOURCES = mod_indexfile.c
-mod_indexfile_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_indexfile_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_indexfile_la_LIBADD = $(common_libadd)
 mod_setenv_la_SOURCES = mod_setenv.c
-mod_setenv_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_setenv_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_setenv_la_LIBADD = $(common_libadd)
 mod_alias_la_SOURCES = mod_alias.c
-mod_alias_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_alias_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_alias_la_LIBADD = $(common_libadd)
 mod_userdir_la_SOURCES = mod_userdir.c
-mod_userdir_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_userdir_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_userdir_la_LIBADD = $(common_libadd)
 mod_rrdtool_la_SOURCES = mod_rrdtool.c
-mod_rrdtool_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_rrdtool_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_rrdtool_la_LIBADD = $(common_libadd)
 mod_usertrack_la_SOURCES = mod_usertrack.c
-mod_usertrack_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_usertrack_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_usertrack_la_LIBADD = $(common_libadd)
 mod_proxy_la_SOURCES = mod_proxy.c
-mod_proxy_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_proxy_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_proxy_la_LIBADD = $(common_libadd)
 mod_ssi_la_SOURCES = mod_ssi_exprparser.c mod_ssi_expr.c mod_ssi.c
-mod_ssi_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_ssi_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_ssi_la_LIBADD = $(common_libadd) $(PCRE_LIB)
 mod_secdownload_la_SOURCES = mod_secure_download.c
-mod_secdownload_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_secdownload_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_secdownload_la_LIBADD = $(common_libadd)
 mod_expire_la_SOURCES = mod_expire.c
-mod_expire_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_expire_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_expire_la_LIBADD = $(common_libadd)
 mod_evhost_la_SOURCES = mod_evhost.c
-mod_evhost_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_evhost_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_evhost_la_LIBADD = $(common_libadd)
 mod_simple_vhost_la_SOURCES = mod_simple_vhost.c
-mod_simple_vhost_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_simple_vhost_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_simple_vhost_la_LIBADD = $(common_libadd)
 mod_fastcgi_la_SOURCES = mod_fastcgi.c
-mod_fastcgi_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_fastcgi_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_fastcgi_la_LIBADD = $(common_libadd)
 mod_extforward_la_SOURCES = mod_extforward.c
-mod_extforward_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_extforward_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_extforward_la_LIBADD = $(common_libadd)
 mod_access_la_SOURCES = mod_access.c
-mod_access_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_access_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_access_la_LIBADD = $(common_libadd)
 mod_compress_la_SOURCES = mod_compress.c
-mod_compress_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_compress_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_compress_la_LIBADD = $(Z_LIB) $(BZ_LIB) $(common_libadd)
 mod_auth_la_SOURCES = mod_auth.c http_auth.c
-mod_auth_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
-mod_auth_la_LIBADD = $(CRYPT_LIB) $(LDAP_LIB) $(LBER_LIB) $(common_libadd)
+mod_auth_la_LDFLAGS = -module -export-dynamic -avoid-version
+mod_auth_la_LIBADD = $(CRYPT_LIB) $(SSL_LIB) $(LDAP_LIB) $(LBER_LIB) $(common_libadd)
 mod_rewrite_la_SOURCES = mod_rewrite.c
-mod_rewrite_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_rewrite_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_rewrite_la_LIBADD = $(PCRE_LIB) $(common_libadd)
 mod_redirect_la_SOURCES = mod_redirect.c
-mod_redirect_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_redirect_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_redirect_la_LIBADD = $(PCRE_LIB) $(common_libadd)
 mod_status_la_SOURCES = mod_status.c
-mod_status_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_status_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_status_la_LIBADD = $(common_libadd)
 mod_accesslog_la_SOURCES = mod_accesslog.c
-mod_accesslog_la_LDFLAGS = -module -export-dynamic -avoid-version -no-undefined
+mod_accesslog_la_LDFLAGS = -module -export-dynamic -avoid-version
 mod_accesslog_la_LIBADD = $(common_libadd)
 hdr = server.h buffer.h network.h log.h keyvalue.h \
       response.h request.h fastcgi.h chunk.h \
@@ -882,6 +936,7 @@
 $(ACLOCAL_M4):  $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(am__aclocal_m4_deps):
+
 install-libLTLIBRARIES: $(lib_LTLIBRARIES)
 	@$(NORMAL_INSTALL)
 	@list='$(lib_LTLIBRARIES)'; test -n "$(libdir)" || list=; \
@@ -908,76 +963,111 @@
 
 clean-libLTLIBRARIES:
 	-test -z "$(lib_LTLIBRARIES)" || rm -f $(lib_LTLIBRARIES)
-	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
-	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
-	  test "$$dir" != "$$p" || dir=.; \
-	  echo "rm -f \"$${dir}/so_locations\""; \
-	  rm -f "$${dir}/so_locations"; \
-	done
+	@list='$(lib_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
+
 liblightcomp.la: $(liblightcomp_la_OBJECTS) $(liblightcomp_la_DEPENDENCIES) $(EXTRA_liblightcomp_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(liblightcomp_la_LINK) $(am_liblightcomp_la_rpath) $(liblightcomp_la_OBJECTS) $(liblightcomp_la_LIBADD) $(LIBS)
+
 mod_access.la: $(mod_access_la_OBJECTS) $(mod_access_la_DEPENDENCIES) $(EXTRA_mod_access_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_access_la_LINK) -rpath $(libdir) $(mod_access_la_OBJECTS) $(mod_access_la_LIBADD) $(LIBS)
+
 mod_accesslog.la: $(mod_accesslog_la_OBJECTS) $(mod_accesslog_la_DEPENDENCIES) $(EXTRA_mod_accesslog_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_accesslog_la_LINK) -rpath $(libdir) $(mod_accesslog_la_OBJECTS) $(mod_accesslog_la_LIBADD) $(LIBS)
+
 mod_alias.la: $(mod_alias_la_OBJECTS) $(mod_alias_la_DEPENDENCIES) $(EXTRA_mod_alias_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_alias_la_LINK) -rpath $(libdir) $(mod_alias_la_OBJECTS) $(mod_alias_la_LIBADD) $(LIBS)
+
 mod_auth.la: $(mod_auth_la_OBJECTS) $(mod_auth_la_DEPENDENCIES) $(EXTRA_mod_auth_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_auth_la_LINK) -rpath $(libdir) $(mod_auth_la_OBJECTS) $(mod_auth_la_LIBADD) $(LIBS)
+
 mod_cgi.la: $(mod_cgi_la_OBJECTS) $(mod_cgi_la_DEPENDENCIES) $(EXTRA_mod_cgi_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_cgi_la_LINK) -rpath $(libdir) $(mod_cgi_la_OBJECTS) $(mod_cgi_la_LIBADD) $(LIBS)
+
 mod_cml.la: $(mod_cml_la_OBJECTS) $(mod_cml_la_DEPENDENCIES) $(EXTRA_mod_cml_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_cml_la_LINK) -rpath $(libdir) $(mod_cml_la_OBJECTS) $(mod_cml_la_LIBADD) $(LIBS)
+
 mod_compress.la: $(mod_compress_la_OBJECTS) $(mod_compress_la_DEPENDENCIES) $(EXTRA_mod_compress_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_compress_la_LINK) -rpath $(libdir) $(mod_compress_la_OBJECTS) $(mod_compress_la_LIBADD) $(LIBS)
+
 mod_dirlisting.la: $(mod_dirlisting_la_OBJECTS) $(mod_dirlisting_la_DEPENDENCIES) $(EXTRA_mod_dirlisting_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_dirlisting_la_LINK) -rpath $(libdir) $(mod_dirlisting_la_OBJECTS) $(mod_dirlisting_la_LIBADD) $(LIBS)
+
 mod_evasive.la: $(mod_evasive_la_OBJECTS) $(mod_evasive_la_DEPENDENCIES) $(EXTRA_mod_evasive_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_evasive_la_LINK) -rpath $(libdir) $(mod_evasive_la_OBJECTS) $(mod_evasive_la_LIBADD) $(LIBS)
+
 mod_evhost.la: $(mod_evhost_la_OBJECTS) $(mod_evhost_la_DEPENDENCIES) $(EXTRA_mod_evhost_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_evhost_la_LINK) -rpath $(libdir) $(mod_evhost_la_OBJECTS) $(mod_evhost_la_LIBADD) $(LIBS)
+
 mod_expire.la: $(mod_expire_la_OBJECTS) $(mod_expire_la_DEPENDENCIES) $(EXTRA_mod_expire_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_expire_la_LINK) -rpath $(libdir) $(mod_expire_la_OBJECTS) $(mod_expire_la_LIBADD) $(LIBS)
+
 mod_extforward.la: $(mod_extforward_la_OBJECTS) $(mod_extforward_la_DEPENDENCIES) $(EXTRA_mod_extforward_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_extforward_la_LINK) -rpath $(libdir) $(mod_extforward_la_OBJECTS) $(mod_extforward_la_LIBADD) $(LIBS)
+
 mod_fastcgi.la: $(mod_fastcgi_la_OBJECTS) $(mod_fastcgi_la_DEPENDENCIES) $(EXTRA_mod_fastcgi_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_fastcgi_la_LINK) -rpath $(libdir) $(mod_fastcgi_la_OBJECTS) $(mod_fastcgi_la_LIBADD) $(LIBS)
+
 mod_flv_streaming.la: $(mod_flv_streaming_la_OBJECTS) $(mod_flv_streaming_la_DEPENDENCIES) $(EXTRA_mod_flv_streaming_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_flv_streaming_la_LINK) -rpath $(libdir) $(mod_flv_streaming_la_OBJECTS) $(mod_flv_streaming_la_LIBADD) $(LIBS)
+
 mod_indexfile.la: $(mod_indexfile_la_OBJECTS) $(mod_indexfile_la_DEPENDENCIES) $(EXTRA_mod_indexfile_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_indexfile_la_LINK) -rpath $(libdir) $(mod_indexfile_la_OBJECTS) $(mod_indexfile_la_LIBADD) $(LIBS)
+
 mod_magnet.la: $(mod_magnet_la_OBJECTS) $(mod_magnet_la_DEPENDENCIES) $(EXTRA_mod_magnet_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_magnet_la_LINK) -rpath $(libdir) $(mod_magnet_la_OBJECTS) $(mod_magnet_la_LIBADD) $(LIBS)
+
 mod_mysql_vhost.la: $(mod_mysql_vhost_la_OBJECTS) $(mod_mysql_vhost_la_DEPENDENCIES) $(EXTRA_mod_mysql_vhost_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_mysql_vhost_la_LINK) -rpath $(libdir) $(mod_mysql_vhost_la_OBJECTS) $(mod_mysql_vhost_la_LIBADD) $(LIBS)
+
 mod_proxy.la: $(mod_proxy_la_OBJECTS) $(mod_proxy_la_DEPENDENCIES) $(EXTRA_mod_proxy_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_proxy_la_LINK) -rpath $(libdir) $(mod_proxy_la_OBJECTS) $(mod_proxy_la_LIBADD) $(LIBS)
+
 mod_redirect.la: $(mod_redirect_la_OBJECTS) $(mod_redirect_la_DEPENDENCIES) $(EXTRA_mod_redirect_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_redirect_la_LINK) -rpath $(libdir) $(mod_redirect_la_OBJECTS) $(mod_redirect_la_LIBADD) $(LIBS)
+
 mod_rewrite.la: $(mod_rewrite_la_OBJECTS) $(mod_rewrite_la_DEPENDENCIES) $(EXTRA_mod_rewrite_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_rewrite_la_LINK) -rpath $(libdir) $(mod_rewrite_la_OBJECTS) $(mod_rewrite_la_LIBADD) $(LIBS)
+
 mod_rrdtool.la: $(mod_rrdtool_la_OBJECTS) $(mod_rrdtool_la_DEPENDENCIES) $(EXTRA_mod_rrdtool_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_rrdtool_la_LINK) -rpath $(libdir) $(mod_rrdtool_la_OBJECTS) $(mod_rrdtool_la_LIBADD) $(LIBS)
+
 mod_scgi.la: $(mod_scgi_la_OBJECTS) $(mod_scgi_la_DEPENDENCIES) $(EXTRA_mod_scgi_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_scgi_la_LINK) -rpath $(libdir) $(mod_scgi_la_OBJECTS) $(mod_scgi_la_LIBADD) $(LIBS)
+
 mod_secdownload.la: $(mod_secdownload_la_OBJECTS) $(mod_secdownload_la_DEPENDENCIES) $(EXTRA_mod_secdownload_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_secdownload_la_LINK) -rpath $(libdir) $(mod_secdownload_la_OBJECTS) $(mod_secdownload_la_LIBADD) $(LIBS)
+
 mod_setenv.la: $(mod_setenv_la_OBJECTS) $(mod_setenv_la_DEPENDENCIES) $(EXTRA_mod_setenv_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_setenv_la_LINK) -rpath $(libdir) $(mod_setenv_la_OBJECTS) $(mod_setenv_la_LIBADD) $(LIBS)
+
 mod_simple_vhost.la: $(mod_simple_vhost_la_OBJECTS) $(mod_simple_vhost_la_DEPENDENCIES) $(EXTRA_mod_simple_vhost_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_simple_vhost_la_LINK) -rpath $(libdir) $(mod_simple_vhost_la_OBJECTS) $(mod_simple_vhost_la_LIBADD) $(LIBS)
+
 mod_ssi.la: $(mod_ssi_la_OBJECTS) $(mod_ssi_la_DEPENDENCIES) $(EXTRA_mod_ssi_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_ssi_la_LINK) -rpath $(libdir) $(mod_ssi_la_OBJECTS) $(mod_ssi_la_LIBADD) $(LIBS)
+
 mod_staticfile.la: $(mod_staticfile_la_OBJECTS) $(mod_staticfile_la_DEPENDENCIES) $(EXTRA_mod_staticfile_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_staticfile_la_LINK) -rpath $(libdir) $(mod_staticfile_la_OBJECTS) $(mod_staticfile_la_LIBADD) $(LIBS)
+
 mod_status.la: $(mod_status_la_OBJECTS) $(mod_status_la_DEPENDENCIES) $(EXTRA_mod_status_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_status_la_LINK) -rpath $(libdir) $(mod_status_la_OBJECTS) $(mod_status_la_LIBADD) $(LIBS)
+
 mod_trigger_b4_dl.la: $(mod_trigger_b4_dl_la_OBJECTS) $(mod_trigger_b4_dl_la_DEPENDENCIES) $(EXTRA_mod_trigger_b4_dl_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_trigger_b4_dl_la_LINK) -rpath $(libdir) $(mod_trigger_b4_dl_la_OBJECTS) $(mod_trigger_b4_dl_la_LIBADD) $(LIBS)
+
 mod_userdir.la: $(mod_userdir_la_OBJECTS) $(mod_userdir_la_DEPENDENCIES) $(EXTRA_mod_userdir_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_userdir_la_LINK) -rpath $(libdir) $(mod_userdir_la_OBJECTS) $(mod_userdir_la_LIBADD) $(LIBS)
+
 mod_usertrack.la: $(mod_usertrack_la_OBJECTS) $(mod_usertrack_la_DEPENDENCIES) $(EXTRA_mod_usertrack_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_usertrack_la_LINK) -rpath $(libdir) $(mod_usertrack_la_OBJECTS) $(mod_usertrack_la_LIBADD) $(LIBS)
+
 mod_webdav.la: $(mod_webdav_la_OBJECTS) $(mod_webdav_la_DEPENDENCIES) $(EXTRA_mod_webdav_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(mod_webdav_la_LINK) -rpath $(libdir) $(mod_webdav_la_OBJECTS) $(mod_webdav_la_LIBADD) $(LIBS)
 
@@ -998,10 +1088,12 @@
 	fi; \
 	for p in $$list; do echo "$$p $$p"; done | \
 	sed 's/$(EXEEXT)$$//' | \
-	while read p p1; do if test -f $$p || test -f $$p1; \
-	  then echo "$$p"; echo "$$p"; else :; fi; \
+	while read p p1; do if test -f $$p \
+	 || test -f $$p1 \
+	  ; then echo "$$p"; echo "$$p"; else :; fi; \
 	done | \
-	sed -e 'p;s,.*/,,;n;h' -e 's|.*|.|' \
+	sed -e 'p;s,.*/,,;n;h' \
+	    -e 's|.*|.|' \
 	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
 	sed 'N;N;N;s,\n, ,g' | \
 	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \
@@ -1022,7 +1114,8 @@
 	@list='$(sbin_PROGRAMS)'; test -n "$(sbindir)" || list=; \
 	files=`for p in $$list; do echo "$$p"; done | \
 	  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \
-	      -e 's/$$/$(EXEEXT)/' `; \
+	      -e 's/$$/$(EXEEXT)/' \
+	`; \
 	test -n "$$list" || exit 0; \
 	echo " ( cd '$(DESTDIR)$(sbindir)' && rm -f" $$files ")"; \
 	cd "$(DESTDIR)$(sbindir)" && rm -f $$files
@@ -1035,15 +1128,19 @@
 	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
 	echo " rm -f" $$list; \
 	rm -f $$list
+
 lemon$(EXEEXT): $(lemon_OBJECTS) $(lemon_DEPENDENCIES) $(EXTRA_lemon_DEPENDENCIES) 
 	@rm -f lemon$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(lemon_OBJECTS) $(lemon_LDADD) $(LIBS)
+
 lighttpd$(EXEEXT): $(lighttpd_OBJECTS) $(lighttpd_DEPENDENCIES) $(EXTRA_lighttpd_DEPENDENCIES) 
 	@rm -f lighttpd$(EXEEXT)
 	$(AM_V_CCLD)$(lighttpd_LINK) $(lighttpd_OBJECTS) $(lighttpd_LDADD) $(LIBS)
+
 lighttpd-angel$(EXEEXT): $(lighttpd_angel_OBJECTS) $(lighttpd_angel_DEPENDENCIES) $(EXTRA_lighttpd_angel_DEPENDENCIES) 
 	@rm -f lighttpd-angel$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(lighttpd_angel_OBJECTS) $(lighttpd_angel_LDADD) $(LIBS)
+
 proc_open$(EXEEXT): $(proc_open_OBJECTS) $(proc_open_DEPENDENCIES) $(EXTRA_proc_open_DEPENDENCIES) 
 	@rm -f proc_open$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(proc_open_OBJECTS) $(proc_open_LDADD) $(LIBS)
@@ -1190,14 +1287,14 @@
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c $<
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
 
 .c.obj:
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c `$(CYGPATH_W) '$<'`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
 .c.lo:
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
@@ -1569,26 +1666,15 @@
 clean-libtool:
 	-rm -rf .libs _libs
 
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
 
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -1600,15 +1686,11 @@
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -1617,6 +1699,21 @@
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
@@ -1766,20 +1863,20 @@
 
 .MAKE: all check install install-am install-strip
 
-.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
 	clean-libLTLIBRARIES clean-libtool clean-noinstPROGRAMS \
-	clean-sbinPROGRAMS ctags distclean distclean-compile \
-	distclean-generic distclean-libtool distclean-tags distdir dvi \
-	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-dvi install-dvi-am \
-	install-exec install-exec-am install-html install-html-am \
-	install-info install-info-am install-libLTLIBRARIES \
-	install-man install-pdf install-pdf-am install-ps \
-	install-ps-am install-sbinPROGRAMS install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
+	clean-sbinPROGRAMS cscopelist-am ctags ctags-am distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am \
+	install-libLTLIBRARIES install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-sbinPROGRAMS install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
 	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-libLTLIBRARIES \
+	tags tags-am uninstall uninstall-am uninstall-libLTLIBRARIES \
 	uninstall-sbinPROGRAMS
 
 
diff -u lighttpd-1.4.32/src/mod_access.c lighttpd-1.4.35/src/mod_access.c
--- lighttpd-1.4.32/src/mod_access.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/mod_access.c	2014-03-06 08:08:00.000000000 -0600
@@ -61,7 +61,7 @@
 		{ NULL,                          NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
 	};
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
diff -u lighttpd-1.4.32/src/mod_accesslog.c lighttpd-1.4.35/src/mod_accesslog.c
--- lighttpd-1.4.32/src/mod_accesslog.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.35/src/mod_accesslog.c	2014-03-06 08:08:00.000000000 -0600
@@ -124,16 +124,17 @@
 
 typedef struct {
 	buffer *access_logfile;
-	buffer *format;
-	unsigned short use_syslog;
+	int    log_access_fd;
+	buffer *access_logbuffer; /* each logfile has a separate buffer */
 
+	unsigned short use_syslog; /* syslog has global buffer */
+	unsigned short syslog_level;
+
+	buffer *format;
 
-	int    log_access_fd;
 	time_t last_generated_accesslog_ts;
 	time_t *last_generated_accesslog_ts_ptr;
 
-
-	buffer *access_logbuffer;
 	buffer *ts_accesslog_str;
 	buffer *ts_accesslog_fmt_str;
 	unsigned short append_tz_offset;
@@ -146,12 +147,15 @@
 
 	plugin_config **config_storage;
 	plugin_config conf;
+
+	buffer *syslog_logbuffer; /* syslog has global buffer. no caching, always written directly */
 } plugin_data;
 
 INIT_FUNC(mod_accesslog_init) {
 	plugin_data *p;
 
 	p = calloc(1, sizeof(*p));
+	p->syslog_logbuffer = buffer_init();
 
 	return p;
 }
@@ -413,13 +417,7 @@
 			if (!s) continue;
 
 			if (s->access_logbuffer->used) {
-				if (s->use_syslog) {
-# ifdef HAVE_SYSLOG_H
-					if (s->access_logbuffer->used > 2) {
-						syslog(LOG_INFO, "%*s", (int) s->access_logbuffer->used - 2, s->access_logbuffer->ptr);
-					}
-# endif
-				} else if (s->log_access_fd != -1) {
+				if (s->log_access_fd != -1) {
 					write(s->log_access_fd, s->access_logbuffer->ptr, s->access_logbuffer->used - 1);
 				}
 			}
@@ -448,6 +446,7 @@
 		free(p->config_storage);
 	}
 
+	if (p->syslog_logbuffer) buffer_free(p->syslog_logbuffer);
 	free(p);
 
 	return HANDLER_GO_ON;
@@ -461,12 +460,13 @@
 		{ "accesslog.filename",             NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },
 		{ "accesslog.use-syslog",           NULL, T_CONFIG_BOOLEAN, T_CONFIG_SCOPE_CONNECTION },
 		{ "accesslog.format",               NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },
+		{ "accesslog.syslog-level",         NULL, T_CONFIG_SHORT, T_CONFIG_SCOPE_CONNECTION },
 		{ NULL,                             NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
 	};
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -480,11 +480,13 @@
 		s->log_access_fd = -1;
 		s->last_generated_accesslog_ts = 0;
 		s->last_generated_accesslog_ts_ptr = &(s->last_generated_accesslog_ts);
+		s->syslog_level = LOG_INFO;
 
 
 		cv[0].destination = s->access_logfile;
 		cv[1].destination = &(s->use_syslog);
 		cv[2].destination = s->format;
+		cv[3].destination = &(s->syslog_level);
 
 		p->config_storage[i] = s;
 
@@ -590,14 +592,7 @@
 		plugin_config *s = p->config_storage[i];
 
 		if (s->access_logbuffer->used) {
-			if (s->use_syslog) {
-#ifdef HAVE_SYSLOG_H
-				if (s->access_logbuffer->used > 2) {
-					/* syslog appends a \n on its own */
-					syslog(LOG_INFO, "%*s", (int) s->access_logbuffer->used - 2, s->access_logbuffer->ptr);
-				}
-#endif
-			} else if (s->log_access_fd != -1) {
+			if (s->log_access_fd != -1) {
 				write(s->log_access_fd, s->access_logbuffer->ptr, s->access_logbuffer->used - 1);
 			}
 
@@ -608,7 +603,7 @@
 		    s->access_logfile->used > 1 &&
 		    s->access_logfile->ptr[0] != '|') {
 
-			close(s->log_access_fd);
+			if (-1 != s->log_access_fd) close(s->log_access_fd);
 
 			if (-1 == (s->log_access_fd =
 				   open(s->access_logfile->ptr, O_APPEND | O_WRONLY | O_CREAT | O_LARGEFILE, 0644))) {
@@ -617,9 +612,7 @@
 
 				return HANDLER_ERROR;
 			}
-#ifdef FD_CLOEXEC
-			fcntl(s->log_access_fd, F_SETFD, FD_CLOEXEC);
-#endif
+			fd_close_on_exec(s->log_access_fd);
 		}
 	}
 
@@ -642,6 +635,7 @@
 	PATCH(append_tz_offset);
 	PATCH(parsed_format);
 	PATCH(use_syslog);
+	PATCH(syslog_level);
 
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -668,7 +662,8 @@
 				PATCH(append_tz_offset);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("accesslog.use-syslog"))) {
 				PATCH(use_syslog);
-				PATCH(access_logbuffer);
+			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("accesslog.syslog-level"))) {
+				PATCH(syslog_level);
 			}
 		}
 	}
@@ -690,7 +685,12 @@
 	/* No output device, nothing to do */
 	if (!p->conf.use_syslog && p->conf.log_access_fd == -1) return HANDLER_GO_ON;
 
-	b = p->conf.access_logbuffer;
+	if (p->conf.use_syslog) {
+		b = p->syslog_logbuffer;
+	} else {
+		b = p->conf.access_logbuffer;
+	}
+
 	if (b->used == 0) {
 		buffer_copy_string_len(b, CONST_STR_LEN(""));
 	}
@@ -765,8 +765,8 @@
 				buffer_append_string_len(b, CONST_STR_LEN("-"));
 				break;
 			case FORMAT_REMOTE_USER:
-				if (con->authed_user->used > 1) {
-					buffer_append_string_buffer(b, con->authed_user);
+				if (NULL != (ds = (data_string *)array_get_element(con->environment, "REMOTE_USER")) && ds->value->used > 1) {
+					accesslog_append_escaped(b, ds->value);
 				} else {
 					buffer_append_string_len(b, CONST_STR_LEN("-"));
 				}
@@ -911,10 +911,11 @@
 #ifdef HAVE_SYSLOG_H
 			if (b->used > 2) {
 				/* syslog appends a \n on its own */
-				syslog(LOG_INFO, "%*s", (int) b->used - 2, b->ptr);
+				syslog(p->conf.syslog_level, "%*s", (int) b->used - 2, b->ptr);
 			}
 #endif
 		} else if (p->conf.log_access_fd != -1) {
+			force_assert(b->used > 0);
 			write(p->conf.log_access_fd, b->ptr, b->used - 1);
 		}
 		buffer_reset(b);
diff -u lighttpd-1.4.32/src/mod_alias.c lighttpd-1.4.35/src/mod_alias.c
--- lighttpd-1.4.32/src/mod_alias.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/mod_alias.c	2014-03-06 08:08:00.000000000 -0600
@@ -72,7 +72,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -156,7 +156,8 @@
 	mod_alias_patch_connection(srv, con, p);
 
 	/* not to include the tailing slash */
-	basedir_len = (con->physical.basedir->used - 1) - 1;
+	basedir_len = (con->physical.basedir->used - 1);
+	if ('/' == con->physical.basedir->ptr[basedir_len-1]) --basedir_len;
 	uri_len = con->physical.path->used - 1 - basedir_len;
 	uri_ptr = con->physical.path->ptr + basedir_len;
 
diff -u lighttpd-1.4.32/src/mod_auth.c lighttpd-1.4.35/src/mod_auth.c
--- lighttpd-1.4.32/src/mod_auth.c	2012-04-19 07:05:52.000000000 -0500
+++ lighttpd-1.4.35/src/mod_auth.c	2014-03-06 08:08:00.000000000 -0600
@@ -185,6 +185,7 @@
 	data_string *ds;
 	mod_auth_plugin_data *p = p_d;
 	array *req;
+	data_string *req_method;
 
 	/* select the right config */
 	mod_auth_patch_connection(srv, con, p);
@@ -227,18 +228,30 @@
 	if (auth_required == 0) return HANDLER_GO_ON;
 
 	req = ((data_array *)(p->conf.auth_require->data[k]))->value;
+	req_method = (data_string *)array_get_element(req, "method");
 
-	/* try to get Authorization-header */
-
-	if (NULL != (ds = (data_string *)array_get_element(con->request.headers, "Authorization"))) {
-		http_authorization = ds->value->ptr;
+	if (0 == strcmp(req_method->value->ptr, "extern")) {
+		/* require REMOTE_USER to be already set */
+		if (NULL == (ds = (data_string *)array_get_element(con->environment, "REMOTE_USER"))) {
+			con->http_status = 401;
+			con->mode = DIRECT;
+			return HANDLER_FINISHED;
+		} else if (http_auth_match_rules(srv, req, ds->value->ptr, NULL, NULL)) {
+			log_error_write(srv, __FILE__, __LINE__, "s", "rules didn't match");
+			con->http_status = 401;
+			con->mode = DIRECT;
+			return HANDLER_FINISHED;
+		} else {
+			return HANDLER_GO_ON;
+		}
 	}
 
-	if (ds && ds->value && ds->value->used) {
+	/* try to get Authorization-header */
+
+	if (NULL != (ds = (data_string *)array_get_element(con->request.headers, "Authorization")) && ds->value->used) {
 		char *auth_realm;
-		data_string *method;
 
-		method = (data_string *)array_get_element(req, "method");
+		http_authorization = ds->value->ptr;
 
 		/* parse auth-header */
 		if (NULL != (auth_realm = strchr(http_authorization, ' '))) {
@@ -248,14 +261,14 @@
 			    (0 == strncasecmp(http_authorization, "Basic", auth_type_len))) {
 				auth_type = "Basic";
 
-				if (0 == strcmp(method->value->ptr, "basic")) {
-					auth_satisfied = http_auth_basic_check(srv, con, p, req, con->uri.path, auth_realm+1);
+				if (0 == strcmp(req_method->value->ptr, "basic")) {
+					auth_satisfied = http_auth_basic_check(srv, con, p, req, auth_realm+1);
 				}
 			} else if ((auth_type_len == 6) &&
 				   (0 == strncasecmp(http_authorization, "Digest", auth_type_len))) {
 				auth_type = "Digest";
-				if (0 == strcmp(method->value->ptr, "digest")) {
-					if (-1 == (auth_satisfied = http_auth_digest_check(srv, con, p, req, con->uri.path, auth_realm+1))) {
+				if (0 == strcmp(req_method->value->ptr, "digest")) {
+					if (-1 == (auth_satisfied = http_auth_digest_check(srv, con, p, req, auth_realm+1))) {
 						con->http_status = 400;
 						con->mode = DIRECT;
 
@@ -304,18 +317,25 @@
 	} else {
 		/* the REMOTE_USER header */
 
-		buffer_copy_string_buffer(con->authed_user, p->auth_user);
+		if (NULL == (ds = (data_string *)array_get_element(con->environment, "REMOTE_USER"))) {
+			if (NULL == (ds = (data_string *)array_get_unused_element(con->environment, TYPE_STRING))) {
+				ds = data_string_init();
+			}
+			buffer_copy_string(ds->key, "REMOTE_USER");
+			array_insert_unique(con->environment, (data_unset *)ds);
+		}
+		buffer_copy_string_buffer(ds->value, p->auth_user);
 
 		/* AUTH_TYPE environment */
 
-		if (NULL == (ds = (data_string *)array_get_unused_element(con->environment, TYPE_STRING))) {
-			ds = data_string_init();
+		if (NULL == (ds = (data_string *)array_get_element(con->environment, "AUTH_TYPE"))) {
+			if (NULL == (ds = (data_string *)array_get_unused_element(con->environment, TYPE_STRING))) {
+				ds = data_string_init();
+			}
+			buffer_copy_string(ds->key, "AUTH_TYPE");
+			array_insert_unique(con->environment, (data_unset *)ds);
 		}
-
-		buffer_copy_string(ds->key, "AUTH_TYPE");
 		buffer_copy_string(ds->value, auth_type);
-
-		array_insert_unique(con->environment, (data_unset *)ds);
 	}
 
 	return HANDLER_GO_ON;
@@ -344,7 +364,7 @@
 		{ NULL,                             NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
 	};
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(mod_auth_plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		mod_auth_plugin_config *s;
@@ -487,9 +507,10 @@
 				return HANDLER_ERROR;
 			} else {
 				if (0 != strcmp(method, "basic") &&
-				    0 != strcmp(method, "digest")) {
+				    0 != strcmp(method, "digest") &&
+				    0 != strcmp(method, "extern")) {
 					log_error_write(srv, __FILE__, __LINE__, "ss",
-							"method has to be either \"basic\" or \"digest\" in",
+							"method has to be either \"basic\", \"digest\" or \"extern\" in",
 							"auth.require = ( \"...\" => ( ..., \"method\" => \"...\") )");
 					return HANDLER_ERROR;
 				}
diff -u lighttpd-1.4.32/src/mod_cgi.c lighttpd-1.4.35/src/mod_cgi.c
--- lighttpd-1.4.32/src/mod_cgi.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.35/src/mod_cgi.c	2014-03-06 08:08:00.000000000 -0600
@@ -85,7 +85,7 @@
 static handler_ctx * cgi_handler_ctx_init(void) {
 	handler_ctx *hctx = calloc(1, sizeof(*hctx));
 
-	assert(hctx);
+	force_assert(hctx);
 
 	hctx->response = buffer_init();
 	hctx->response_header = buffer_init();
@@ -107,7 +107,7 @@
 
 	p = calloc(1, sizeof(*p));
 
-	assert(p);
+	force_assert(p);
 
 	p->tmp_buf = buffer_init();
 	p->parse_response = buffer_init();
@@ -157,13 +157,13 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
 
 		s = calloc(1, sizeof(plugin_config));
-		assert(s);
+		force_assert(s);
 
 		s->cgi    = array_init();
 		s->execute_x_only = 0;
@@ -918,17 +918,10 @@
 			);
 		cgi_env_add(&env, CONST_STR_LEN("REMOTE_PORT"), buf, strlen(buf));
 
-		if (!buffer_is_empty(con->authed_user)) {
-			cgi_env_add(&env, CONST_STR_LEN("REMOTE_USER"),
-				    CONST_BUF_LEN(con->authed_user));
+		if (buffer_is_equal_caseless_string(con->uri.scheme, CONST_STR_LEN("https"))) {
+			cgi_env_add(&env, CONST_STR_LEN("HTTPS"), CONST_STR_LEN("on"));
 		}
 
-#ifdef USE_OPENSSL
-	if (srv_sock->is_ssl) {
-		cgi_env_add(&env, CONST_STR_LEN("HTTPS"), CONST_STR_LEN("on"));
-	}
-#endif
-
 		/* request.content_length < SSIZE_MAX, see request.c */
 		LI_ltostr(buf, con->request.content_length);
 		cgi_env_add(&env, CONST_STR_LEN("CONTENT_LENGTH"), buf, strlen(buf));
diff -u lighttpd-1.4.32/src/mod_cml.c lighttpd-1.4.35/src/mod_cml.c
--- lighttpd-1.4.32/src/mod_cml.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/mod_cml.c	2014-03-06 08:08:00.000000000 -0600
@@ -83,7 +83,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = malloc(srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
diff -u lighttpd-1.4.32/src/mod_cml_lua.c lighttpd-1.4.35/src/mod_cml_lua.c
--- lighttpd-1.4.32/src/mod_cml_lua.c	2012-11-17 11:32:01.000000000 -0600
+++ lighttpd-1.4.35/src/mod_cml_lua.c	2014-03-06 08:08:00.000000000 -0600
@@ -64,7 +64,7 @@
 
 	lua_pop(L, 1);
 
-	assert(curelem - 1 == lua_gettop(L));
+	force_assert(curelem - 1 == lua_gettop(L));
 
 	return 0;
 }
@@ -86,7 +86,7 @@
 
 	lua_settop(L, curelem - 1);
 
-	assert(curelem - 1 == lua_gettop(L));
+	force_assert(curelem - 1 == lua_gettop(L));
 
 	return 1;
 }
@@ -209,12 +209,17 @@
 	lua_State *L;
 	readme rm;
 	int ret = -1;
-	buffer *b = buffer_init();
+	buffer *b;
 	int header_tbl = 0;
 
 	rm.done = 0;
-	stream_open(&rm.st, fn);
+	if (-1 == stream_open(&rm.st, fn)) {
+		log_error_write(srv, __FILE__, __LINE__, "sbss",
+				"opening lua cml file ", fn, "failed:", strerror(errno));
+		return -1;
+	}
 
+	b = buffer_init();
 	/* push the lua file to the interpreter and see what happends */
 	L = luaL_newstate();
 	luaL_openlibs(L);
@@ -398,26 +403,22 @@
 			con->file_finished = 1;
 
 			ds = (data_string *)array_get_element(con->response.headers, "Last-Modified");
+			if (0 == mtime) mtime = time(NULL); /* default last-modified to now */
 
 			/* no Last-Modified specified */
-			if ((mtime) && (NULL == ds)) {
+			if (NULL == ds) {
 
 				strftime(timebuf, sizeof(timebuf), "%a, %d %b %Y %H:%M:%S GMT", gmtime(&mtime));
 
 				response_header_overwrite(srv, con, CONST_STR_LEN("Last-Modified"), timebuf, sizeof(timebuf) - 1);
 
-
 				tbuf.ptr = timebuf;
 				tbuf.used = sizeof(timebuf);
 				tbuf.size = sizeof(timebuf);
-			} else if (ds) {
+			} else {
 				tbuf.ptr = ds->value->ptr;
 				tbuf.used = ds->value->used;
 				tbuf.size = ds->value->size;
-			} else {
-				tbuf.size = 0;
-				tbuf.used = 0;
-				tbuf.ptr = NULL;
 			}
 
 			if (HANDLER_FINISHED == http_response_handle_cachable(srv, con, &tbuf)) {
diff -u lighttpd-1.4.32/src/mod_compress.c lighttpd-1.4.35/src/mod_compress.c
--- lighttpd-1.4.32/src/mod_compress.c	2012-11-17 11:32:01.000000000 -0600
+++ lighttpd-1.4.35/src/mod_compress.c	2014-03-06 08:08:00.000000000 -0600
@@ -12,6 +12,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
+#include <assert.h>
 #include <fcntl.h>
 #include <unistd.h>
 #include <ctype.h>
@@ -161,7 +162,7 @@
 		{ NULL,                             NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
 	};
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -412,7 +413,7 @@
 
 static int deflate_file_to_file(server *srv, connection *con, plugin_data *p, buffer *fn, stat_cache_entry *sce, int type) {
 	int ifd, ofd;
-	int ret = -1;
+	int ret;
 	void *start;
 	const char *filename = fn->ptr;
 	ssize_t r;
@@ -525,6 +526,7 @@
 	}
 #endif
 
+	ret = -1;
 	switch(type) {
 #ifdef USE_ZLIB
 	case HTTP_ACCEPT_ENCODING_GZIP:
@@ -541,9 +543,6 @@
 		ret = deflate_file_to_buffer_bzip2(srv, con, p, start, sce->st.st_size);
 		break;
 #endif
-	default:
-		ret = -1;
-		break;
 	}
 
 	if (ret == 0) {
@@ -860,7 +859,8 @@
 					} else if (matched_encodings & HTTP_ACCEPT_ENCODING_X_GZIP) {
 						compression_type = HTTP_ACCEPT_ENCODING_X_GZIP;
 						compression_name = dflt_x_gzip;
-					} else if (matched_encodings & HTTP_ACCEPT_ENCODING_DEFLATE) {
+					} else {
+						force_assert(matched_encodings & HTTP_ACCEPT_ENCODING_DEFLATE);
 						compression_type = HTTP_ACCEPT_ENCODING_DEFLATE;
 						compression_name = dflt_deflate;
 					}
diff -u lighttpd-1.4.32/src/mod_dirlisting.c lighttpd-1.4.35/src/mod_dirlisting.c
--- lighttpd-1.4.32/src/mod_dirlisting.c	2011-07-19 06:22:48.000000000 -0500
+++ lighttpd-1.4.35/src/mod_dirlisting.c	2014-03-06 08:08:00.000000000 -0600
@@ -278,7 +278,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -672,7 +672,7 @@
 #endif
 
 	path = malloc(dir->used + name_max);
-	assert(path);
+	force_assert(path);
 	strcpy(path, dir->ptr);
 	path_file = path + i;
 
@@ -685,11 +685,11 @@
 	}
 
 	dirs.ent   = (dirls_entry_t**) malloc(sizeof(dirls_entry_t*) * DIRLIST_BLOB_SIZE);
-	assert(dirs.ent);
+	force_assert(dirs.ent);
 	dirs.size  = DIRLIST_BLOB_SIZE;
 	dirs.used  = 0;
 	files.ent  = (dirls_entry_t**) malloc(sizeof(dirls_entry_t*) * DIRLIST_BLOB_SIZE);
-	assert(files.ent);
+	force_assert(files.ent);
 	files.size = DIRLIST_BLOB_SIZE;
 	files.used = 0;
 
@@ -730,7 +730,11 @@
 					log_error_write(srv, __FILE__, __LINE__, "sd",
 						"execution error while matching:", n);
 
-					return -1;
+					/* aborting would require a lot of manual cleanup here.
+					 * skip instead (to not leak names that break pcre matching)
+					 */
+					exclude_match = 1;
+					break;
 				}
 			}
 			else {
@@ -762,7 +766,7 @@
 		if (list->used == list->size) {
 			list->size += DIRLIST_BLOB_SIZE;
 			list->ent   = (dirls_entry_t**) realloc(list->ent, sizeof(dirls_entry_t*) * list->size);
-			assert(list->ent);
+			force_assert(list->ent);
 		}
 
 		tmp = (dirls_entry_t*) malloc(sizeof(dirls_entry_t) + 1 + i);
diff -u lighttpd-1.4.32/src/mod_evasive.c lighttpd-1.4.35/src/mod_evasive.c
--- lighttpd-1.4.32/src/mod_evasive.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/mod_evasive.c	2014-03-06 08:08:00.000000000 -0600
@@ -78,7 +78,7 @@
 		{ NULL,                          NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
 	};
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
diff -u lighttpd-1.4.32/src/mod_evhost.c lighttpd-1.4.35/src/mod_evhost.c
--- lighttpd-1.4.32/src/mod_evhost.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/mod_evhost.c	2014-03-06 08:08:00.000000000 -0600
@@ -128,7 +128,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
diff -u lighttpd-1.4.32/src/mod_expire.c lighttpd-1.4.35/src/mod_expire.c
--- lighttpd-1.4.32/src/mod_expire.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/mod_expire.c	2014-03-06 08:08:00.000000000 -0600
@@ -221,7 +221,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -306,7 +306,8 @@
 			size_t len;
 			stat_cache_entry *sce = NULL;
 
-			stat_cache_get_entry(srv, con, con->physical.path, &sce);
+			/* if stat fails => sce == NULL, ignore return value */
+			(void) stat_cache_get_entry(srv, con, con->physical.path, &sce);
 
 			switch(mod_expire_get_offset(srv, p, ds->value, &ts)) {
 			case 0:
@@ -316,11 +317,16 @@
 			case 1:
 				/* modification */
 
+				/* can't set modification based expire header if
+				 * mtime is not available
+				 */
+				if (NULL == sce) return HANDLER_GO_ON;
+
 				expires = (ts + sce->st.st_mtime);
 				break;
 			default:
 				/* -1 is handled at parse-time */
-				break;
+				return HANDLER_ERROR;
 			}
 
 			/* expires should be at least srv->cur_ts */
diff -u lighttpd-1.4.32/src/mod_extforward.c lighttpd-1.4.35/src/mod_extforward.c
--- lighttpd-1.4.32/src/mod_extforward.c	2012-11-15 02:32:52.000000000 -0600
+++ lighttpd-1.4.35/src/mod_extforward.c	2014-03-06 08:08:00.000000000 -0600
@@ -11,6 +11,7 @@
 #include "config.h"
 #endif
 
+#include <assert.h>
 #include <ctype.h>
 #include <stdlib.h>
 #include <string.h>
@@ -164,7 +165,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -303,11 +304,14 @@
 	return NULL;
 }
 
-static struct addrinfo *ipstr_to_sockaddr(server *srv, const char *host) {
-	struct addrinfo hints, *res0;
+#ifdef HAVE_IPV6
+static void ipstr_to_sockaddr(server *srv, const char *host, sock_addr *sock) {
+	struct addrinfo hints, *addrlist = NULL;
 	int result;
 
 	memset(&hints, 0, sizeof(hints));
+	sock->plain.sa_family = AF_UNSPEC;
+
 #ifndef AI_NUMERICSERV
 	/**
 	  * quoting $ man getaddrinfo
@@ -321,22 +325,31 @@
 	hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV;
 
 	errno = 0;
-	result = getaddrinfo(host, NULL, &hints, &res0);
+	result = getaddrinfo(host, NULL, &hints, &addrlist);
 
 	if (result != 0) {
 		log_error_write(srv, __FILE__, __LINE__, "SSSs(S)",
-			"could not resolve hostname ", host, " because ", gai_strerror(result), strerror(errno));
-
-		return NULL;
-	} else if (res0 == NULL) {
+			"could not parse ip address ", host, " because ", gai_strerror(result), strerror(errno));
+	} else if (addrlist == NULL) {
+		log_error_write(srv, __FILE__, __LINE__, "SSS",
+			"Problem in parsing ip address ", host, ": succeeded, but no information returned");
+	} else switch (addrlist->ai_family) {
+	case AF_INET:
+		memcpy(&sock->ipv4, addrlist->ai_addr, sizeof(sock->ipv4));
+		force_assert(AF_INET == sock->plain.sa_family);
+		break;
+	case AF_INET6:
+		memcpy(&sock->ipv6, addrlist->ai_addr, sizeof(sock->ipv6));
+		force_assert(AF_INET6 == sock->plain.sa_family);
+		break;
+	default:
 		log_error_write(srv, __FILE__, __LINE__, "SSS",
-			"Problem in resolving hostname ", host, ": succeeded, but no information returned");
+			"Problem in parsing ip address ", host, ": succeeded, but unknown family");
 	}
 
-	return res0;
+	freeaddrinfo(addrlist);
 }
-
-
+#endif
 
 static void clean_cond_cache(server *srv, connection *con) {
 	config_cond_cache_reset_item(srv, con, COMP_HTTP_REMOTE_IP);
@@ -347,7 +360,6 @@
 	data_string *forwarded = NULL;
 #ifdef HAVE_IPV6
 	char b2[INET6_ADDRSTRLEN + 1];
-	struct addrinfo *addrlist = NULL;
 #endif
 	const char *dst_addr_str = NULL;
 	array *forward_array = NULL;
@@ -411,34 +423,22 @@
 
 	if (real_remote_addr != NULL) { /* parsed */
 		sock_addr sock;
-		struct addrinfo *addrs_left;
-		server_socket *srv_sock = con->srv_socket;
 		data_string *forwarded_proto = (data_string *)array_get_element(con->request.headers, "X-Forwarded-Proto");
 
-		if (forwarded_proto && !strcmp(forwarded_proto->value->ptr, "https")) {
-			srv_sock->is_proxy_ssl = 1;
-		} else {
-			srv_sock->is_proxy_ssl = 0;
+		if (NULL != forwarded_proto) {
+			if (buffer_is_equal_caseless_string(forwarded_proto->value, CONST_STR_LEN("https"))) {
+				buffer_copy_string_len(con->uri.scheme, CONST_STR_LEN("https"));
+			} else if (buffer_is_equal_caseless_string(forwarded_proto->value, CONST_STR_LEN("http"))) {
+				buffer_copy_string_len(con->uri.scheme, CONST_STR_LEN("http"));
+			}
 		}
 
 		if (con->conf.log_request_handling) {
- 			log_error_write(srv, __FILE__, __LINE__, "ss", "using address:", real_remote_addr);
+			log_error_write(srv, __FILE__, __LINE__, "ss", "using address:", real_remote_addr);
 		}
 #ifdef HAVE_IPV6
-		addrlist = ipstr_to_sockaddr(srv, real_remote_addr);
-		sock.plain.sa_family = AF_UNSPEC;
-		for (addrs_left = addrlist; addrs_left != NULL; addrs_left = addrs_left -> ai_next) {
-			sock.plain.sa_family = addrs_left->ai_family;
-			if (sock.plain.sa_family == AF_INET) {
-				sock.ipv4.sin_addr = ((struct sockaddr_in*)addrs_left->ai_addr)->sin_addr;
-				break;
-			} else if (sock.plain.sa_family == AF_INET6) {
-				sock.ipv6.sin6_addr = ((struct sockaddr_in6*)addrs_left->ai_addr)->sin6_addr;
-				break;
-			}
-		}
+		ipstr_to_sockaddr(srv, real_remote_addr, &sock);
 #else
-		UNUSED(addrs_left);
 		sock.ipv4.sin_addr.s_addr = inet_addr(real_remote_addr);
 		sock.plain.sa_family = (sock.ipv4.sin_addr.s_addr == 0xFFFFFFFF) ? AF_UNSPEC : AF_INET;
 #endif
@@ -464,9 +464,6 @@
 			/* Now, clean the conf_cond cache, because we may have changed the results of tests */
 			clean_cond_cache(srv, con);
 		}
-#ifdef HAVE_IPV6
-		if (addrlist != NULL ) freeaddrinfo(addrlist);
-#endif
 	}
 	array_free(forward_array);
 
diff -u lighttpd-1.4.32/src/mod_fastcgi.c lighttpd-1.4.35/src/mod_fastcgi.c
--- lighttpd-1.4.32/src/mod_fastcgi.c	2012-11-17 11:32:14.000000000 -0600
+++ lighttpd-1.4.35/src/mod_fastcgi.c	2014-03-06 08:08:00.000000000 -0600
@@ -487,7 +487,7 @@
 	handler_ctx * hctx;
 
 	hctx = calloc(1, sizeof(*hctx));
-	assert(hctx);
+	force_assert(hctx);
 
 	hctx->fde_ndx = -1;
 
@@ -634,7 +634,7 @@
 	if (i == ext->used) {
 		/* filextension is new */
 		fe = calloc(1, sizeof(*fe));
-		assert(fe);
+		force_assert(fe);
 		fe->key = buffer_init();
 		fe->last_used_ndx = -1;
 		buffer_copy_string_buffer(fe->key, key);
@@ -644,11 +644,11 @@
 		if (ext->size == 0) {
 			ext->size = 8;
 			ext->exts = malloc(ext->size * sizeof(*(ext->exts)));
-			assert(ext->exts);
+			force_assert(ext->exts);
 		} else if (ext->used == ext->size) {
 			ext->size += 8;
 			ext->exts = realloc(ext->exts, ext->size * sizeof(*(ext->exts)));
-			assert(ext->exts);
+			force_assert(ext->exts);
 		}
 		ext->exts[ext->used++] = fe;
 	} else {
@@ -658,11 +658,11 @@
 	if (fe->size == 0) {
 		fe->size = 4;
 		fe->hosts = malloc(fe->size * sizeof(*(fe->hosts)));
-		assert(fe->hosts);
+		force_assert(fe->hosts);
 	} else if (fe->size == fe->used) {
 		fe->size += 4;
 		fe->hosts = realloc(fe->hosts, fe->size * sizeof(*(fe->hosts)));
-		assert(fe->hosts);
+		force_assert(fe->hosts);
 	}
 
 	fe->hosts[fe->used++] = fh;
@@ -873,7 +873,13 @@
 
 #ifdef HAVE_SYS_UN_H
 		fcgi_addr_un.sun_family = AF_UNIX;
-		strcpy(fcgi_addr_un.sun_path, proc->unixsocket->ptr);
+		if (proc->unixsocket->used > sizeof(fcgi_addr_un.sun_path)) {
+			log_error_write(srv, __FILE__, __LINE__, "sB",
+					"ERROR: Unix Domain socket filename too long:",
+					proc->unixsocket);
+			return -1;
+		}
+		memcpy(fcgi_addr_un.sun_path, proc->unixsocket->ptr, proc->unixsocket->used);
 
 #ifdef SUN_LEN
 		servlen = SUN_LEN(&fcgi_addr_un);
@@ -969,6 +975,7 @@
 		if (setsockopt(fcgi_fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val)) < 0) {
 			log_error_write(srv, __FILE__, __LINE__, "ss",
 					"socketsockopt failed:", strerror(errno));
+			close(fcgi_fd);
 			return -1;
 		}
 
@@ -978,12 +985,14 @@
 				"bind failed for:",
 				proc->connection_name,
 				strerror(errno));
+			close(fcgi_fd);
 			return -1;
 		}
 
 		if (-1 == listen(fcgi_fd, 1024)) {
 			log_error_write(srv, __FILE__, __LINE__, "ss",
 				"listen failed:", strerror(errno));
+			close(fcgi_fd);
 			return -1;
 		}
 
@@ -1161,6 +1170,7 @@
 	data_unset *du;
 	size_t i = 0;
 	buffer *fcgi_mode = buffer_init();
+	fcgi_extension_host *host = NULL;
 
 	config_values_t cv[] = {
 		{ "fastcgi.server",              NULL, T_CONFIG_LOCAL, T_CONFIG_SCOPE_CONNECTION },       /* 0 */
@@ -1169,7 +1179,7 @@
 		{ NULL,                          NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
 	};
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -1188,7 +1198,7 @@
 		ca = ((data_config *)srv->config_context->data[i])->value;
 
 		if (0 != config_insert_values_global(srv, ca, cv)) {
-			return HANDLER_ERROR;
+			goto error;
 		}
 
 		/*
@@ -1203,7 +1213,7 @@
 				log_error_write(srv, __FILE__, __LINE__, "sss",
 						"unexpected type for key: ", "fastcgi.server", "array of strings");
 
-				return HANDLER_ERROR;
+				goto error;
 			}
 
 
@@ -1221,7 +1231,7 @@
 							"unexpected type for key: ", "fastcgi.server",
 							"[", da->value->data[j]->key, "](string)");
 
-					return HANDLER_ERROR;
+					goto error;
 				}
 
 				/*
@@ -1239,8 +1249,6 @@
 				for (n = 0; n < da_ext->value->used; n++) {
 					data_array *da_host = (data_array *)da_ext->value->data[n];
 
-					fcgi_extension_host *host;
-
 					config_values_t fcv[] = {
 						{ "host",              NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },       /* 0 */
 						{ "docroot",           NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },       /* 1 */
@@ -1271,10 +1279,11 @@
 								"fastcgi.server",
 								"[", da_host->key, "](string)");
 
-						return HANDLER_ERROR;
+						goto error;
 					}
 
 					host = fastcgi_host_init();
+					buffer_reset(fcgi_mode);
 
 					buffer_copy_string_buffer(host->id, da_host->key);
 
@@ -1307,7 +1316,7 @@
 					fcv[15].destination = &(host->fix_root_path_name);
 
 					if (0 != config_insert_values_internal(srv, da_host->value, fcv)) {
-						return HANDLER_ERROR;
+						goto error;
 					}
 
 					if ((!buffer_is_empty(host->host) || host->port) &&
@@ -1318,7 +1327,7 @@
 								da_ext->key, " => (",
 								da_host->key, " ( ...");
 
-						return HANDLER_ERROR;
+						goto error;
 					}
 
 					if (!buffer_is_empty(host->unixsocket)) {
@@ -1332,7 +1341,7 @@
 									da_ext->key, " => (",
 									da_host->key, " ( ...");
 
-							return HANDLER_ERROR;
+							goto error;
 						}
 					} else {
 						/* tcp/ip */
@@ -1345,7 +1354,7 @@
 									da_ext->key, " => (",
 									da_host->key, " ( ...");
 
-							return HANDLER_ERROR;
+							goto error;
 						} else if (host->port == 0) {
 							log_error_write(srv, __FILE__, __LINE__, "sbsbsbs",
 									"port has to be set in:",
@@ -1353,7 +1362,7 @@
 									da_ext->key, " => (",
 									da_host->key, " ( ...");
 
-							return HANDLER_ERROR;
+							goto error;
 						}
 					}
 
@@ -1396,13 +1405,14 @@
 							if (fcgi_spawn_connection(srv, p, host, proc)) {
 								log_error_write(srv, __FILE__, __LINE__, "s",
 										"[ERROR]: spawning fcgi failed.");
-								return HANDLER_ERROR;
+								fastcgi_process_free(proc);
+								goto error;
 							}
 
 							fastcgi_status_init(srv, p->statuskey, host, proc);
 
 							proc->next = host->first;
-							if (host->first) 	host->first->prev = proc;
+							if (host->first) host->first->prev = proc;
 
 							host->first = proc;
 						}
@@ -1436,7 +1446,7 @@
 							if (buffer_is_empty(host->docroot)) {
 								log_error_write(srv, __FILE__, __LINE__, "s",
 										"ERROR: docroot is required for authorizer mode.");
-								return HANDLER_ERROR;
+								goto error;
 							}
 						} else {
 							log_error_write(srv, __FILE__, __LINE__, "sbs",
@@ -1447,14 +1457,19 @@
 
 					/* if extension already exists, take it */
 					fastcgi_extension_insert(s->exts, da_ext->key, host);
+					host = NULL;
 				}
 			}
 		}
 	}
 
 	buffer_free(fcgi_mode);
-
 	return HANDLER_GO_ON;
+
+error:
+	if (NULL != host) fastcgi_host_free(host);
+	buffer_free(fcgi_mode);
+	return HANDLER_ERROR;
 }
 
 static int fcgi_set_state(server *srv, handler_ctx *hctx, fcgi_connection_state_t state) {
@@ -1622,7 +1637,7 @@
 }
 
 static int fcgi_header(FCGI_Header * header, unsigned char type, size_t request_id, int contentLength, unsigned char paddingLength) {
-	assert(contentLength <= FCGI_MAX_LENGTH);
+	force_assert(contentLength <= FCGI_MAX_LENGTH);
 	
 	header->version = FCGI_VERSION_1;
 	header->type = type;
@@ -1661,7 +1676,14 @@
 #ifdef HAVE_SYS_UN_H
 		/* use the unix domain socket */
 		fcgi_addr_un.sun_family = AF_UNIX;
-		strcpy(fcgi_addr_un.sun_path, proc->unixsocket->ptr);
+		if (proc->unixsocket->used > sizeof(fcgi_addr_un.sun_path)) {
+			log_error_write(srv, __FILE__, __LINE__, "sB",
+					"ERROR: Unix Domain socket filename too long:",
+					proc->unixsocket);
+			return -1;
+		}
+		memcpy(fcgi_addr_un.sun_path, proc->unixsocket->ptr, proc->unixsocket->used);
+
 #ifdef SUN_LEN
 		servlen = SUN_LEN(&fcgi_addr_un);
 #else
@@ -1915,10 +1937,6 @@
 	s = inet_ntop_cache_get_ip(srv, &(con->dst_addr));
 	FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("REMOTE_ADDR"), s, strlen(s)),con)
 
-	if (!buffer_is_empty(con->authed_user)) {
-		FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("REMOTE_USER"), CONST_BUF_LEN(con->authed_user)),con)
-	}
-
 	if (con->request.content_length > 0 && host->mode != FCGI_AUTHORIZER) {
 		/* CGI-SPEC 6.1.2 and FastCGI spec 6.3 */
 
@@ -2031,7 +2049,7 @@
 	s = get_http_version_name(con->request.http_version);
 	FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("SERVER_PROTOCOL"), s, strlen(s)),con)
 
-    if (srv_sock->is_ssl || srv_sock->is_proxy_ssl) {
+	if (buffer_is_equal_caseless_string(con->uri.scheme, CONST_STR_LEN("https"))) {
 		FCGI_ENV_ADD_CHECK(fcgi_env_add(p->fcgi_env, CONST_STR_LEN("HTTPS"), CONST_STR_LEN("on")),con)
 	}
 
@@ -2089,7 +2107,7 @@
 							req_c->file.name);
 					}
 
-					assert(weHave != 0);
+					force_assert(weHave != 0);
 
 					chunkqueue_append_file(hctx->wb, req_c->file.name, req_c->offset, weHave);
 
@@ -2119,8 +2137,8 @@
 						}
 						c = hctx->wb->last;
 
-						assert(c->type == FILE_CHUNK);
-						assert(req_c->file.is_temp == 1);
+						force_assert(c->type == FILE_CHUNK);
+						force_assert(req_c->file.is_temp == 1);
 
 						c->file.is_temp = 1;
 						req_c->file.is_temp = 0;
@@ -2423,11 +2441,12 @@
 	if ((packet->b->used == 0) ||
 	    (packet->b->used - 1 < sizeof(FCGI_Header))) {
 		/* no header */
-		buffer_free(packet->b);
-
 		if (hctx->plugin_data->conf.debug) {
 			log_error_write(srv, __FILE__, __LINE__, "sdsds", "FastCGI: header too small:", packet->b->used, "bytes <", sizeof(FCGI_Header), "bytes, waiting for more data");
 		}
+
+		buffer_free(packet->b);
+
 		return -1;
 	}
 
@@ -2535,7 +2554,7 @@
 		}
 
 		/* this should be catched by the b > 0 above */
-		assert(r);
+		force_assert(r);
 
 		b->used = r + 1; /* one extra for the fake \0 */
 		b->ptr[b->used - 1] = '\0';
@@ -2673,8 +2692,8 @@
 		case FCGI_STDERR:
 			if (packet.len == 0) break;
 
-			log_error_write(srv, __FILE__, __LINE__, "sb",
-					"FastCGI-stderr:", packet.b);
+			log_error_write_multiline_buffer(srv, __FILE__, __LINE__, packet.b, "s",
+					"FastCGI-stderr:");
 
 			break;
 		case FCGI_END_REQUEST:
@@ -2725,7 +2744,7 @@
 		case PROC_STATE_KILLED:
 		case PROC_STATE_UNSET:
 			/* this should never happen as long as adaptive spawing is disabled */
-			assert(0);
+			force_assert(0);
 
 			break;
 		case PROC_STATE_RUNNING:
@@ -3017,7 +3036,7 @@
 
 			break;
 		}
-
+		/* fallthrough */
 	case FCGI_STATE_PREPARE_WRITE:
 		/* ok, we have the connection */
 
@@ -3177,8 +3196,6 @@
 	/* ok, create the request */
 	switch(fcgi_write_request(srv, hctx)) {
 	case HANDLER_ERROR:
-		host = hctx->host;
-
 		if (hctx->state == FCGI_STATE_INIT ||
 		    hctx->state == FCGI_STATE_CONNECT_DELAYED) {
 			fcgi_restart_dead_procs(srv, p, host);
diff -u lighttpd-1.4.32/src/mod_flv_streaming.c lighttpd-1.4.35/src/mod_flv_streaming.c
--- lighttpd-1.4.32/src/mod_flv_streaming.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/mod_flv_streaming.c	2014-03-06 08:08:00.000000000 -0600
@@ -84,7 +84,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
diff -u lighttpd-1.4.32/src/mod_indexfile.c lighttpd-1.4.35/src/mod_indexfile.c
--- lighttpd-1.4.32/src/mod_indexfile.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/mod_indexfile.c	2014-03-06 08:08:00.000000000 -0600
@@ -81,7 +81,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
diff -u lighttpd-1.4.32/src/mod_magnet.c lighttpd-1.4.35/src/mod_magnet.c
--- lighttpd-1.4.32/src/mod_magnet.c	2011-06-13 06:17:01.000000000 -0500
+++ lighttpd-1.4.35/src/mod_magnet.c	2014-03-06 08:08:00.000000000 -0600
@@ -103,7 +103,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -446,6 +446,7 @@
 		MAGNET_ENV_PHYICAL_PATH,
 		MAGNET_ENV_PHYICAL_REL_PATH,
 		MAGNET_ENV_PHYICAL_DOC_ROOT,
+		MAGNET_ENV_PHYICAL_BASEDIR,
 
 		MAGNET_ENV_URI_PATH,
 		MAGNET_ENV_URI_PATH_RAW,
@@ -466,6 +467,7 @@
 	{ "physical.path", MAGNET_ENV_PHYICAL_PATH },
 	{ "physical.rel-path", MAGNET_ENV_PHYICAL_REL_PATH },
 	{ "physical.doc-root", MAGNET_ENV_PHYICAL_DOC_ROOT },
+	{ "physical.basedir", MAGNET_ENV_PHYICAL_BASEDIR },
 
 	{ "uri.path", MAGNET_ENV_URI_PATH },
 	{ "uri.path-raw", MAGNET_ENV_URI_PATH_RAW },
@@ -497,6 +499,7 @@
 	case MAGNET_ENV_PHYICAL_PATH: dest = con->physical.path; break;
 	case MAGNET_ENV_PHYICAL_REL_PATH: dest = con->physical.rel_path; break;
 	case MAGNET_ENV_PHYICAL_DOC_ROOT: dest = con->physical.doc_root; break;
+	case MAGNET_ENV_PHYICAL_BASEDIR: dest = con->physical.basedir; break;
 
 	case MAGNET_ENV_URI_PATH: dest = con->uri.path; break;
 	case MAGNET_ENV_URI_PATH_RAW: dest = con->uri.path_raw; break;
@@ -693,7 +696,7 @@
 	/* lighty.header */
 
 	lua_getfield(L, -1, "lighty"); /* lighty.* from the env  */
-	assert(lua_istable(L, -1));
+	force_assert(lua_istable(L, -1));
 
 	lua_getfield(L, -1, "header"); /* lighty.header */
 	if (lua_istable(L, -1)) {
@@ -737,11 +740,11 @@
 	 * get the environment of the function
 	 */
 
-	assert(lua_isfunction(L, -1));
+	force_assert(lua_isfunction(L, -1));
 	lua_getfenv(L, -1); /* -1 is the function */
 
 	lua_getfield(L, -1, "lighty"); /* lighty.* from the env  */
-	assert(lua_istable(L, -1));
+	force_assert(lua_istable(L, -1));
 
 	lua_getfield(L, -1, "content"); /* lighty.content */
 	if (lua_istable(L, -1)) {
@@ -763,12 +766,17 @@
 				lua_getfield(L, -3, "offset");
 
 				if (lua_isstring(L, -3)) { /* filename has to be a string */
-					buffer *fn = buffer_init();
+					buffer *fn;
 					stat_cache_entry *sce;
+					const char *fn_str;
+					handler_t res;
 
-					buffer_copy_string(fn, lua_tostring(L, -3));
+					fn_str = lua_tostring(L, -3);
+					fn = buffer_init_string(fn_str);
 
-					if (HANDLER_GO_ON == stat_cache_get_entry(srv, con, fn, &sce)) {
+					res = stat_cache_get_entry(srv, con, fn, &sce);
+
+					if (HANDLER_GO_ON == res) {
 						off_t off = 0;
 						off_t len = 0;
 
@@ -783,11 +791,13 @@
 						}
 
 						if (off < 0) {
-							return luaL_error(L, "offset for '%s' is negative", fn->ptr);
+							buffer_free(fn);
+							return luaL_error(L, "offset for '%s' is negative", fn_str);
 						}
 
 						if (len < off) {
-							return luaL_error(L, "offset > length for '%s'", fn->ptr);
+							buffer_free(fn);
+							return luaL_error(L, "offset > length for '%s'", fn_str);
 						}
 
 						chunkqueue_append_file(con->write_queue, fn, off, len - off);
@@ -870,7 +880,7 @@
 
 		lua_pop(L, 1);
 
-		assert(lua_gettop(L) == 0); /* only the function should be on the stack */
+		force_assert(lua_gettop(L) == 0); /* only the function should be on the stack */
 
 		con->http_status = 500;
 		con->mode = DIRECT;
@@ -992,7 +1002,7 @@
 			lua_tostring(L, -1));
 		lua_pop(L, 1); /* remove the error-msg and the function copy from the stack */
 
-		assert(lua_gettop(L) == 1); /* only the function should be on the stack */
+		force_assert(lua_gettop(L) == 1); /* only the function should be on the stack */
 
 		con->http_status = 500;
 		con->mode = DIRECT;
@@ -1002,7 +1012,7 @@
 	lua_remove(L, errfunc);
 
 	/* we should have the function-copy and the return value on the stack */
-	assert(lua_gettop(L) == 2);
+	force_assert(lua_gettop(L) == 2);
 
 	if (lua_isnumber(L, -1)) {
 		/* if the ret-value is a number, take it */
@@ -1028,16 +1038,16 @@
 			con->mode = DIRECT;
 		}
 
-		assert(lua_gettop(L) == 1); /* only the function should be on the stack */
+		force_assert(lua_gettop(L) == 1); /* only the function should be on the stack */
 
 		/* we are finished */
 		return HANDLER_FINISHED;
 	} else if (MAGNET_RESTART_REQUEST == lua_return_value) {
-		assert(lua_gettop(L) == 1); /* only the function should be on the stack */
+		force_assert(lua_gettop(L) == 1); /* only the function should be on the stack */
 
 		return HANDLER_COMEBACK;
 	} else {
-		assert(lua_gettop(L) == 1); /* only the function should be on the stack */
+		force_assert(lua_gettop(L) == 1); /* only the function should be on the stack */
 
 		return HANDLER_GO_ON;
 	}
diff -u lighttpd-1.4.32/src/mod_magnet_cache.c lighttpd-1.4.35/src/mod_magnet_cache.c
--- lighttpd-1.4.32/src/mod_magnet_cache.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/mod_magnet_cache.c	2014-03-06 08:08:00.000000000 -0600
@@ -80,7 +80,7 @@
 				break;
 			}
 
-			assert(lua_isfunction(sc->L, -1));
+			force_assert(lua_isfunction(sc->L, -1));
 			lua_pushvalue(sc->L, -1); /* copy the function-reference */
 
 			return sc->L;
@@ -128,7 +128,7 @@
 	 * as pcall() will pop the script from the stack when done, we have to
 	 * duplicate it here
 	 */
-	assert(lua_isfunction(sc->L, -1));
+	force_assert(lua_isfunction(sc->L, -1));
 	lua_pushvalue(sc->L, -1); /* copy the function-reference */
 
 	return sc->L;
diff -u lighttpd-1.4.32/src/mod_mysql_vhost.c lighttpd-1.4.35/src/mod_mysql_vhost.c
--- lighttpd-1.4.32/src/mod_mysql_vhost.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/mod_mysql_vhost.c	2014-03-06 10:24:14.000000000 -0600
@@ -127,7 +127,7 @@
 	UNUSED(srv);
 
 #ifdef DEBUG
-        log_error_write(srv, __FILE__, __LINE__, "ss",
+	log_error_write(srv, __FILE__, __LINE__, "ss",
 		"mod_mysql_connection_data", c ? "old" : "NEW");
 #endif
 
@@ -173,24 +173,24 @@
 
 	char *qmark;
 	size_t i = 0;
+	buffer *sel;
 
 	config_values_t cv[] = {
-		{ "mysql-vhost.db",	NULL, T_CONFIG_STRING, 	T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.user",	NULL, T_CONFIG_STRING, 	T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.pass",	NULL, T_CONFIG_STRING, 	T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.sock",	NULL, T_CONFIG_STRING, 	T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.sql",	NULL, T_CONFIG_STRING, 	T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.hostname", NULL, T_CONFIG_STRING,T_CONFIG_SCOPE_SERVER },
-		{ "mysql-vhost.port",   NULL, T_CONFIG_SHORT,   T_CONFIG_SCOPE_SERVER },
-                { NULL,			NULL, T_CONFIG_UNSET,	T_CONFIG_SCOPE_UNSET }
-        };
+		{ "mysql-vhost.db",       NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_SERVER },
+		{ "mysql-vhost.user",     NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_SERVER },
+		{ "mysql-vhost.pass",     NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_SERVER },
+		{ "mysql-vhost.sock",     NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_SERVER },
+		{ "mysql-vhost.sql",      NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_SERVER },
+		{ "mysql-vhost.hostname", NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_SERVER },
+		{ "mysql-vhost.port",     NULL, T_CONFIG_SHORT,  T_CONFIG_SCOPE_SERVER },
+		{ NULL,                   NULL, T_CONFIG_UNSET,  T_CONFIG_SCOPE_UNSET }
+	};
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
+	sel = buffer_init();
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
-		buffer *sel;
-
 
 		s = calloc(1, sizeof(plugin_config));
 		s->mydb = buffer_init();
@@ -198,8 +198,7 @@
 		s->mypass = buffer_init();
 		s->mysock = buffer_init();
 		s->hostname = buffer_init();
-		s->port   = 0;               /* default port for mysql */
-		sel = buffer_init();
+		s->port = 0;               /* default port for mysql */
 		s->mysql = NULL;
 
 		s->mysql_pre = buffer_init();
@@ -209,13 +208,14 @@
 		cv[1].destination = s->myuser;
 		cv[2].destination = s->mypass;
 		cv[3].destination = s->mysock;
+		buffer_reset(sel);
 		cv[4].destination = sel;
 		cv[5].destination = s->hostname;
 		cv[6].destination = &(s->port);
 
 		p->config_storage[i] = s;
 
-        	if (config_insert_values_global(srv,
+		if (config_insert_values_global(srv,
 			((data_config *)srv->config_context->data[i])->value,
 			cv)) return HANDLER_ERROR;
 
@@ -249,6 +249,7 @@
 			if (NULL == (s->mysql = mysql_init(NULL))) {
 				log_error_write(srv, __FILE__, __LINE__, "s", "mysql_init() failed, exiting...");
 
+				buffer_free(sel);
 				return HANDLER_ERROR;
 			}
 
@@ -260,7 +261,7 @@
 #define FOO(x) (s->x->used ? s->x->ptr : NULL)
 
 #if MYSQL_VERSION_ID >= 40100
-                        /* CLIENT_MULTI_STATEMENTS first appeared in 4.1 */ 
+			/* CLIENT_MULTI_STATEMENTS first appeared in 4.1 */ 
 			if (!mysql_real_connect(s->mysql, FOO(hostname), FOO(myuser), FOO(mypass),
 						FOO(mydb), s->port, FOO(mysock), CLIENT_MULTI_STATEMENTS)) {
 #else
@@ -269,29 +270,16 @@
 #endif
 				log_error_write(srv, __FILE__, __LINE__, "s", mysql_error(s->mysql));
 
+				buffer_free(sel);
 				return HANDLER_ERROR;
 			}
 #undef FOO
 
-#if 0
-			/* set close_on_exec for mysql the hard way */
-			/* Note: this only works as it is done during startup, */
-			/* otherwise we cannot be sure that mysql is fd i-1 */
-			{ int fd;
-			if (-1 != (fd = open("/dev/null", 0))) {
-				close(fd);
-#ifdef FD_CLOEXEC
-				fcntl(fd-1, F_SETFD, FD_CLOEXEC);
-#endif
-			} }
-#else
-#ifdef FD_CLOEXEC
-			fcntl(s->mysql->net.fd, F_SETFD, FD_CLOEXEC);
-#endif
-#endif
+			fd_close_on_exec(s->mysql->net.fd);
 		}
 	}
 
+	buffer_free(sel);
 	return HANDLER_GO_ON;
 }
 
@@ -351,21 +339,32 @@
 	mod_mysql_vhost_patch_connection(srv, con, p);
 
 	if (!p->conf.mysql) return HANDLER_GO_ON;
+	if (0 == p->conf.mysql_pre->used) return HANDLER_GO_ON;
 
 	/* sets up connection data if not done yet */
 	c = mod_mysql_vhost_connection_data(srv, con, p_d);
 
 	/* check if cached this connection */
 	if (c->server_name->used && /* con->uri.authority->used && */
-            buffer_is_equal(c->server_name, con->uri.authority)) goto GO_ON;
+	    buffer_is_equal(c->server_name, con->uri.authority)) goto GO_ON;
 
 	/* build and run SQL query */
 	buffer_copy_string_buffer(p->tmp_buf, p->conf.mysql_pre);
 	if (p->conf.mysql_post->used) {
-		buffer_append_string_buffer(p->tmp_buf, con->uri.authority);
+		/* escape the uri.authority */
+		unsigned long to_len;
+
+		/* 'to' has to be 'from_len * 2 + 1' */
+		buffer_prepare_append(p->tmp_buf, (con->uri.authority->used - 1) * 2 + 1);
+
+		to_len = mysql_real_escape_string(p->conf.mysql,
+				p->tmp_buf->ptr + p->tmp_buf->used - 1,
+				con->uri.authority->ptr, con->uri.authority->used - 1);
+		p->tmp_buf->used += to_len;
+
 		buffer_append_string_buffer(p->tmp_buf, p->conf.mysql_post);
 	}
-   	if (mysql_query(p->conf.mysql, p->tmp_buf->ptr)) {
+	if (mysql_real_query(p->conf.mysql, p->tmp_buf->ptr, p->tmp_buf->used - 1)) {
 		log_error_write(srv, __FILE__, __LINE__, "s", mysql_error(p->conf.mysql));
 		goto ERR500;
 	}
@@ -389,7 +388,7 @@
 		log_error_write(srv, __FILE__, __LINE__, "sb", strerror(errno), p->tmp_buf);
 		goto ERR500;
 	}
-        if (!S_ISDIR(sce->st.st_mode)) {
+	if (!S_ISDIR(sce->st.st_mode)) {
 		log_error_write(srv, __FILE__, __LINE__, "sb", "Not a directory", p->tmp_buf);
 		goto ERR500;
 	}
@@ -416,7 +415,8 @@
 #endif
 
 	/* fix virtual server and docroot */
-GO_ON:	buffer_copy_string_buffer(con->server_name, c->server_name);
+GO_ON:
+	buffer_copy_string_buffer(con->server_name, c->server_name);
 	buffer_copy_string_buffer(con->physical.doc_root, c->document_root);
 
 #ifdef DEBUG
@@ -427,7 +427,8 @@
 #endif
 	return HANDLER_GO_ON;
 
-ERR500:	if (result) mysql_free_result(result);
+ERR500:
+	if (result) mysql_free_result(result);
 #if MYSQL_VERSION_ID >= 40100
 	while (mysql_next_result(p->conf.mysql) == 0);
 #endif
diff -u lighttpd-1.4.32/src/mod_proxy.c lighttpd-1.4.35/src/mod_proxy.c
--- lighttpd-1.4.32/src/mod_proxy.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.35/src/mod_proxy.c	2014-03-06 08:08:00.000000000 -0600
@@ -194,7 +194,7 @@
 		{ NULL,                        NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
 	};
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -298,6 +298,7 @@
 					pcv[1].destination = &(df->port);
 
 					if (0 != config_insert_values_internal(srv, da_host->value, pcv)) {
+						df->free((data_unset*) df);
 						return HANDLER_ERROR;
 					}
 
@@ -309,6 +310,7 @@
 								da_host->key,
 								"host");
 
+						df->free((data_unset*) df);
 						return HANDLER_ERROR;
 					}
 
@@ -463,7 +465,7 @@
 	    !buffer_is_empty(con->request.http_host)) {
 		proxy_set_header(con, "X-Host", con->request.http_host->ptr);
 	}
-	proxy_set_header(con, "X-Forwarded-Proto", con->conf.is_ssl ? "https" : "http");
+	proxy_set_header(con, "X-Forwarded-Proto", con->uri.scheme->ptr);
 
 	/* request header */
 	for (i = 0; i < con->request.headers->used; i++) {
@@ -684,7 +686,7 @@
 		}
 
 		/* this should be catched by the b > 0 above */
-		assert(r);
+		force_assert(r);
 
 		hctx->response->used += r;
 		hctx->response->ptr[hctx->response->used - 1] = '\0';
@@ -1256,7 +1258,7 @@
 		}
 
 		/* just to be sure */
-		assert(extension->value->used < INT_MAX);
+		force_assert(extension->value->used < INT_MAX);
 
 		host = (data_proxy *)extension->value->data[0];
 
diff -u lighttpd-1.4.32/src/mod_redirect.c lighttpd-1.4.35/src/mod_redirect.c
--- lighttpd-1.4.32/src/mod_redirect.c	2012-05-30 11:54:43.000000000 -0500
+++ lighttpd-1.4.35/src/mod_redirect.c	2014-03-06 08:08:00.000000000 -0600
@@ -65,7 +65,6 @@
 
 SETDEFAULTS_FUNC(mod_redirect_set_defaults) {
 	plugin_data *p = p_d;
-	data_unset *du;
 	size_t i = 0;
 
 	config_values_t cv[] = {
@@ -77,13 +76,14 @@
 	if (!p) return HANDLER_ERROR;
 
 	/* 0 */
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
 		size_t j;
 		array *ca;
-		data_array *da = (data_array *)du;
+		data_unset *du;
+		data_array *da;
 
 		s = calloc(1, sizeof(plugin_config));
 		s->redirect   = pcre_keyvalue_buffer_init();
diff -u lighttpd-1.4.32/src/mod_rewrite.c lighttpd-1.4.35/src/mod_rewrite.c
--- lighttpd-1.4.32/src/mod_rewrite.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.35/src/mod_rewrite.c	2014-03-06 08:08:00.000000000 -0600
@@ -242,7 +242,7 @@
 	if (!p) return HANDLER_ERROR;
 
 	/* 0 */
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 #else
 	UNUSED(p_d);
 #endif
@@ -296,8 +296,6 @@
 		data_config *dc = (data_config *)srv->config_context->data[i];
 		s = p->config_storage[i];
 
-		if (COMP_HTTP_URL == dc->comp) continue;
-
 		/* condition didn't match */
 		if (!config_check_cond(srv, con, dc)) continue;
 
diff -u lighttpd-1.4.32/src/mod_rrdtool.c lighttpd-1.4.35/src/mod_rrdtool.c
--- lighttpd-1.4.32/src/mod_rrdtool.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/mod_rrdtool.c	2014-03-06 08:08:00.000000000 -0600
@@ -7,6 +7,7 @@
 #include "plugin.h"
 #include <sys/types.h>
 
+#include <assert.h>
 #include <fcntl.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -169,10 +170,8 @@
 		p->read_fd = from_rrdtool_fds[0];
 		p->rrdtool_pid = pid;
 
-#ifdef FD_CLOEXEC
-		fcntl(p->write_fd, F_SETFD, FD_CLOEXEC);
-		fcntl(p->read_fd, F_SETFD, FD_CLOEXEC);
-#endif
+		fd_close_on_exec(p->write_fd);
+		fd_close_on_exec(p->read_fd);
 
 		break;
 	}
@@ -345,7 +344,8 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	force_assert(srv->config_context->used > 0);
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -435,7 +435,7 @@
 		}
 
 		buffer_prepare_copy(p->resp, 4096);
-		if (-1 == (r = safe_read(p->read_fd, p->resp->ptr, p->resp->size))) {
+		if (-1 == (r = safe_read(p->read_fd, p->resp->ptr, p->resp->size - 1))) {
 			p->rrdtool_running = 0;
 
 			log_error_write(srv, __FILE__, __LINE__, "ss",
@@ -444,7 +444,8 @@
 			return HANDLER_ERROR;
 		}
 
-		p->resp->used = r;
+		p->resp->used = r + 1;
+		p->resp->ptr[r] = '\0';
 
 		if (p->resp->ptr[0] != 'O' ||
 		    p->resp->ptr[1] != 'K') {
diff -u lighttpd-1.4.32/src/mod_scgi.c lighttpd-1.4.35/src/mod_scgi.c
--- lighttpd-1.4.32/src/mod_scgi.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.35/src/mod_scgi.c	2014-03-06 08:08:00.000000000 -0600
@@ -351,7 +351,7 @@
 	handler_ctx * hctx;
 
 	hctx = calloc(1, sizeof(*hctx));
-	assert(hctx);
+	force_assert(hctx);
 
 	hctx->fde_ndx = -1;
 
@@ -495,7 +495,7 @@
 	if (i == ext->used) {
 		/* filextension is new */
 		fe = calloc(1, sizeof(*fe));
-		assert(fe);
+		force_assert(fe);
 		fe->key = buffer_init();
 		buffer_copy_string_buffer(fe->key, key);
 
@@ -504,11 +504,11 @@
 		if (ext->size == 0) {
 			ext->size = 8;
 			ext->exts = malloc(ext->size * sizeof(*(ext->exts)));
-			assert(ext->exts);
+			force_assert(ext->exts);
 		} else if (ext->used == ext->size) {
 			ext->size += 8;
 			ext->exts = realloc(ext->exts, ext->size * sizeof(*(ext->exts)));
-			assert(ext->exts);
+			force_assert(ext->exts);
 		}
 		ext->exts[ext->used++] = fe;
 	} else {
@@ -518,11 +518,11 @@
 	if (fe->size == 0) {
 		fe->size = 4;
 		fe->hosts = malloc(fe->size * sizeof(*(fe->hosts)));
-		assert(fe->hosts);
+		force_assert(fe->hosts);
 	} else if (fe->size == fe->used) {
 		fe->size += 4;
 		fe->hosts = realloc(fe->hosts, fe->size * sizeof(*(fe->hosts)));
-		assert(fe->hosts);
+		force_assert(fe->hosts);
 	}
 
 	fe->hosts[fe->used++] = fh;
@@ -670,7 +670,13 @@
 
 #ifdef HAVE_SYS_UN_H
 		scgi_addr_un.sun_family = AF_UNIX;
-		strcpy(scgi_addr_un.sun_path, proc->socket->ptr);
+		if (proc->socket->used > sizeof(scgi_addr_un.sun_path)) {
+			log_error_write(srv, __FILE__, __LINE__, "sB",
+					"ERROR: Unix Domain socket filename too long:",
+					proc->socket);
+			return -1;
+		}
+		memcpy(scgi_addr_un.sun_path, proc->socket->ptr, proc->socket->used);
 
 #ifdef SUN_LEN
 		servlen = SUN_LEN(&scgi_addr_un);
@@ -752,6 +758,7 @@
 		if (setsockopt(scgi_fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val)) < 0) {
 			log_error_write(srv, __FILE__, __LINE__, "ss",
 					"socketsockopt failed:", strerror(errno));
+			close(scgi_fd);
 			return -1;
 		}
 
@@ -762,12 +769,14 @@
 				proc->socket,
 				proc->port,
 				strerror(errno));
+			close(scgi_fd);
 			return -1;
 		}
 
 		if (-1 == listen(scgi_fd, 1024)) {
 			log_error_write(srv, __FILE__, __LINE__, "ss",
 				"listen failed:", strerror(errno));
+			close(scgi_fd);
 			return -1;
 		}
 
@@ -918,6 +927,7 @@
 	plugin_data *p = p_d;
 	data_unset *du;
 	size_t i = 0;
+	scgi_extension_host *df = NULL;
 
 	config_values_t cv[] = {
 		{ "scgi.server",              NULL, T_CONFIG_LOCAL, T_CONFIG_SCOPE_CONNECTION },       /* 0 */
@@ -925,7 +935,7 @@
 		{ NULL,                          NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
 	};
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -942,7 +952,7 @@
 		ca = ((data_config *)srv->config_context->data[i])->value;
 
 		if (0 != config_insert_values_global(srv, ca, cv)) {
-			return HANDLER_ERROR;
+			goto error;
 		}
 
 		/*
@@ -957,7 +967,7 @@
 				log_error_write(srv, __FILE__, __LINE__, "sss",
 						"unexpected type for key: ", "scgi.server", "array of strings");
 
-				return HANDLER_ERROR;
+				goto error;
 			}
 
 
@@ -975,7 +985,7 @@
 							"unexpected type for key: ", "scgi.server",
 							"[", da->value->data[j]->key, "](string)");
 
-					return HANDLER_ERROR;
+					goto error;
 				}
 
 				/*
@@ -993,8 +1003,6 @@
 				for (n = 0; n < da_ext->value->used; n++) {
 					data_array *da_host = (data_array *)da_ext->value->data[n];
 
-					scgi_extension_host *df;
-
 					config_values_t fcv[] = {
 						{ "host",              NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },       /* 0 */
 						{ "docroot",           NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },       /* 1 */
@@ -1023,7 +1031,7 @@
 								"scgi.server",
 								"[", da_host->key, "](string)");
 
-						return HANDLER_ERROR;
+						goto error;
 					}
 
 					df = scgi_host_init();
@@ -1055,7 +1063,7 @@
 
 
 					if (0 != config_insert_values_internal(srv, da_host->value, fcv)) {
-						return HANDLER_ERROR;
+						goto error;
 					}
 
 					if ((!buffer_is_empty(df->host) || df->port) &&
@@ -1063,7 +1071,7 @@
 						log_error_write(srv, __FILE__, __LINE__, "s",
 								"either host+port or socket");
 
-						return HANDLER_ERROR;
+						goto error;
 					}
 
 					if (!buffer_is_empty(df->unixsocket)) {
@@ -1073,7 +1081,7 @@
 						if (df->unixsocket->used > sizeof(un.sun_path) - 2) {
 							log_error_write(srv, __FILE__, __LINE__, "s",
 									"path of the unixdomain socket is too large");
-							return HANDLER_ERROR;
+							goto error;
 						}
 					} else {
 						/* tcp/ip */
@@ -1087,7 +1095,7 @@
 									da_host->key,
 									"host");
 
-							return HANDLER_ERROR;
+							goto error;
 						} else if (df->port == 0) {
 							log_error_write(srv, __FILE__, __LINE__, "sbbbs",
 									"missing key (short):",
@@ -1095,7 +1103,7 @@
 									da_ext->key,
 									da_host->key,
 									"port");
-							return HANDLER_ERROR;
+							goto error;
 						}
 					}
 
@@ -1145,7 +1153,8 @@
 							if (scgi_spawn_connection(srv, p, df, proc)) {
 								log_error_write(srv, __FILE__, __LINE__, "s",
 										"[ERROR]: spawning fcgi failed.");
-								return HANDLER_ERROR;
+								scgi_process_free(proc);
+								goto error;
 							}
 
 							proc->next = df->first;
@@ -1176,12 +1185,17 @@
 
 					/* if extension already exists, take it */
 					scgi_extension_insert(s->exts, da_ext->key, df);
+					df = NULL;
 				}
 			}
 		}
 	}
 
 	return HANDLER_GO_ON;
+
+error:
+	if (NULL != df) scgi_host_free(df);
+	return HANDLER_ERROR;
 }
 
 static int scgi_set_state(server *srv, handler_ctx *hctx, scgi_connection_state_t state) {
@@ -1332,7 +1346,14 @@
 #ifdef HAVE_SYS_UN_H
 		/* use the unix domain socket */
 		scgi_addr_un.sun_family = AF_UNIX;
-		strcpy(scgi_addr_un.sun_path, proc->socket->ptr);
+		if (proc->socket->used > sizeof(scgi_addr_un.sun_path)) {
+			log_error_write(srv, __FILE__, __LINE__, "sB",
+					"ERROR: Unix Domain socket filename too long:",
+					proc->socket);
+			return -1;
+		}
+		memcpy(scgi_addr_un.sun_path, proc->socket->ptr, proc->socket->used);
+
 #ifdef SUN_LEN
 		servlen = SUN_LEN(&scgi_addr_un);
 #else
@@ -1542,12 +1563,6 @@
 	s = inet_ntop_cache_get_ip(srv, &(con->dst_addr));
 	scgi_env_add(p->scgi_env, CONST_STR_LEN("REMOTE_ADDR"), s, strlen(s));
 
-	if (!buffer_is_empty(con->authed_user)) {
-		scgi_env_add(p->scgi_env, CONST_STR_LEN("REMOTE_USER"),
-			     CONST_BUF_LEN(con->authed_user));
-	}
-
-
 	/*
 	 * SCRIPT_NAME, PATH_INFO and PATH_TRANSLATED according to
 	 * http://cgi-spec.golux.com/draft-coar-cgi-v11-03-clean.html
@@ -1614,7 +1629,7 @@
 	scgi_env_add(p->scgi_env, CONST_STR_LEN("SERVER_PROTOCOL"), s, strlen(s));
 
 #ifdef USE_OPENSSL
-	if (srv_sock->is_ssl) {
+	if (buffer_is_equal_caseless_string(con->uri.scheme, CONST_STR_LEN("https"))) {
 		scgi_env_add(p->scgi_env, CONST_STR_LEN("HTTPS"), CONST_STR_LEN("on"));
 	}
 #endif
@@ -2813,7 +2828,7 @@
 
 			if (con->conf.log_request_handling) {
 				log_error_write(srv, __FILE__, __LINE__, "s",
-				"handling it in mod_fastcgi");
+				"handling it in mod_scgi");
 			}
 
 			/* the prefix is the SCRIPT_NAME,
@@ -2871,7 +2886,7 @@
 		con->mode = p->id;
 
 		if (con->conf.log_request_handling) {
-			log_error_write(srv, __FILE__, __LINE__, "s", "handling it in mod_fastcgi");
+			log_error_write(srv, __FILE__, __LINE__, "s", "handling it in mod_scgi");
 		}
 	}
 
@@ -3003,6 +3018,7 @@
 					if (scgi_spawn_connection(srv, p, host, fp)) {
 						log_error_write(srv, __FILE__, __LINE__, "s",
 								"ERROR: spawning fcgi failed.");
+						scgi_process_free(fp);
 						return HANDLER_ERROR;
 					}
 
diff -u lighttpd-1.4.32/src/mod_secure_download.c lighttpd-1.4.35/src/mod_secure_download.c
--- lighttpd-1.4.32/src/mod_secure_download.c	2011-07-30 04:13:39.000000000 -0500
+++ lighttpd-1.4.35/src/mod_secure_download.c	2014-03-06 08:08:00.000000000 -0600
@@ -97,7 +97,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -255,6 +255,7 @@
 	buffer_copy_string_buffer(p->md5, p->conf.secret);
 	buffer_append_string(p->md5, rel_uri);
 	buffer_append_string_len(p->md5, ts_str, 8);
+	force_assert(p->md5->used > 0);
 
 	li_MD5_Init(&Md5Ctx);
 	li_MD5_Update(&Md5Ctx, (unsigned char *)p->md5->ptr, p->md5->used - 1);
@@ -276,6 +277,7 @@
 	 */
 
 	buffer_copy_string_buffer(con->physical.doc_root, p->conf.doc_root);
+	buffer_copy_string_buffer(con->physical.basedir, p->conf.doc_root);
 	buffer_copy_string(con->physical.rel_path, rel_uri);
 	buffer_copy_string_buffer(con->physical.path, con->physical.doc_root);
 	buffer_append_string_buffer(con->physical.path, con->physical.rel_path);
diff -u lighttpd-1.4.32/src/mod_setenv.c lighttpd-1.4.35/src/mod_setenv.c
--- lighttpd-1.4.32/src/mod_setenv.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.35/src/mod_setenv.c	2014-03-06 08:08:00.000000000 -0600
@@ -96,7 +96,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
diff -u lighttpd-1.4.32/src/mod_simple_vhost.c lighttpd-1.4.35/src/mod_simple_vhost.c
--- lighttpd-1.4.32/src/mod_simple_vhost.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/mod_simple_vhost.c	2014-03-06 08:08:00.000000000 -0600
@@ -5,6 +5,7 @@
 
 #include "plugin.h"
 
+#include <assert.h>
 #include <ctype.h>
 #include <stdlib.h>
 #include <string.h>
@@ -88,7 +89,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -123,36 +124,31 @@
 
 static int build_doc_root(server *srv, connection *con, plugin_data *p, buffer *out, buffer *host) {
 	stat_cache_entry *sce = NULL;
+	force_assert(p->conf.server_root->used > 1);
 
 	buffer_prepare_copy(out, 128);
+	buffer_copy_string_buffer(out, p->conf.server_root);
 
-	if (p->conf.server_root->used) {
-		buffer_copy_string_buffer(out, p->conf.server_root);
+	if (host->used) {
+		/* a hostname has to start with a alpha-numerical character
+		 * and must not contain a slash "/"
+		 */
+		char *dp;
 
-		if (host->used) {
-			/* a hostname has to start with a alpha-numerical character
-			 * and must not contain a slash "/"
-			 */
-			char *dp;
-
-			BUFFER_APPEND_SLASH(out);
-
-			if (NULL == (dp = strchr(host->ptr, ':'))) {
-				buffer_append_string_buffer(out, host);
-			} else {
-				buffer_append_string_len(out, host->ptr, dp - host->ptr);
-			}
-		}
 		BUFFER_APPEND_SLASH(out);
 
-		if (p->conf.document_root->used > 2 && p->conf.document_root->ptr[0] == '/') {
-			buffer_append_string_len(out, p->conf.document_root->ptr + 1, p->conf.document_root->used - 2);
+		if (NULL == (dp = strchr(host->ptr, ':'))) {
+			buffer_append_string_buffer(out, host);
 		} else {
-			buffer_append_string_buffer(out, p->conf.document_root);
-			BUFFER_APPEND_SLASH(out);
+			buffer_append_string_len(out, host->ptr, dp - host->ptr);
 		}
+	}
+	BUFFER_APPEND_SLASH(out);
+
+	if (p->conf.document_root->used > 2 && p->conf.document_root->ptr[0] == '/') {
+		buffer_append_string_len(out, p->conf.document_root->ptr + 1, p->conf.document_root->used - 2);
 	} else {
-		buffer_copy_string_buffer(out, con->conf.document_root);
+		buffer_append_string_buffer(out, p->conf.document_root);
 		BUFFER_APPEND_SLASH(out);
 	}
 
@@ -228,38 +224,41 @@
 
 	mod_simple_vhost_patch_connection(srv, con, p);
 
+	/* build_doc_root() requires a server_root; skip module if simple-vhost.server-root is not set
+	 * or set to an empty string (especially don't cache any results!)
+	 */
+	if (p->conf.server_root->used < 2) return HANDLER_GO_ON;
+
 	if (p->conf.docroot_cache_key->used &&
 	    con->uri.authority->used &&
 	    buffer_is_equal(p->conf.docroot_cache_key, con->uri.authority)) {
 		/* cache hit */
-		buffer_copy_string_buffer(con->physical.doc_root, p->conf.docroot_cache_value);
 		buffer_copy_string_buffer(con->server_name,       p->conf.docroot_cache_servername);
+		buffer_copy_string_buffer(con->physical.doc_root, p->conf.docroot_cache_value);
 	} else {
 		/* build document-root */
 		if ((con->uri.authority->used == 0) ||
 		    build_doc_root(srv, con, p, p->doc_root, con->uri.authority)) {
 			/* not found, fallback the default-host */
-			if (build_doc_root(srv, con, p,
+			if (0 == build_doc_root(srv, con, p,
 					   p->doc_root,
 					   p->conf.default_host)) {
-				return HANDLER_GO_ON;
-			} else {
+				/* default host worked */
 				buffer_copy_string_buffer(con->server_name, p->conf.default_host);
 				buffer_copy_string_buffer(con->physical.doc_root, p->doc_root);
-
 				/* do not cache default host */
-				return HANDLER_GO_ON;
 			}
-		} else {
-			buffer_copy_string_buffer(con->server_name, con->uri.authority);
+			return HANDLER_GO_ON;
 		}
 
+		/* found host */
+		buffer_copy_string_buffer(con->server_name, con->uri.authority);
+		buffer_copy_string_buffer(con->physical.doc_root, p->doc_root);
+
 		/* copy to cache */
 		buffer_copy_string_buffer(p->conf.docroot_cache_key,        con->uri.authority);
 		buffer_copy_string_buffer(p->conf.docroot_cache_value,      p->doc_root);
 		buffer_copy_string_buffer(p->conf.docroot_cache_servername, con->server_name);
-
-		buffer_copy_string_buffer(con->physical.doc_root, p->doc_root);
 	}
 
 	return HANDLER_GO_ON;
diff -u lighttpd-1.4.32/src/mod_skeleton.c lighttpd-1.4.35/src/mod_skeleton.c
--- lighttpd-1.4.32/src/mod_skeleton.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/mod_skeleton.c	2013-11-13 11:30:52.000000000 -0600
@@ -108,7 +108,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
diff -u lighttpd-1.4.32/src/mod_ssi.c lighttpd-1.4.35/src/mod_ssi.c
--- lighttpd-1.4.32/src/mod_ssi.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/mod_ssi.c	2014-03-06 08:08:00.000000000 -0600
@@ -108,7 +108,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -276,11 +276,6 @@
 	ssi_env_add(p->ssi_cgi_env, CONST_STRING("REMOTE_ADDR"),
 		    inet_ntop_cache_get_ip(srv, &(con->dst_addr)));
 
-	if (con->authed_user->used) {
-		ssi_env_add(p->ssi_cgi_env, CONST_STRING("REMOTE_USER"),
-			     con->authed_user->ptr);
-	}
-
 	if (con->request.content_length > 0) {
 		/* CGI-SPEC 6.1.2 and FastCGI spec 6.3 */
 
@@ -324,8 +319,7 @@
 	return 0;
 }
 
-static int process_ssi_stmt(server *srv, connection *con, plugin_data *p,
-			    const char **l, size_t n) {
+static int process_ssi_stmt(server *srv, connection *con, plugin_data *p, const char **l, size_t n, stat_cache_entry *sce) {
 	size_t i, ssicmd = 0;
 	char buf[255];
 	buffer *b = NULL;
@@ -365,7 +359,6 @@
 		int var = 0;
 		/* int enc = 0; */
 		const char *var_val = NULL;
-		stat_cache_entry *sce = NULL;
 
 		struct {
 			const char *var;
@@ -434,8 +427,6 @@
 			break;
 		}
 
-		stat_cache_get_entry(srv, con, con->physical.path, &sce);
-
 		switch(var) {
 		case SSI_ECHO_USER_NAME: {
 			struct passwd *pw;
@@ -963,6 +954,9 @@
 	int ovec[N * 3];
 #endif
 
+	stat_cache_entry *sce = NULL;
+
+
 	/* get a stream to the file */
 
 	array_reset(p->ssi_vars);
@@ -975,6 +969,11 @@
 	/* Reset the modified time of included files */
 	include_file_last_mtime = 0;
 
+	if (HANDLER_ERROR == stat_cache_get_entry(srv, con, con->physical.path, &sce)) {
+		log_error_write(srv, __FILE__, __LINE__,  "SB", "stat_cache_get_entry failed: ", con->physical.path);
+		return -1;
+	}
+
 	if (-1 == stream_open(&s, con->physical.path)) {
 		log_error_write(srv, __FILE__, __LINE__, "sb",
 				"stream-open: ", con->physical.path);
@@ -1048,7 +1047,7 @@
 		if (!p->if_is_false) chunkqueue_append_file(con->write_queue, con->physical.path, i, ovec[0] - i);
 
 		pcre_get_substring_list(s.start, ovec, n, &l);
-		process_ssi_stmt(srv, con, p, l, n);
+		process_ssi_stmt(srv, con, p, l, n, sce);
 		pcre_free_substring_list(l);
 	}
 
@@ -1079,14 +1078,10 @@
 	}
 
 	{
-  	/* Generate "ETag" & "Last-Modified" headers */
-
-		stat_cache_entry *sce = NULL;
+		/* Generate "ETag" & "Last-Modified" headers */
 		time_t lm_time = 0;
 		buffer *mtime = NULL;
 
-		stat_cache_get_entry(srv, con, con->physical.path, &sce);
-
 		etag_mutate(con->physical.etag, sce->etag);
 		response_header_overwrite(srv, con, CONST_STR_LEN("ETag"), CONST_BUF_LEN(con->physical.etag));
 
diff -u lighttpd-1.4.32/src/mod_ssi_expr.h lighttpd-1.4.35/src/mod_ssi_expr.h
--- lighttpd-1.4.32/src/mod_ssi_expr.h	2011-06-13 06:17:01.000000000 -0500
+++ lighttpd-1.4.35/src/mod_ssi_expr.h	2013-11-13 11:30:52.000000000 -0600
@@ -25,7 +25,7 @@
 void ssiexprparser(void *yyp, int yymajor, buffer *yyminor, ssi_ctx_t *ctx);
 
 int ssi_val_tobool(ssi_val_t *B);
-ssi_val_t *ssi_val_init();
+ssi_val_t *ssi_val_init(void);
 void ssi_val_free(ssi_val_t *s);
 
 #endif
diff -u lighttpd-1.4.32/src/mod_staticfile.c lighttpd-1.4.35/src/mod_staticfile.c
--- lighttpd-1.4.32/src/mod_staticfile.c	2012-11-17 11:32:01.000000000 -0600
+++ lighttpd-1.4.35/src/mod_staticfile.c	2014-03-06 08:08:00.000000000 -0600
@@ -91,7 +91,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
diff -u lighttpd-1.4.32/src/mod_status.c lighttpd-1.4.35/src/mod_status.c
--- lighttpd-1.4.32/src/mod_status.c	2011-10-05 08:32:23.000000000 -0500
+++ lighttpd-1.4.35/src/mod_status.c	2014-03-06 08:08:00.000000000 -0600
@@ -115,7 +115,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
diff -u lighttpd-1.4.32/src/mod_trigger_b4_dl.c lighttpd-1.4.35/src/mod_trigger_b4_dl.c
--- lighttpd-1.4.32/src/mod_trigger_b4_dl.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/mod_trigger_b4_dl.c	2014-03-06 08:08:00.000000000 -0600
@@ -143,7 +143,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -181,9 +181,7 @@
 						"gdbm-open failed");
 				return HANDLER_ERROR;
 			}
-#ifdef FD_CLOEXEC
-			fcntl(gdbm_fdesc(s->db), F_SETFD, FD_CLOEXEC);
-#endif
+			fd_close_on_exec(gdbm_fdesc(s->db));
 		}
 #endif
 #if defined(HAVE_PCRE_H)
@@ -437,7 +435,7 @@
 				return HANDLER_FINISHED;
 			}
 
-			last_hit = *(time_t *)(val.dptr);
+			memcpy(&last_hit, val.dptr, sizeof(time_t));
 
 			free(val.dptr);
 
@@ -555,7 +553,7 @@
 
 			val = gdbm_fetch(s->db, key);
 
-			last_hit = *(time_t *)(val.dptr);
+			memcpy(&last_hit, val.dptr, sizeof(time_t));
 
 			free(val.dptr);
 
diff -u lighttpd-1.4.32/src/mod_userdir.c lighttpd-1.4.35/src/mod_userdir.c
--- lighttpd-1.4.32/src/mod_userdir.c	2011-07-30 04:18:49.000000000 -0500
+++ lighttpd-1.4.35/src/mod_userdir.c	2014-03-06 08:08:00.000000000 -0600
@@ -22,6 +22,7 @@
 	buffer *path;
 	buffer *basepath;
 	unsigned short letterhomes;
+	unsigned short active;
 } plugin_config;
 
 typedef struct {
@@ -88,13 +89,14 @@
 		{ "userdir.exclude-user",       NULL, T_CONFIG_ARRAY,  T_CONFIG_SCOPE_CONNECTION },       /* 1 */
 		{ "userdir.include-user",       NULL, T_CONFIG_ARRAY,  T_CONFIG_SCOPE_CONNECTION },       /* 2 */
 		{ "userdir.basepath",           NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },       /* 3 */
-		{ "userdir.letterhomes",	NULL, T_CONFIG_BOOLEAN,T_CONFIG_SCOPE_CONNECTION },	  /* 4 */
+		{ "userdir.letterhomes",        NULL, T_CONFIG_BOOLEAN,T_CONFIG_SCOPE_CONNECTION },       /* 4 */
+		{ "userdir.active",             NULL, T_CONFIG_BOOLEAN,T_CONFIG_SCOPE_CONNECTION },       /* 5 */
 		{ NULL,                         NULL, T_CONFIG_UNSET,  T_CONFIG_SCOPE_UNSET }
 	};
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -105,12 +107,16 @@
 		s->path = buffer_init();
 		s->basepath = buffer_init();
 		s->letterhomes = 0;
+		/* enabled by default for backward compatibility; if userdir.path isn't set userdir is disabled too,
+		 * but you can't disable it by setting it to an empty string. */
+		s->active = 1;
 
 		cv[0].destination = s->path;
 		cv[1].destination = s->exclude_user;
 		cv[2].destination = s->include_user;
 		cv[3].destination = s->basepath;
 		cv[4].destination = &(s->letterhomes);
+		cv[5].destination = &(s->active);
 
 		p->config_storage[i] = s;
 
@@ -133,6 +139,7 @@
 	PATCH(include_user);
 	PATCH(basepath);
 	PATCH(letterhomes);
+	PATCH(active);
 
 	/* skip the first, the global context */
 	for (i = 1; i < srv->config_context->used; i++) {
@@ -156,6 +163,8 @@
 				PATCH(basepath);
 			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("userdir.letterhomes"))) {
 				PATCH(letterhomes);
+			} else if (buffer_is_equal_string(du->key, CONST_STR_LEN("userdir.active"))) {
+				PATCH(active);
 			}
 		}
 	}
@@ -179,7 +188,7 @@
 	/* enforce the userdir.path to be set in the config, ugly fix for #1587;
 	 * should be replaced with a clean .enabled option in 1.5
 	 */
-	if (p->conf.path->used == 0) return HANDLER_GO_ON;
+	if (!p->conf.active || p->conf.path->used == 0) return HANDLER_GO_ON;
 
 	/* /~user/foo.html -> /home/user/public_html/foo.html */
 
@@ -284,6 +293,8 @@
 		}
 	}
 
+	buffer_copy_string_buffer(con->physical.basedir, p->temp_path);
+
 	/* the physical rel_path is basically the same as uri.path;
 	 * but it is converted to lowercase in case of force_lowercase_filenames and some special handling
 	 * for trailing '.', ' ' and '/' on windows
diff -u lighttpd-1.4.32/src/mod_usertrack.c lighttpd-1.4.35/src/mod_usertrack.c
--- lighttpd-1.4.32/src/mod_usertrack.c	2011-07-30 04:00:53.000000000 -0500
+++ lighttpd-1.4.35/src/mod_usertrack.c	2014-03-06 08:08:00.000000000 -0600
@@ -78,7 +78,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
diff -u lighttpd-1.4.32/src/mod_webdav.c lighttpd-1.4.35/src/mod_webdav.c
--- lighttpd-1.4.32/src/mod_webdav.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.35/src/mod_webdav.c	2014-03-06 08:08:00.000000000 -0600
@@ -179,7 +179,7 @@
 
 	if (!p) return HANDLER_ERROR;
 
-	p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));
+	p->config_storage = calloc(1, srv->config_context->used * sizeof(plugin_config *));
 
 	for (i = 0; i < srv->config_context->used; i++) {
 		plugin_config *s;
@@ -1258,7 +1258,7 @@
 			if (1 == webdav_parse_chunkqueue(srv, con, p, con->request_content_queue, &xml)) {
 				xmlNode *rootnode = xmlDocGetRootElement(xml);
 
-				assert(rootnode);
+				force_assert(rootnode);
 
 				if (0 == xmlStrcmp(rootnode->name, BAD_CAST "propfind")) {
 					xmlNode *cmd;
@@ -1690,7 +1690,7 @@
 
 			/* if the file doesn't exist, create it */
 			if (-1 == (fd = open(con->physical.path->ptr, O_WRONLY|O_TRUNC, WEBDAV_FILE_MODE))) {
-				if (errno == ENOENT &&
+				if (errno != ENOENT ||
 				    -1 == (fd = open(con->physical.path->ptr, O_WRONLY|O_CREAT|O_TRUNC|O_EXCL, WEBDAV_FILE_MODE))) {
 					/* we can't open the file */
 					con->http_status = 403;
@@ -1717,7 +1717,7 @@
 					if (-1 == c->file.fd &&  /* open the file if not already open */
 					    -1 == (c->file.fd = open(c->file.name->ptr, O_RDONLY))) {
 						log_error_write(srv, __FILE__, __LINE__, "ss", "open failed: ", strerror(errno));
-
+						close(fd);
 						return HANDLER_ERROR;
 					}
 
@@ -1726,7 +1726,7 @@
 								strerror(errno), c->file.name,  c->file.fd);
 						close(c->file.fd);
 						c->file.fd = -1;
-
+						close(fd);
 						return HANDLER_ERROR;
 					}
 
@@ -2235,7 +2235,7 @@
 			if (1 == webdav_parse_chunkqueue(srv, con, p, con->request_content_queue, &xml)) {
 				xmlNode *rootnode = xmlDocGetRootElement(xml);
 
-				assert(rootnode);
+				force_assert(rootnode);
 
 				if (0 == xmlStrcmp(rootnode->name, BAD_CAST "lockinfo")) {
 					xmlNode *lockinfo;
diff -u lighttpd-1.4.32/src/network.c lighttpd-1.4.35/src/network.c
--- lighttpd-1.4.32/src/network.c	2012-11-08 05:52:51.000000000 -0600
+++ lighttpd-1.4.35/src/network.c	2014-03-06 08:08:00.000000000 -0600
@@ -25,7 +25,9 @@
 # include <openssl/ssl.h>
 # include <openssl/err.h>
 # include <openssl/rand.h>
-# include <openssl/dh.h>
+# ifndef OPENSSL_NO_DH
+#  include <openssl/dh.h>
+# endif
 # include <openssl/bn.h>
 
 # if OPENSSL_VERSION_NUMBER >= 0x0090800fL
@@ -42,8 +44,6 @@
 	if (0 != (where & SSL_CB_HANDSHAKE_START)) {
 		connection *con = SSL_get_app_data(ssl);
 		++con->renegotiations;
-	} else if (0 != (where & SSL_CB_HANDSHAKE_DONE)) {
-		ssl->s3->flags |= SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS;
 	}
 }
 #endif
@@ -112,20 +112,46 @@
 	config_patch_connection(srv, con, COMP_HTTP_SCHEME);
 	config_patch_connection(srv, con, COMP_HTTP_HOST);
 
-	if (NULL == con->conf.ssl_ctx) {
-		/* ssl_ctx <=> pemfile was set <=> ssl_ctx got patched: so this should never happen */
+	if (NULL == con->conf.ssl_pemfile_x509 || NULL == con->conf.ssl_pemfile_pkey) {
+		/* x509/pkey available <=> pemfile was set <=> pemfile got patched: so this should never happen, unless you nest $SERVER["socket"] */
 		log_error_write(srv, __FILE__, __LINE__, "ssb", "SSL:",
-			"null SSL_CTX for TLS server name", con->tlsext_server_name);
+			"no certificate/private key for TLS server name", con->tlsext_server_name);
 		return SSL_TLSEXT_ERR_ALERT_FATAL;
 	}
 
-	/* switch to new SSL_CTX in reaction to a client's server_name extension */
-	if (con->conf.ssl_ctx != SSL_set_SSL_CTX(ssl, con->conf.ssl_ctx)) {
-		log_error_write(srv, __FILE__, __LINE__, "ssb", "SSL:",
-			"failed to set SSL_CTX for TLS server name", con->tlsext_server_name);
+	/* first set certificate! setting private key checks whether certificate matches it */
+	if (!SSL_use_certificate(ssl, con->conf.ssl_pemfile_x509)) {
+		log_error_write(srv, __FILE__, __LINE__, "ssb:s", "SSL:",
+			"failed to set certificate for TLS server name", con->tlsext_server_name,
+			ERR_error_string(ERR_get_error(), NULL));
 		return SSL_TLSEXT_ERR_ALERT_FATAL;
 	}
 
+	if (!SSL_use_PrivateKey(ssl, con->conf.ssl_pemfile_pkey)) {
+		log_error_write(srv, __FILE__, __LINE__, "ssb:s", "SSL:",
+			"failed to set private key for TLS server name", con->tlsext_server_name,
+			ERR_error_string(ERR_get_error(), NULL));
+		return SSL_TLSEXT_ERR_ALERT_FATAL;
+	}
+
+	if (con->conf.ssl_verifyclient) {
+		if (NULL == con->conf.ssl_ca_file_cert_names) {
+			log_error_write(srv, __FILE__, __LINE__, "ssb:s", "SSL:",
+				"can't verify client without ssl.ca-file for TLS server name", con->tlsext_server_name,
+				ERR_error_string(ERR_get_error(), NULL));
+			return SSL_TLSEXT_ERR_ALERT_FATAL;
+		}
+
+		SSL_set_client_CA_list(ssl, SSL_dup_CA_list(con->conf.ssl_ca_file_cert_names));
+		/* forcing verification here is really not that useful - a client could just connect without SNI */
+		SSL_set_verify(
+			ssl,
+			SSL_VERIFY_PEER | (con->conf.ssl_verifyclient_enforce ? SSL_VERIFY_FAIL_IF_NO_PEER_CERT : 0),
+			NULL
+		);
+		SSL_set_verify_depth(ssl, con->conf.ssl_verifyclient_depth);
+	}
+
 	return SSL_TLSEXT_ERR_OK;
 }
 #endif
@@ -224,7 +250,6 @@
 			log_error_write(srv, __FILE__, __LINE__, "ss", "socket failed:", strerror(errno));
 			goto error_free_socket;
 		}
-		srv_socket->use_ipv6 = 1;
 	}
 #endif
 
@@ -236,10 +261,8 @@
 		}
 	}
 
-#ifdef FD_CLOEXEC
 	/* set FD_CLOEXEC now, fdevent_fcntl_set is called later; needed for pipe-logger forks */
-	fcntl(srv_socket->fd, F_SETFD, FD_CLOEXEC);
-#endif
+	fd_close_on_exec(srv_socket->fd);
 
 	/* */
 	srv->cur_fds = srv_socket->fd;
@@ -326,14 +349,21 @@
 
 		break;
 	case AF_UNIX:
+		{
+			size_t hostlen = strlen(host) + 1;
+			if (hostlen > sizeof(srv_socket->addr.un.sun_path)) {
+				log_error_write(srv, __FILE__, __LINE__, "sS", "unix socket filename too long:", host);
+				goto error_free_socket;
+			}
+			memcpy(srv_socket->addr.un.sun_path, host, hostlen);
+		}
 		srv_socket->addr.un.sun_family = AF_UNIX;
-		strcpy(srv_socket->addr.un.sun_path, host);
 
 #ifdef SUN_LEN
 		addr_len = SUN_LEN(&srv_socket->addr.un);
 #else
 		/* stevens says: */
-		addr_len = strlen(host) + 1 + sizeof(srv_socket->addr.un.sun_family);
+		addr_len = hostlen + sizeof(srv_socket->addr.un.sun_family);
 #endif
 
 		/* check if the socket exists and try to connect to it. */
@@ -389,7 +419,7 @@
 		goto error_free_socket;
 	}
 
-	if (s->is_ssl) {
+	if (s->ssl_enabled) {
 #ifdef USE_OPENSSL
 		if (NULL == (srv_socket->ssl_ctx = s->ssl_ctx)) {
 			log_error_write(srv, __FILE__, __LINE__, "s", "ssl.pemfile has to be set");
@@ -423,15 +453,15 @@
 #endif
 	}
 
-	srv_socket->is_ssl = s->is_ssl;
+	srv_socket->is_ssl = s->ssl_enabled;
 
 	if (srv->srv_sockets.size == 0) {
 		srv->srv_sockets.size = 4;
 		srv->srv_sockets.used = 0;
-		srv->srv_sockets.ptr = malloc(srv->srv_sockets.size * sizeof(server_socket));
+		srv->srv_sockets.ptr = malloc(srv->srv_sockets.size * sizeof(server_socket*));
 	} else if (srv->srv_sockets.used == srv->srv_sockets.size) {
 		srv->srv_sockets.size += 4;
-		srv->srv_sockets.ptr = realloc(srv->srv_sockets.ptr, srv->srv_sockets.size * sizeof(server_socket));
+		srv->srv_sockets.ptr = realloc(srv->srv_sockets.ptr, srv->srv_sockets.size * sizeof(server_socket*));
 	}
 
 	srv->srv_sockets.ptr[srv->srv_sockets.used++] = srv_socket;
@@ -492,9 +522,98 @@
 	NETWORK_BACKEND_SOLARIS_SENDFILEV
 } network_backend_t;
 
+#ifdef USE_OPENSSL
+static X509* x509_load_pem_file(server *srv, const char *file) {
+	BIO *in;
+	X509 *x = NULL;
+
+	in = BIO_new(BIO_s_file());
+	if (NULL == in) {
+		log_error_write(srv, __FILE__, __LINE__, "S", "SSL: BIO_new(BIO_s_file()) failed");
+		goto error;
+	}
+
+	if (BIO_read_filename(in,file) <= 0) {
+		log_error_write(srv, __FILE__, __LINE__, "SSS", "SSL: BIO_read_filename('", file,"') failed");
+		goto error;
+	}
+	x = PEM_read_bio_X509(in, NULL, NULL, NULL);
+
+	if (NULL == x) {
+		log_error_write(srv, __FILE__, __LINE__, "SSS", "SSL: couldn't read X509 certificate from '", file,"'");
+		goto error;
+	}
+
+	BIO_free(in);
+	return x;
+
+error:
+	if (NULL != in) BIO_free(in);
+	return NULL;
+}
+
+static EVP_PKEY* evp_pkey_load_pem_file(server *srv, const char *file) {
+	BIO *in;
+	EVP_PKEY *x = NULL;
+
+	in=BIO_new(BIO_s_file());
+	if (NULL == in) {
+		log_error_write(srv, __FILE__, __LINE__, "s", "SSL: BIO_new(BIO_s_file()) failed");
+		goto error;
+	}
+
+	if (BIO_read_filename(in,file) <= 0) {
+		log_error_write(srv, __FILE__, __LINE__, "SSS", "SSL: BIO_read_filename('", file,"') failed");
+		goto error;
+	}
+	x = PEM_read_bio_PrivateKey(in, NULL, NULL, NULL);
+
+	if (NULL == x) {
+		log_error_write(srv, __FILE__, __LINE__, "SSS", "SSL: couldn't read private key from '", file,"'");
+		goto error;
+	}
+
+	BIO_free(in);
+	return x;
+
+error:
+	if (NULL != in) BIO_free(in);
+	return NULL;
+}
+
+static int network_openssl_load_pemfile(server *srv, size_t ndx) {
+	specific_config *s = srv->config_storage[ndx];
+
+#ifdef OPENSSL_NO_TLSEXT
+	{
+		data_config *dc = (data_config *)srv->config_context->data[ndx];
+		if ((ndx > 0 && (COMP_SERVER_SOCKET != dc->comp || dc->cond != CONFIG_COND_EQ))
+			|| !s->ssl_enabled) {
+			log_error_write(srv, __FILE__, __LINE__, "ss", "SSL:",
+					"ssl.pemfile only works in SSL socket binding context as openssl version does not support TLS extensions");
+			return -1;
+		}
+	}
+#endif
+
+	if (NULL == (s->ssl_pemfile_x509 = x509_load_pem_file(srv, s->ssl_pemfile->ptr))) return -1;
+	if (NULL == (s->ssl_pemfile_pkey = evp_pkey_load_pem_file(srv, s->ssl_pemfile->ptr))) return -1;
+
+	if (!X509_check_private_key(s->ssl_pemfile_x509, s->ssl_pemfile_pkey)) {
+		log_error_write(srv, __FILE__, __LINE__, "sssb", "SSL:",
+				"Private key does not match the certificate public key, reason:",
+				ERR_error_string(ERR_get_error(), NULL),
+				s->ssl_pemfile);
+		return -1;
+	}
+
+	return 0;
+}
+#endif
+
 int network_init(server *srv) {
 	buffer *b;
-	size_t i;
+	size_t i, j;
 	network_backend_t backend;
 
 #if OPENSSL_VERSION_NUMBER >= 0x0090800fL
@@ -505,7 +624,9 @@
 #endif
 
 #ifdef USE_OPENSSL
+# ifndef OPENSSL_NO_DH
 	DH *dh;
+# endif
 	BIO *bio;
 
        /* 1024-bit MODP Group with 160-bit prime order subgroup (RFC5114)
@@ -579,18 +700,7 @@
 		long ssloptions =
 			SSL_OP_ALL | SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION | SSL_OP_NO_COMPRESSION;
 
-		if (buffer_is_empty(s->ssl_pemfile)) continue;
-
-#ifdef OPENSSL_NO_TLSEXT
-		{
-			data_config *dc = (data_config *)srv->config_context->data[i];
-			if (COMP_HTTP_HOST == dc->comp) {
-			    log_error_write(srv, __FILE__, __LINE__, "ss", "SSL:",
-					    "can't use ssl.pemfile with $HTTP[\"host\"], openssl version does not support TLS extensions");
-			    return -1;
-			}
-		}
-#endif
+		if (buffer_is_empty(s->ssl_pemfile) && buffer_is_empty(s->ssl_ca_file)) continue;
 
 		if (srv->ssl_is_init == 0) {
 			SSL_load_error_strings();
@@ -605,12 +715,53 @@
 			}
 		}
 
+		if (!buffer_is_empty(s->ssl_pemfile)) {
+#ifdef OPENSSL_NO_TLSEXT
+			data_config *dc = (data_config *)srv->config_context->data[i];
+			if (COMP_HTTP_HOST == dc->comp) {
+				log_error_write(srv, __FILE__, __LINE__, "ss", "SSL:",
+						"can't use ssl.pemfile with $HTTP[\"host\"], openssl version does not support TLS extensions");
+				return -1;
+			}
+#endif
+			if (network_openssl_load_pemfile(srv, i)) return -1;
+		}
+
+
+		if (!buffer_is_empty(s->ssl_ca_file)) {
+			s->ssl_ca_file_cert_names = SSL_load_client_CA_file(s->ssl_ca_file->ptr);
+			if (NULL == s->ssl_ca_file_cert_names) {
+				log_error_write(srv, __FILE__, __LINE__, "ssb", "SSL:",
+						ERR_error_string(ERR_get_error(), NULL), s->ssl_ca_file);
+			}
+		}
+
+		if (buffer_is_empty(s->ssl_pemfile) || !s->ssl_enabled) continue;
+
 		if (NULL == (s->ssl_ctx = SSL_CTX_new(SSLv23_server_method()))) {
 			log_error_write(srv, __FILE__, __LINE__, "ss", "SSL:",
 					ERR_error_string(ERR_get_error(), NULL));
 			return -1;
 		}
 
+		/* completely useless identifier; required for client cert verification to work with sessions */
+		if (0 == SSL_CTX_set_session_id_context(s->ssl_ctx, (const unsigned char*) CONST_STR_LEN("lighttpd"))) {
+			log_error_write(srv, __FILE__, __LINE__, "ss:s", "SSL:",
+				"failed to set session context",
+				ERR_error_string(ERR_get_error(), NULL));
+			return -1;
+		}
+
+		if (s->ssl_empty_fragments) {
+#ifdef SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
+			ssloptions &= ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;
+#else
+			ssloptions &= ~0x00000800L; /* hardcode constant */
+			log_error_write(srv, __FILE__, __LINE__, "ss", "WARNING: SSL:",
+					"'insert empty fragments' not supported by the openssl version used to compile lighttpd with");
+#endif
+		}
+
 		SSL_CTX_set_options(s->ssl_ctx, ssloptions);
 		SSL_CTX_set_info_callback(s->ssl_ctx, ssl_info_callback);
 
@@ -645,6 +796,7 @@
 			}
 		}
 
+#ifndef OPENSSL_NO_DH
 		/* Support for Diffie-Hellman key exchange */
 		if (!buffer_is_empty(s->ssl_dh_file)) {
 			/* DH parameters from file */
@@ -678,6 +830,11 @@
 		SSL_CTX_set_tmp_dh(s->ssl_ctx,dh);
 		SSL_CTX_set_options(s->ssl_ctx,SSL_OP_SINGLE_DH_USE);
 		DH_free(dh);
+#else
+		if (!buffer_is_empty(s->ssl_dh_file)) {
+			log_error_write(srv, __FILE__, __LINE__, "ss", "SSL: openssl compiled without DH support, can't load parameters from", s->ssl_dh_file->ptr);
+		}
+#endif
 
 #if OPENSSL_VERSION_NUMBER >= 0x0090800fL
 #ifndef OPENSSL_NO_ECDH
@@ -704,45 +861,42 @@
 #endif
 #endif
 
-		if (!buffer_is_empty(s->ssl_ca_file)) {
-			if (1 != SSL_CTX_load_verify_locations(s->ssl_ctx, s->ssl_ca_file->ptr, NULL)) {
-				log_error_write(srv, __FILE__, __LINE__, "ssb", "SSL:",
-						ERR_error_string(ERR_get_error(), NULL), s->ssl_ca_file);
-				return -1;
-			}
-			if (s->ssl_verifyclient) {
-				STACK_OF(X509_NAME) *certs = SSL_load_client_CA_file(s->ssl_ca_file->ptr);
-				if (!certs) {
+		/* load all ssl.ca-files specified in the config into each SSL_CTX to be prepared for SNI */
+		for (j = 0; j < srv->config_context->used; j++) {
+			specific_config *s1 = srv->config_storage[j];
+
+			if (!buffer_is_empty(s1->ssl_ca_file)) {
+				if (1 != SSL_CTX_load_verify_locations(s->ssl_ctx, s1->ssl_ca_file->ptr, NULL)) {
 					log_error_write(srv, __FILE__, __LINE__, "ssb", "SSL:",
-							ERR_error_string(ERR_get_error(), NULL), s->ssl_ca_file);
-				}
-				if (SSL_CTX_set_session_id_context(s->ssl_ctx, (void*) &srv, sizeof(srv)) != 1) {
-					log_error_write(srv, __FILE__, __LINE__, "ss", "SSL:",
-						ERR_error_string(ERR_get_error(), NULL));
+							ERR_error_string(ERR_get_error(), NULL), s1->ssl_ca_file);
 					return -1;
 				}
-				SSL_CTX_set_client_CA_list(s->ssl_ctx, certs);
-				SSL_CTX_set_verify(
-					s->ssl_ctx,
-					SSL_VERIFY_PEER | (s->ssl_verifyclient_enforce ? SSL_VERIFY_FAIL_IF_NO_PEER_CERT : 0),
-					NULL
+			}
+		}
+
+		if (s->ssl_verifyclient) {
+			if (NULL == s->ssl_ca_file_cert_names) {
+				log_error_write(srv, __FILE__, __LINE__, "s",
+					"SSL: You specified ssl.verifyclient.activate but no ca_file"
 				);
-				SSL_CTX_set_verify_depth(s->ssl_ctx, s->ssl_verifyclient_depth);
+				return -1;
 			}
-		} else if (s->ssl_verifyclient) {
-			log_error_write(
-				srv, __FILE__, __LINE__, "s",
-				"SSL: You specified ssl.verifyclient.activate but no ca_file"
+			SSL_CTX_set_client_CA_list(s->ssl_ctx, SSL_dup_CA_list(s->ssl_ca_file_cert_names));
+			SSL_CTX_set_verify(
+				s->ssl_ctx,
+				SSL_VERIFY_PEER | (s->ssl_verifyclient_enforce ? SSL_VERIFY_FAIL_IF_NO_PEER_CERT : 0),
+				NULL
 			);
+			SSL_CTX_set_verify_depth(s->ssl_ctx, s->ssl_verifyclient_depth);
 		}
 
-		if (SSL_CTX_use_certificate_file(s->ssl_ctx, s->ssl_pemfile->ptr, SSL_FILETYPE_PEM) < 0) {
+		if (SSL_CTX_use_certificate(s->ssl_ctx, s->ssl_pemfile_x509) < 0) {
 			log_error_write(srv, __FILE__, __LINE__, "ssb", "SSL:",
 					ERR_error_string(ERR_get_error(), NULL), s->ssl_pemfile);
 			return -1;
 		}
 
-		if (SSL_CTX_use_PrivateKey_file (s->ssl_ctx, s->ssl_pemfile->ptr, SSL_FILETYPE_PEM) < 0) {
+		if (SSL_CTX_use_PrivateKey(s->ssl_ctx, s->ssl_pemfile_pkey) < 0) {
 			log_error_write(srv, __FILE__, __LINE__, "ssb", "SSL:",
 					ERR_error_string(ERR_get_error(), NULL), s->ssl_pemfile);
 			return -1;
@@ -776,6 +930,7 @@
 	buffer_append_long(b, srv->srvconf.port);
 
 	if (0 != network_server_init(srv, b, srv->config_storage[0])) {
+		buffer_free(b);
 		return -1;
 	}
 	buffer_free(b);
@@ -839,7 +994,6 @@
 	for (i = 1; i < srv->config_context->used; i++) {
 		data_config *dc = (data_config *)srv->config_context->data[i];
 		specific_config *s = srv->config_storage[i];
-		size_t j;
 
 		/* not our stage */
 		if (COMP_SERVER_SOCKET != dc->comp) continue;
diff -u lighttpd-1.4.32/src/network_freebsd_sendfile.c lighttpd-1.4.35/src/network_freebsd_sendfile.c
--- lighttpd-1.4.32/src/network_freebsd_sendfile.c	2011-08-20 08:32:49.000000000 -0500
+++ lighttpd-1.4.35/src/network_freebsd_sendfile.c	2014-03-06 08:08:00.000000000 -0600
@@ -151,9 +151,7 @@
 					return -1;
 				}
 
-#ifdef FD_CLOEXEC
-				fcntl(c->file.fd, F_SETFD, FD_CLOEXEC);
-#endif
+				fd_close_on_exec(c->file.fd);
 			}
 
 			r = 0;
diff -u lighttpd-1.4.32/src/network_linux_sendfile.c lighttpd-1.4.35/src/network_linux_sendfile.c
--- lighttpd-1.4.32/src/network_linux_sendfile.c	2011-08-20 08:33:01.000000000 -0500
+++ lighttpd-1.4.35/src/network_linux_sendfile.c	2014-03-06 08:08:00.000000000 -0600
@@ -141,9 +141,7 @@
 
 					return -1;
 				}
-#ifdef FD_CLOEXEC
-				fcntl(c->file.fd, F_SETFD, FD_CLOEXEC);
-#endif
+				fd_close_on_exec(c->file.fd);
 #ifdef HAVE_POSIX_FADVISE
 				/* tell the kernel that we want to stream the file */
 				if (-1 == posix_fadvise(c->file.fd, 0, 0, POSIX_FADV_SEQUENTIAL)) {
diff -u lighttpd-1.4.32/src/network_openssl.c lighttpd-1.4.35/src/network_openssl.c
--- lighttpd-1.4.32/src/network_openssl.c	2011-12-05 11:03:27.000000000 -0600
+++ lighttpd-1.4.35/src/network_openssl.c	2014-03-06 08:08:00.000000000 -0600
@@ -90,7 +90,7 @@
 			r = SSL_write(ssl, offset, toSend);
 
 			if (con->renegotiations > 1 && con->conf.ssl_disable_client_renegotiation) {
-				log_error_write(srv, __FILE__, __LINE__, "s", "SSL: renegotiation initiated by client");
+				log_error_write(srv, __FILE__, __LINE__, "s", "SSL: renegotiation initiated by client, killing connection");
 				return -1;
 			}
 
@@ -170,7 +170,7 @@
 
 			if (NULL == local_send_buffer) {
 				local_send_buffer = malloc(LOCAL_SEND_BUFSIZE);
-				assert(local_send_buffer);
+				force_assert(local_send_buffer);
 			}
 
 			do {
@@ -187,10 +187,14 @@
 				}
 
 
-				lseek(ifd, offset, SEEK_SET);
-				if (-1 == (toSend = read(ifd, local_send_buffer, toSend))) {
+				if (-1 == lseek(ifd, offset, SEEK_SET)) {
+					log_error_write(srv, __FILE__, __LINE__, "ss", "lseek failed:", strerror(errno));
 					close(ifd);
+					return -1;
+				}
+				if (-1 == (toSend = read(ifd, local_send_buffer, toSend))) {
 					log_error_write(srv, __FILE__, __LINE__, "ss", "read failed:", strerror(errno));
+					close(ifd);
 					return -1;
 				}
 
@@ -202,7 +206,7 @@
 				r = SSL_write(ssl, s, toSend);
 
 				if (con->renegotiations > 1 && con->conf.ssl_disable_client_renegotiation) {
-					log_error_write(srv, __FILE__, __LINE__, "s", "SSL: renegotiation initiated by client");
+					log_error_write(srv, __FILE__, __LINE__, "s", "SSL: renegotiation initiated by client, killing connection");
 					return -1;
 				}
 
diff -u lighttpd-1.4.32/src/network_write.c lighttpd-1.4.35/src/network_write.c
--- lighttpd-1.4.32/src/network_write.c	2011-08-20 08:30:11.000000000 -0500
+++ lighttpd-1.4.35/src/network_write.c	2014-03-06 08:08:00.000000000 -0600
@@ -147,11 +147,14 @@
 #else /* USE_MMAP */
 			buffer_prepare_copy(srv->tmp_buf, toSend);
 
-			lseek(ifd, offset, SEEK_SET);
+			if (-1 == lseek(ifd, offset, SEEK_SET)) {
+				log_error_write(srv, __FILE__, __LINE__, "ss", "lseek: ", strerror(errno));
+				close(ifd);
+				return -1;
+			}
 			if (-1 == (toSend = read(ifd, srv->tmp_buf->ptr, toSend))) {
 				log_error_write(srv, __FILE__, __LINE__, "ss", "read: ", strerror(errno));
 				close(ifd);
-
 				return -1;
 			}
 			close(ifd);
diff -u lighttpd-1.4.32/src/network_writev.c lighttpd-1.4.35/src/network_writev.c
--- lighttpd-1.4.32/src/network_writev.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.35/src/network_writev.c	2014-03-06 08:08:00.000000000 -0600
@@ -30,6 +30,18 @@
 #define LOCAL_BUFFERING 1
 #endif
 
+#if defined(UIO_MAXIOV)
+# define MAX_CHUNKS UIO_MAXIOV
+#elif defined(IOV_MAX)
+/* new name for UIO_MAXIOV since IEEE Std 1003.1-2001 */
+# define MAX_CHUNKS IOV_MAX
+#elif defined(_XOPEN_IOV_MAX)
+/* minimum value for sysconf(_SC_IOV_MAX); posix requires this to be at least 16, which is good enough - no need to call sysconf() */
+# define MAX_CHUNKS _XOPEN_IOV_MAX
+#else
+# error neither UIO_MAXIOV nor IOV_MAX nor _XOPEN_IOV_MAX are defined
+#endif
+
 int network_write_chunkqueue_writev(server *srv, connection *con, int fd, chunkqueue *cq, off_t max_bytes) {
 	chunk *c;
 
@@ -46,30 +58,13 @@
 			struct iovec *chunks;
 			chunk *tc;
 			size_t num_bytes = 0;
-#if defined(_SC_IOV_MAX) /* IRIX, MacOS X, FreeBSD, Solaris, ... */
-			const size_t max_chunks = sysconf(_SC_IOV_MAX);
-#elif defined(IOV_MAX) /* Linux x86 (glibc-2.3.6-3) */
-			const size_t max_chunks = IOV_MAX;
-#elif defined(MAX_IOVEC) /* Linux ia64 (glibc-2.3.3-98.28) */
-			const size_t max_chunks = MAX_IOVEC;
-#elif defined(UIO_MAXIOV) /* Linux x86 (glibc-2.2.5-233) */
-			const size_t max_chunks = UIO_MAXIOV;
-#elif (defined(__FreeBSD__) && __FreeBSD_version < 500000) || defined(__DragonFly__) || defined(__APPLE__) 
-			/* - FreeBSD 4.x
-			 * - MacOS X 10.3.x
-			 *   (covered in -DKERNEL)
-			 *  */
-			const size_t max_chunks = 1024; /* UIO_MAXIOV value from sys/uio.h */
-#else
-#error "sysconf() doesnt return _SC_IOV_MAX ..., check the output of 'man writev' for the EINVAL error and send the output to jan@kneschke.de"
-#endif
 
 			/* build writev list
 			 *
-			 * 1. limit: num_chunks < max_chunks
+			 * 1. limit: num_chunks < MAX_CHUNKS
 			 * 2. limit: num_bytes < max_bytes
 			 */
-			for (num_chunks = 0, tc = c; tc && tc->type == MEM_CHUNK && num_chunks < max_chunks; num_chunks++, tc = tc->next);
+			for (num_chunks = 0, tc = c; tc && tc->type == MEM_CHUNK && num_chunks < MAX_CHUNKS; num_chunks++, tc = tc->next);
 
 			chunks = calloc(num_chunks, sizeof(*chunks));
 
@@ -235,14 +230,10 @@
 
 						return -1;
 					}
-#ifdef FD_CLOEXEC
-					fcntl(c->file.fd, F_SETFD, FD_CLOEXEC);
-#endif
+					fd_close_on_exec(c->file.fd);
 				}
 
 				if (MAP_FAILED == (c->file.mmap.start = mmap(NULL, to_mmap, PROT_READ, MAP_SHARED, c->file.fd, c->file.mmap.offset))) {
-					/* close it here, otherwise we'd have to set FD_CLOEXEC */
-
 					log_error_write(srv, __FILE__, __LINE__, "ssbd", "mmap failed:",
 							strerror(errno), c->file.name, c->file.fd);
 
@@ -278,7 +269,7 @@
 						c->file.mmap.length,
 						abs_offset,
 						c->file.mmap.offset);
-				assert(toSend < 0);
+				force_assert(toSend < 0);
 			}
 
 			if (toSend > max_bytes) toSend = max_bytes;
diff -u lighttpd-1.4.32/src/proc_open.c lighttpd-1.4.35/src/proc_open.c
--- lighttpd-1.4.32/src/proc_open.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.35/src/proc_open.c	2014-03-06 08:08:00.000000000 -0600
@@ -317,6 +317,7 @@
 		proc_read_fd_to_buffer(proc.err.fd, tmp);
 		if (tmp->used > 0 &&  write(2, (void*)tmp->ptr, tmp->used) < 0) {
 			perror("error writing pipe");
+			buffer_free(tmp);
 			return -1;
 		}
 		buffer_free(tmp);
diff -u lighttpd-1.4.32/src/request.c lighttpd-1.4.35/src/request.c
--- lighttpd-1.4.32/src/request.c	2012-11-20 04:09:44.000000000 -0600
+++ lighttpd-1.4.35/src/request.c	2014-03-07 04:01:31.000000000 -0600
@@ -43,7 +43,7 @@
 		char *c = host->ptr + 1;
 		int colon_cnt = 0;
 
-		/* check portnumber */
+		/* check the address inside [...] */
 		for (; *c && *c != ']'; c++) {
 			if (*c == ':') {
 				if (++colon_cnt > 7) {
@@ -67,6 +67,10 @@
 				}
 			}
 		}
+		else if ('\0' != *(c+1)) {
+			/* only a port is allowed to follow [...] */
+			return -1;
+		}
 		return 0;
 	}
 
@@ -366,7 +370,7 @@
 				*(proto - 1) = '\0';
 
 				/* we got the first one :) */
-				if (-1 == (r = get_http_method_key(method))) {
+				if (HTTP_METHOD_UNSET == (r = get_http_method_key(method))) {
 					con->http_status = 501;
 					con->response.keep_alive = 0;
 					con->keep_alive = 0;
@@ -584,7 +588,7 @@
 
 			/**
 			 * 1*<any CHAR except CTLs or separators>
-			 * CTLs == 0-31 + 127
+			 * CTLs == 0-31 + 127, CHAR = 7-bit ascii (0..127)
 			 *
 			 */
 			switch(*cur) {
@@ -619,8 +623,14 @@
 				con->keep_alive = 0;
 				con->response.keep_alive = 0;
 
-				log_error_write(srv, __FILE__, __LINE__, "sbsds",
+				if (srv->srvconf.log_request_header_on_error) {
+					log_error_write(srv, __FILE__, __LINE__, "sbsds",
 						"invalid character in key", con->request.request, cur, *cur, "-> 400");
+
+					log_error_write(srv, __FILE__, __LINE__, "Sb",
+						"request-header:\n",
+						con->request.request);
+				}
 				return 0;
 			case ' ':
 			case '\t':
@@ -678,8 +688,6 @@
 					i++;
 
 					done = 1;
-
-					break;
 				} else {
 					if (srv->srvconf.log_request_header_on_error) {
 						log_error_write(srv, __FILE__, __LINE__, "s", "CR without LF -> 400");
@@ -693,53 +701,24 @@
 					con->response.keep_alive = 0;
 					return 0;
 				}
-				/* fall thru */
-			case 0: /* illegal characters (faster than a if () :) */
-			case 1:
-			case 2:
-			case 3:
-			case 4:
-			case 5:
-			case 6:
-			case 7:
-			case 8:
-			case 10:
-			case 11:
-			case 12:
-			case 14:
-			case 15:
-			case 16:
-			case 17:
-			case 18:
-			case 19:
-			case 20:
-			case 21:
-			case 22:
-			case 23:
-			case 24:
-			case 25:
-			case 26:
-			case 27:
-			case 28:
-			case 29:
-			case 30:
-			case 31:
-			case 127:
-				con->http_status = 400;
-				con->keep_alive = 0;
-				con->response.keep_alive = 0;
+				break;
+			default:
+				if (*cur < 32 || ((unsigned char)*cur) >= 127) {
+					con->http_status = 400;
+					con->keep_alive = 0;
+					con->response.keep_alive = 0;
 
-				if (srv->srvconf.log_request_header_on_error) {
-					log_error_write(srv, __FILE__, __LINE__, "sbsds",
-						"CTL character in key", con->request.request, cur, *cur, "-> 400");
+					if (srv->srvconf.log_request_header_on_error) {
+						log_error_write(srv, __FILE__, __LINE__, "sbsds",
+							"invalid character in key", con->request.request, cur, *cur, "-> 400");
 
-					log_error_write(srv, __FILE__, __LINE__, "Sb",
-						"request-header:\n",
-						con->request.request);
-				}
+						log_error_write(srv, __FILE__, __LINE__, "Sb",
+							"request-header:\n",
+							con->request.request);
+					}
 
-				return 0;
-			default:
+					return 0;
+				}
 				/* ok */
 				break;
 			}
@@ -1048,6 +1027,7 @@
 			case '\t':
 				/* strip leading WS */
 				if (value == cur) value = cur+1;
+				/* fallthrough */
 			default:
 				if (*cur >= 0 && *cur < 32 && *cur != '\t') {
 					if (srv->srvconf.log_request_header_on_error) {
diff -u lighttpd-1.4.32/src/response.c lighttpd-1.4.35/src/response.c
--- lighttpd-1.4.32/src/response.c	2012-11-07 06:31:42.000000000 -0600
+++ lighttpd-1.4.35/src/response.c	2014-03-06 08:08:00.000000000 -0600
@@ -169,11 +169,19 @@
 			envds->value,
 			(const char *)xe->value->data, xe->value->length
 		);
-		/* pick one of the exported values as "authed user", for example
+		/* pick one of the exported values as "REMOTE_USER", for example
 		 * ssl.verifyclient.username   = "SSL_CLIENT_S_DN_UID" or "SSL_CLIENT_S_DN_emailAddress"
 		 */
 		if (buffer_is_equal(con->conf.ssl_verifyclient_username, envds->key)) {
-			buffer_copy_string_buffer(con->authed_user, envds->value);
+			data_string *ds;
+			if (NULL == (ds = (data_string *)array_get_element(con->environment, "REMOTE_USER"))) {
+				if (NULL == (ds = (data_string *)array_get_unused_element(con->environment, TYPE_STRING))) {
+					ds = data_string_init();
+				}
+				buffer_copy_string(ds->key, "REMOTE_USER");
+				array_insert_unique(con->environment, (data_unset *)ds);
+			}
+			buffer_copy_string_buffer(ds->value, envds->value);
 		}
 		array_insert_unique(con->environment, (data_unset *)envds);
 	}
@@ -264,7 +272,8 @@
 		 *
 		 */
 
-		if (con->conf.is_ssl) {
+		/* initial scheme value. can be overwritten for example by mod_extforward later */
+		if (con->srv_socket->is_ssl) {
 			buffer_copy_string_len(con->uri.scheme, CONST_STR_LEN("https"));
 		} else {
 			buffer_copy_string_len(con->uri.scheme, CONST_STR_LEN("http"));
@@ -296,13 +305,44 @@
 			buffer_copy_string_buffer(con->uri.path_raw, con->request.uri);
 		}
 
+		/* decode url to path
+		 *
+		 * - decode url-encodings  (e.g. %20 -> ' ')
+		 * - remove path-modifiers (e.g. /../)
+		 */
+
+		if (con->request.http_method == HTTP_METHOD_OPTIONS &&
+		    con->uri.path_raw->ptr[0] == '*' && con->uri.path_raw->ptr[1] == '\0') {
+			/* OPTIONS * ... */
+			buffer_copy_string_buffer(con->uri.path, con->uri.path_raw);
+		} else {
+			buffer_copy_string_buffer(srv->tmp_buf, con->uri.path_raw);
+			buffer_urldecode_path(srv->tmp_buf);
+			buffer_path_simplify(con->uri.path, srv->tmp_buf);
+		}
+
+		config_patch_connection(srv, con, COMP_HTTP_URL); /* HTTPurl */
+		config_patch_connection(srv, con, COMP_HTTP_QUERY_STRING); /* HTTPqs */
+
+#ifdef USE_OPENSSL
+		if (con->srv_socket->is_ssl && con->conf.ssl_verifyclient) {
+			https_add_ssl_entries(con);
+		}
+#endif
+
+		/* do we have to downgrade to 1.0 ? */
+		if (!con->conf.allow_http11) {
+			con->request.http_version = HTTP_VERSION_1_0;
+		}
+
 		if (con->conf.log_request_handling) {
 			log_error_write(srv, __FILE__, __LINE__,  "s",  "-- splitting Request-URI");
-			log_error_write(srv, __FILE__, __LINE__,  "sb", "Request-URI  : ", con->request.uri);
-			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-scheme   : ", con->uri.scheme);
-			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-authority: ", con->uri.authority);
-			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-path     : ", con->uri.path_raw);
-			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-query    : ", con->uri.query);
+			log_error_write(srv, __FILE__, __LINE__,  "sb", "Request-URI     : ", con->request.uri);
+			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-scheme      : ", con->uri.scheme);
+			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-authority   : ", con->uri.authority);
+			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-path (raw)  : ", con->uri.path_raw);
+			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-path (clean): ", con->uri.path);
+			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-query       : ", con->uri.query);
 		}
 
 
@@ -327,35 +367,6 @@
 			break;
 		}
 
-		/* build filename
-		 *
-		 * - decode url-encodings  (e.g. %20 -> ' ')
-		 * - remove path-modifiers (e.g. /../)
-		 */
-
-
-
-		if (con->request.http_method == HTTP_METHOD_OPTIONS &&
-		    con->uri.path_raw->ptr[0] == '*' && con->uri.path_raw->ptr[1] == '\0') {
-			/* OPTIONS * ... */
-			buffer_copy_string_buffer(con->uri.path, con->uri.path_raw);
-		} else {
-			buffer_copy_string_buffer(srv->tmp_buf, con->uri.path_raw);
-			buffer_urldecode_path(srv->tmp_buf);
-			buffer_path_simplify(con->uri.path, srv->tmp_buf);
-		}
-
-		if (con->conf.log_request_handling) {
-			log_error_write(srv, __FILE__, __LINE__,  "s",  "-- sanatising URI");
-			log_error_write(srv, __FILE__, __LINE__,  "sb", "URI-path     : ", con->uri.path);
-		}
-
-#ifdef USE_OPENSSL
-		if (con->conf.is_ssl && con->conf.ssl_verifyclient) {
-			https_add_ssl_entries(con);
-		}
-#endif
-
 		/**
 		 *
 		 * call plugins
@@ -364,14 +375,6 @@
 		 *
 		 */
 
-		config_patch_connection(srv, con, COMP_HTTP_URL); /* HTTPurl */
-		config_patch_connection(srv, con, COMP_HTTP_QUERY_STRING); /* HTTPqs */
-
-		/* do we have to downgrade to 1.0 ? */
-		if (!con->conf.allow_http11) {
-			con->request.http_version = HTTP_VERSION_1_0;
-		}
-
 		switch(r = plugins_call_handle_uri_clean(srv, con)) {
 		case HANDLER_GO_ON:
 			break;
@@ -507,9 +510,9 @@
 		 *
 		 */
 
+		buffer_copy_string_buffer(con->physical.basedir, con->physical.doc_root);
 		buffer_copy_string_buffer(con->physical.path, con->physical.doc_root);
 		BUFFER_APPEND_SLASH(con->physical.path);
-		buffer_copy_string_buffer(con->physical.basedir, con->physical.path);
 		if (con->physical.rel_path->used &&
 		    con->physical.rel_path->ptr[0] == '/') {
 			buffer_append_string_len(con->physical.path, con->physical.rel_path->ptr + 1, con->physical.rel_path->used - 2);
@@ -540,6 +543,7 @@
 		if (con->conf.log_request_handling) {
 			log_error_write(srv, __FILE__, __LINE__,  "s",  "-- logical -> physical");
 			log_error_write(srv, __FILE__, __LINE__,  "sb", "Doc-Root     :", con->physical.doc_root);
+			log_error_write(srv, __FILE__, __LINE__,  "sb", "Basedir      :", con->physical.basedir);
 			log_error_write(srv, __FILE__, __LINE__,  "sb", "Rel-Path     :", con->physical.rel_path);
 			log_error_write(srv, __FILE__, __LINE__,  "sb", "Path         :", con->physical.path);
 		}
diff -u lighttpd-1.4.32/src/server.c lighttpd-1.4.35/src/server.c
--- lighttpd-1.4.32/src/server.c	2012-08-31 09:11:20.000000000 -0500
+++ lighttpd-1.4.35/src/server.c	2014-03-06 08:08:00.000000000 -0600
@@ -172,7 +172,7 @@
 	FILE *frandom = NULL;
 
 	server *srv = calloc(1, sizeof(*srv));
-	assert(srv);
+	force_assert(srv);
 #define CLEAN(x) \
 	srv->x = buffer_init();
 
@@ -230,13 +230,13 @@
 	srv->startup_ts = srv->cur_ts;
 
 	srv->conns = calloc(1, sizeof(*srv->conns));
-	assert(srv->conns);
+	force_assert(srv->conns);
 
 	srv->joblist = calloc(1, sizeof(*srv->joblist));
-	assert(srv->joblist);
+	force_assert(srv->joblist);
 
 	srv->fdwaitqueue = calloc(1, sizeof(*srv->fdwaitqueue));
-	assert(srv->fdwaitqueue);
+	force_assert(srv->fdwaitqueue);
 
 	srv->srvconf.modules = array_init();
 	srv->srvconf.modules_dir = buffer_init_string(LIBRARY_DIR);
@@ -314,6 +314,9 @@
 			buffer_free(s->ssl_verifyclient_username);
 #ifdef USE_OPENSSL
 			SSL_CTX_free(s->ssl_ctx);
+			EVP_PKEY_free(s->ssl_pemfile_pkey);
+			X509_free(s->ssl_pemfile_x509);
+			if (NULL != s->ssl_ca_file_cert_names) sk_X509_NAME_pop_free(s->ssl_ca_file_cert_names, X509_NAME_free);
 #endif
 			free(s);
 		}
@@ -817,8 +820,14 @@
 		 * to /etc/group
 		 * */
 		if (NULL != grp) {
-			setgid(grp->gr_gid);
-			setgroups(0, NULL);
+			if (-1 == setgid(grp->gr_gid)) {
+				log_error_write(srv, __FILE__, __LINE__, "ss", "setgid failed: ", strerror(errno));
+				return -1;
+			}
+			if (-1 == setgroups(0, NULL)) {
+				log_error_write(srv, __FILE__, __LINE__, "ss", "setgroups failed: ", strerror(errno));
+				return -1;
+			}
 			if (srv->srvconf.username->used) {
 				initgroups(srv->srvconf.username->ptr, grp->gr_gid);
 			}
@@ -841,7 +850,10 @@
 #ifdef HAVE_PWD_H
 		/* drop root privs */
 		if (NULL != pwd) {
-			setuid(pwd->pw_uid);
+			if (-1 == setuid(pwd->pw_uid)) {
+				log_error_write(srv, __FILE__, __LINE__, "ss", "setuid failed: ", strerror(errno));
+				return -1;
+			}
 		}
 #endif
 #if defined(HAVE_SYS_PRCTL_H) && defined(PR_SET_DUMPABLE)
@@ -937,6 +949,51 @@
 	if (srv->srvconf.dont_daemonize == 0) daemonize();
 #endif
 
+
+#ifdef HAVE_SIGACTION
+	memset(&act, 0, sizeof(act));
+	act.sa_handler = SIG_IGN;
+	sigaction(SIGPIPE, &act, NULL);
+	sigaction(SIGUSR1, &act, NULL);
+# if defined(SA_SIGINFO)
+	act.sa_sigaction = sigaction_handler;
+	sigemptyset(&act.sa_mask);
+	act.sa_flags = SA_SIGINFO;
+# else
+	act.sa_handler = signal_handler;
+	sigemptyset(&act.sa_mask);
+	act.sa_flags = 0;
+# endif
+	sigaction(SIGINT,  &act, NULL);
+	sigaction(SIGTERM, &act, NULL);
+	sigaction(SIGHUP,  &act, NULL);
+	sigaction(SIGALRM, &act, NULL);
+	sigaction(SIGCHLD, &act, NULL);
+
+#elif defined(HAVE_SIGNAL)
+	/* ignore the SIGPIPE from sendfile() */
+	signal(SIGPIPE, SIG_IGN);
+	signal(SIGUSR1, SIG_IGN);
+	signal(SIGALRM, signal_handler);
+	signal(SIGTERM, signal_handler);
+	signal(SIGHUP,  signal_handler);
+	signal(SIGCHLD,  signal_handler);
+	signal(SIGINT,  signal_handler);
+#endif
+
+#ifdef USE_ALARM
+	signal(SIGALRM, signal_handler);
+
+	/* setup periodic timer (1 second) */
+	if (setitimer(ITIMER_REAL, &interval, NULL)) {
+		log_error_write(srv, __FILE__, __LINE__, "s", "setting timer failed");
+		return -1;
+	}
+
+	getitimer(ITIMER_REAL, &interval);
+#endif
+
+
 	srv->gid = getgid();
 	srv->uid = getuid();
 
@@ -944,6 +1001,7 @@
 	if (pid_fd != -1) {
 		buffer_copy_long(srv->tmp_buf, getpid());
 		buffer_append_string_len(srv->tmp_buf, CONST_STR_LEN("\n"));
+		force_assert(srv->tmp_buf->used > 0);
 		write(pid_fd, srv->tmp_buf->ptr, srv->tmp_buf->used - 1);
 		close(pid_fd);
 		pid_fd = -1;
@@ -1011,51 +1069,6 @@
 	}
 
 
-
-
-#ifdef HAVE_SIGACTION
-	memset(&act, 0, sizeof(act));
-	act.sa_handler = SIG_IGN;
-	sigaction(SIGPIPE, &act, NULL);
-	sigaction(SIGUSR1, &act, NULL);
-# if defined(SA_SIGINFO)
-	act.sa_sigaction = sigaction_handler;
-	sigemptyset(&act.sa_mask);
-	act.sa_flags = SA_SIGINFO;
-# else
-	act.sa_handler = signal_handler;
-	sigemptyset(&act.sa_mask);
-	act.sa_flags = 0;
-# endif
-	sigaction(SIGINT,  &act, NULL);
-	sigaction(SIGTERM, &act, NULL);
-	sigaction(SIGHUP,  &act, NULL);
-	sigaction(SIGALRM, &act, NULL);
-	sigaction(SIGCHLD, &act, NULL);
-
-#elif defined(HAVE_SIGNAL)
-	/* ignore the SIGPIPE from sendfile() */
-	signal(SIGPIPE, SIG_IGN);
-	signal(SIGUSR1, SIG_IGN);
-	signal(SIGALRM, signal_handler);
-	signal(SIGTERM, signal_handler);
-	signal(SIGHUP,  signal_handler);
-	signal(SIGCHLD,  signal_handler);
-	signal(SIGINT,  signal_handler);
-#endif
-
-#ifdef USE_ALARM
-	signal(SIGALRM, signal_handler);
-
-	/* setup periodic timer (1 second) */
-	if (setitimer(ITIMER_REAL, &interval, NULL)) {
-		log_error_write(srv, __FILE__, __LINE__, "s", "setting timer failed");
-		return -1;
-	}
-
-	getitimer(ITIMER_REAL, &interval);
-#endif
-
 #ifdef HAVE_FORK
 	/* start watcher and workers */
 	num_childs = srv->srvconf.max_worker;
@@ -1170,18 +1183,17 @@
 #ifdef HAVE_FAM_H
 	/* setup FAM */
 	if (srv->srvconf.stat_cache_engine == STAT_CACHE_ENGINE_FAM) {
-		if (0 != FAMOpen2(srv->stat_cache->fam, "lighttpd")) {
+		if (0 != FAMOpen2(&srv->stat_cache->fam, "lighttpd")) {
 			log_error_write(srv, __FILE__, __LINE__, "s",
 					 "could not open a fam connection, dieing.");
 			return -1;
 		}
 #ifdef HAVE_FAMNOEXISTS
-		FAMNoExists(srv->stat_cache->fam);
+		FAMNoExists(&srv->stat_cache->fam);
 #endif
 
-		srv->stat_cache->fam_fcce_ndx = -1;
-		fdevent_register(srv->ev, FAMCONNECTION_GETFD(srv->stat_cache->fam), stat_cache_handle_fdevent, NULL);
-		fdevent_event_set(srv->ev, &(srv->stat_cache->fam_fcce_ndx), FAMCONNECTION_GETFD(srv->stat_cache->fam), FDEVENT_IN);
+		fdevent_register(srv->ev, FAMCONNECTION_GETFD(&srv->stat_cache->fam), stat_cache_handle_fdevent, NULL);
+		fdevent_event_set(srv->ev, &(srv->stat_cache->fam_fcce_ndx), FAMCONNECTION_GETFD(&srv->stat_cache->fam), FDEVENT_IN);
 	}
 #endif
 
diff -u lighttpd-1.4.32/src/settings.h lighttpd-1.4.35/src/settings.h
--- lighttpd-1.4.32/src/settings.h	2011-08-20 08:07:05.000000000 -0500
+++ lighttpd-1.4.35/src/settings.h	2014-02-25 16:47:55.000000000 -0600
@@ -9,6 +9,12 @@
 # define __USE_GNU /* a hack in my eyes, <fcntl.h> F_SETSIG should work with _GNU_SOURCE */
 #endif
 
+#ifdef __GNUC__
+# define LI_NORETURN __attribute__((noreturn))
+#else
+# define LI_NORETURN
+#endif
+
 #define BV(x) (1 << x)
 
 #define INET_NTOP_CACHE_MAX 4
diff -u lighttpd-1.4.32/src/stat_cache.c lighttpd-1.4.35/src/stat_cache.c
--- lighttpd-1.4.32/src/stat_cache.c	2010-08-17 04:04:38.000000000 -0500
+++ lighttpd-1.4.35/src/stat_cache.c	2014-03-06 08:08:00.000000000 -0600
@@ -69,7 +69,6 @@
 #ifdef HAVE_FAM_H
 typedef struct {
 	FAMRequest *req;
-	FAMConnection *fc;
 
 	buffer *name;
 
@@ -102,21 +101,22 @@
 #endif
 
 stat_cache *stat_cache_init(void) {
-	stat_cache *fc = NULL;
+	stat_cache *sc = NULL;
 
-	fc = calloc(1, sizeof(*fc));
+	sc = calloc(1, sizeof(*sc));
+
+	sc->dir_name = buffer_init();
+	sc->hash_key = buffer_init();
 
-	fc->dir_name = buffer_init();
-	fc->hash_key = buffer_init();
 #ifdef HAVE_FAM_H
-	fc->fam = calloc(1, sizeof(*fc->fam));
+	sc->fam_fcce_ndx = -1;
 #endif
 
 #ifdef DEBUG_STAT_CACHE
 	ctrl.size = 0;
 #endif
 
-	return fc;
+	return sc;
 }
 
 static stat_cache_entry * stat_cache_entry_init(void) {
@@ -153,12 +153,12 @@
 	return fam_dir;
 }
 
-static void fam_dir_entry_free(void *data) {
+static void fam_dir_entry_free(FAMConnection *fc, void *data) {
 	fam_dir_entry *fam_dir = data;
 
 	if (!fam_dir) return;
 
-	FAMCancelMonitor(fam_dir->fc, fam_dir->req);
+	FAMCancelMonitor(fc, fam_dir->req);
 
 	buffer_free(fam_dir->name);
 	free(fam_dir->req);
@@ -177,7 +177,7 @@
 		stat_cache_entry_free(node->data);
 		sc->files = splaytree_delete(sc->files, node->key);
 
-		assert(osize - 1 == splaytree_size(sc->files));
+		force_assert(osize - 1 == splaytree_size(sc->files));
 	}
 
 	buffer_free(sc->dir_name);
@@ -190,19 +190,21 @@
 
 		osize = sc->dirs->size;
 
-		fam_dir_entry_free(node->data);
+		fam_dir_entry_free(&sc->fam, node->data);
 		sc->dirs = splaytree_delete(sc->dirs, node->key);
 
 		if (osize == 1) {
-			assert(NULL == sc->dirs);
+			force_assert(NULL == sc->dirs);
 		} else {
-			assert(osize == (sc->dirs->size + 1));
+			force_assert(osize == (sc->dirs->size + 1));
 		}
 	}
 
-	if (sc->fam) {
-		FAMClose(sc->fam);
-		free(sc->fam);
+	if (-1 != sc->fam_fcce_ndx) {
+		/* fd events already gone */
+		sc->fam_fcce_ndx = -1;
+
+		FAMClose(&sc->fam);
 	}
 #endif
 	free(sc);
@@ -246,10 +248,8 @@
 	UNUSED(_fce);
 	/* */
 
-	if ((revent & FDEVENT_IN) &&
-	    sc->fam) {
-
-		events = FAMPending(sc->fam);
+	if (revent & FDEVENT_IN) {
+		events = FAMPending(&sc->fam);
 
 		for (i = 0; i < events; i++) {
 			FAMEvent fe;
@@ -257,7 +257,7 @@
 			splay_tree *node;
 			int ndx, j;
 
-			FAMNextEvent(sc->fam, &fe);
+			FAMNextEvent(&sc->fam, &fe);
 
 			/* handle event */
 
@@ -287,10 +287,10 @@
 					if (node && (node->key == ndx)) {
 						int osize = splaytree_size(sc->dirs);
 
-						fam_dir_entry_free(node->data);
+						fam_dir_entry_free(&sc->fam, node->data);
 						sc->dirs = splaytree_delete(sc->dirs, ndx);
 
-						assert(osize - 1 == splaytree_size(sc->dirs));
+						force_assert(osize - 1 == splaytree_size(sc->dirs));
 					}
 				}
 				break;
@@ -302,15 +302,10 @@
 
 	if (revent & FDEVENT_HUP) {
 		/* fam closed the connection */
-		srv->stat_cache->fam_fcce_ndx = -1;
+		fdevent_event_del(srv->ev, &(sc->fam_fcce_ndx), FAMCONNECTION_GETFD(&sc->fam));
+		fdevent_unregister(srv->ev, FAMCONNECTION_GETFD(&sc->fam));
 
-		fdevent_event_del(srv->ev, &(sc->fam_fcce_ndx), FAMCONNECTION_GETFD(sc->fam));
-		fdevent_unregister(srv->ev, FAMCONNECTION_GETFD(sc->fam));
-
-		FAMClose(sc->fam);
-		free(sc->fam);
-
-		sc->fam = NULL;
+		FAMClose(&sc->fam);
 	}
 
 	return HANDLER_GO_ON;
@@ -397,7 +392,7 @@
 	if (sc->files && (sc->files->key == file_ndx)) {
 #ifdef DEBUG_STAT_CACHE
 		/* it was in the cache */
-		assert(i < ctrl.used);
+		force_assert(i < ctrl.used);
 #endif
 
 		/* we have seen this file already and
@@ -435,7 +430,7 @@
 			log_error_write(srv, __FILE__, __LINE__, "xSB",
 				file_ndx, "was already inserted but not found in cache, ", name);
 		}
-		assert(i == ctrl.used);
+		force_assert(i == ctrl.used);
 #endif
 	}
 
@@ -521,9 +516,9 @@
 
 		ctrl.ptr[ctrl.used++] = file_ndx;
 
-		assert(sc->files);
-		assert(sc->files->data == sce);
-		assert(osize + 1 == splaytree_size(sc->files));
+		force_assert(sc->files);
+		force_assert(sc->files->data == sce);
+		force_assert(osize + 1 == splaytree_size(sc->files));
 #endif
 	}
 
@@ -625,12 +620,10 @@
 	}
 
 #ifdef HAVE_FAM_H
-	if (sc->fam &&
-	    (srv->srvconf.stat_cache_engine == STAT_CACHE_ENGINE_FAM)) {
+	if (srv->srvconf.stat_cache_engine == STAT_CACHE_ENGINE_FAM) {
 		/* is this directory already registered ? */
 		if (!dir_node) {
 			fam_dir = fam_dir_entry_init();
-			fam_dir->fc = sc->fam;
 
 			buffer_copy_string_buffer(fam_dir->name, sc->dir_name);
 
@@ -638,7 +631,7 @@
 
 			fam_dir->req = calloc(1, sizeof(FAMRequest));
 
-			if (0 != FAMMonitorDirectory(sc->fam, fam_dir->name->ptr,
+			if (0 != FAMMonitorDirectory(&sc->fam, fam_dir->name->ptr,
 						     fam_dir->req, fam_dir)) {
 
 				log_error_write(srv, __FILE__, __LINE__, "sbsbs",
@@ -647,18 +640,19 @@
 						"file:", name,
 						FamErrlist[FAMErrno]);
 
-				fam_dir_entry_free(fam_dir);
+				fam_dir_entry_free(&sc->fam, fam_dir);
+				fam_dir = NULL;
 			} else {
 				int osize = 0;
 
-			       	if (sc->dirs) {
+				if (sc->dirs) {
 					osize = sc->dirs->size;
 				}
 
 				sc->dirs = splaytree_insert(sc->dirs, dir_ndx, fam_dir);
-				assert(sc->dirs);
-				assert(sc->dirs->data == fam_dir);
-				assert(osize == (sc->dirs->size - 1));
+				force_assert(sc->dirs);
+				force_assert(sc->dirs->data == fam_dir);
+				force_assert(osize == (sc->dirs->size - 1));
 			}
 		} else {
 			fam_dir = dir_node->data;
@@ -668,7 +662,6 @@
 
 		if (fam_dir) {
 			sce->dir_version = fam_dir->version;
-			sce->dir_ndx     = dir_ndx;
 		}
 	}
 #endif
@@ -713,7 +706,7 @@
 
 	if (!sc->files) return 0;
 
-	keys = calloc(1, sizeof(size_t) * sc->files->size);
+	keys = calloc(1, sizeof(int) * sc->files->size);
 
 	stat_cache_tag_old_entries(srv, sc->files, keys, &max_ndx);
 
@@ -742,7 +735,7 @@
 				}
 			}
 
-			assert(osize - 1 == splaytree_size(sc->files));
+			force_assert(osize - 1 == splaytree_size(sc->files));
 #endif
 		}
 	}
